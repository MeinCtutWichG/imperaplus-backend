//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v4.2.6060.41613 (http://NSwag.org)
// </auto-generated>
//----------------------

export class AccountClient {
    baseUrl: string = undefined; 
    beforeSend: any = undefined; 

    constructor(baseUrl?: string) {
        this.baseUrl = baseUrl !== undefined ? baseUrl : ""; 
    }

    /**
     * Checks if a username is available
     * @userName Username to check
     * @return True if username is available
     */
    getUserNameAvailable(userName: string): Q.Promise<any> {
        return Q.Promise<any>((resolve, reject) => {
            this.getUserNameAvailableWithCallbacks(userName, (result) => resolve(result), (exception, reason) => reject(exception));
        });
    }
    
    private getUserNameAvailableWithCallbacks(userName: string, onSuccess?: (result: any) => void, onFail?: (exception: string, reason: string) => void) {
        var url = this.baseUrl + "/api/Account/UserNameAvailable?"; 

        if (userName === undefined)
            throw new Error("The parameter 'userName' must be defined.");
        else
            url += "userName=" + encodeURIComponent("" + userName) + "&"; 

        var content = "";

        jQuery.ajax({
            url: url,
            beforeSend: this.beforeSend,
            type: "get",
            data: content,
            dataType: "text",
            headers: {
                "Content-Type": "application/json; charset=UTF-8"
            }
        }).done((data, textStatus, xhr) => {
            this.processGetUserNameAvailableWithCallbacks(url, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processGetUserNameAvailableWithCallbacks(url, xhr, onSuccess, onFail);
        });
    }

    private processGetUserNameAvailableWithCallbacks(url: string, xhr: any, onSuccess?: any, onFail?: any) {
        try {
            var result = this.processGetUserNameAvailable(xhr);
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    private processGetUserNameAvailable(xhr: any) {
        var data = xhr.responseText; 
        var status = xhr.status.toString(); 

        if (status === "200") {
            var result200: any = null; 
            if (data !== undefined && data !== null && data !== "") {
                result200 = data;
            }
            return result200;
        }
        else
        {
            throw new Error("error_no_callback_for_the_received_http_status");
        }
    }

    /**
     * Get user information
     */
    getUserInfo(): Q.Promise<UserInfo> {
        return Q.Promise<UserInfo>((resolve, reject) => {
            this.getUserInfoWithCallbacks((result) => resolve(result), (exception, reason) => reject(exception));
        });
    }
    
    private getUserInfoWithCallbacks(onSuccess?: (result: UserInfo) => void, onFail?: (exception: string, reason: string) => void) {
        var url = this.baseUrl + "/api/Account/UserInfo?"; 

        var content = "";

        jQuery.ajax({
            url: url,
            beforeSend: this.beforeSend,
            type: "get",
            data: content,
            dataType: "text",
            headers: {
                "Content-Type": "application/json; charset=UTF-8"
            }
        }).done((data, textStatus, xhr) => {
            this.processGetUserInfoWithCallbacks(url, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processGetUserInfoWithCallbacks(url, xhr, onSuccess, onFail);
        });
    }

    private processGetUserInfoWithCallbacks(url: string, xhr: any, onSuccess?: any, onFail?: any) {
        try {
            var result = this.processGetUserInfo(xhr);
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    private processGetUserInfo(xhr: any) {
        var data = xhr.responseText; 
        var status = xhr.status.toString(); 

        if (status === "200") {
            var result200: UserInfo = null; 
            if (data !== undefined && data !== null && data !== "") {
                var resultData200 = data === "" ? null : jQuery.parseJSON(data);
                result200 = resultData200 ? UserInfo.fromJS(resultData200) : null;
            }
            return result200;
        }
        else
        {
            throw new Error("error_no_callback_for_the_received_http_status");
        }
    }

    /**
     * Get user information for an external user (i.e., just logged in using an external provider)
     */
    getExternalUserInfo(): Q.Promise<UserInfo> {
        return Q.Promise<UserInfo>((resolve, reject) => {
            this.getExternalUserInfoWithCallbacks((result) => resolve(result), (exception, reason) => reject(exception));
        });
    }
    
    private getExternalUserInfoWithCallbacks(onSuccess?: (result: UserInfo) => void, onFail?: (exception: string, reason: string) => void) {
        var url = this.baseUrl + "/api/Account/ExternalUserInfo?"; 

        var content = "";

        jQuery.ajax({
            url: url,
            beforeSend: this.beforeSend,
            type: "get",
            data: content,
            dataType: "text",
            headers: {
                "Content-Type": "application/json; charset=UTF-8"
            }
        }).done((data, textStatus, xhr) => {
            this.processGetExternalUserInfoWithCallbacks(url, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processGetExternalUserInfoWithCallbacks(url, xhr, onSuccess, onFail);
        });
    }

    private processGetExternalUserInfoWithCallbacks(url: string, xhr: any, onSuccess?: any, onFail?: any) {
        try {
            var result = this.processGetExternalUserInfo(xhr);
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    private processGetExternalUserInfo(xhr: any) {
        var data = xhr.responseText; 
        var status = xhr.status.toString(); 

        if (status === "200") {
            var result200: UserInfo = null; 
            if (data !== undefined && data !== null && data !== "") {
                var resultData200 = data === "" ? null : jQuery.parseJSON(data);
                result200 = resultData200 ? UserInfo.fromJS(resultData200) : null;
            }
            return result200;
        }
        else
        {
            throw new Error("error_no_callback_for_the_received_http_status");
        }
    }

    logout(): Q.Promise<any> {
        return Q.Promise<any>((resolve, reject) => {
            this.logoutWithCallbacks((result) => resolve(result), (exception, reason) => reject(exception));
        });
    }
    
    private logoutWithCallbacks(onSuccess?: (result: any) => void, onFail?: (exception: string, reason: string) => void) {
        var url = this.baseUrl + "/api/Account/Logout?"; 

        var content = "";

        jQuery.ajax({
            url: url,
            beforeSend: this.beforeSend,
            type: "post",
            data: content,
            dataType: "text",
            headers: {
                "Content-Type": "application/json; charset=UTF-8"
            }
        }).done((data, textStatus, xhr) => {
            this.processLogoutWithCallbacks(url, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processLogoutWithCallbacks(url, xhr, onSuccess, onFail);
        });
    }

    private processLogoutWithCallbacks(url: string, xhr: any, onSuccess?: any, onFail?: any) {
        try {
            var result = this.processLogout(xhr);
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    private processLogout(xhr: any) {
        var data = xhr.responseText; 
        var status = xhr.status.toString(); 

        if (status === "200") {
            var result200: any = null; 
            if (data !== undefined && data !== null && data !== "") {
                result200 = data;
            }
            return result200;
        }
        else
        {
            throw new Error("error_no_callback_for_the_received_http_status");
        }
    }

    getManageInfo(returnUrl: string, generateState: boolean): Q.Promise<ManageInfoViewModel> {
        return Q.Promise<ManageInfoViewModel>((resolve, reject) => {
            this.getManageInfoWithCallbacks(returnUrl, generateState, (result) => resolve(result), (exception, reason) => reject(exception));
        });
    }
    
    private getManageInfoWithCallbacks(returnUrl: string, generateState: boolean, onSuccess?: (result: ManageInfoViewModel) => void, onFail?: (exception: string, reason: string) => void) {
        var url = this.baseUrl + "/api/Account/ManageInfo?"; 

        if (returnUrl === undefined)
            throw new Error("The parameter 'returnUrl' must be defined.");
        else
            url += "returnUrl=" + encodeURIComponent("" + returnUrl) + "&"; 
        if (generateState === null)
            throw new Error("The parameter 'generateState' cannot be null.");
        else if (generateState !== undefined)
            url += "generateState=" + encodeURIComponent("" + generateState) + "&"; 

        var content = "";

        jQuery.ajax({
            url: url,
            beforeSend: this.beforeSend,
            type: "get",
            data: content,
            dataType: "text",
            headers: {
                "Content-Type": "application/json; charset=UTF-8"
            }
        }).done((data, textStatus, xhr) => {
            this.processGetManageInfoWithCallbacks(url, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processGetManageInfoWithCallbacks(url, xhr, onSuccess, onFail);
        });
    }

    private processGetManageInfoWithCallbacks(url: string, xhr: any, onSuccess?: any, onFail?: any) {
        try {
            var result = this.processGetManageInfo(xhr);
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    private processGetManageInfo(xhr: any) {
        var data = xhr.responseText; 
        var status = xhr.status.toString(); 

        if (status === "200") {
            var result200: ManageInfoViewModel = null; 
            if (data !== undefined && data !== null && data !== "") {
                var resultData200 = data === "" ? null : jQuery.parseJSON(data);
                result200 = resultData200 ? ManageInfoViewModel.fromJS(resultData200) : null;
            }
            return result200;
        }
        else
        {
            throw new Error("error_no_callback_for_the_received_http_status");
        }
    }

    changePassword(model: ChangePasswordBindingModel): Q.Promise<any> {
        return Q.Promise<any>((resolve, reject) => {
            this.changePasswordWithCallbacks(model, (result) => resolve(result), (exception, reason) => reject(exception));
        });
    }
    
    private changePasswordWithCallbacks(model: ChangePasswordBindingModel, onSuccess?: (result: any) => void, onFail?: (exception: string, reason: string) => void) {
        var url = this.baseUrl + "/api/Account/ChangePassword?"; 

        var content = JSON.stringify(model ? model.toJS() : null);

        jQuery.ajax({
            url: url,
            beforeSend: this.beforeSend,
            type: "post",
            data: content,
            dataType: "text",
            headers: {
                "Content-Type": "application/json; charset=UTF-8"
            }
        }).done((data, textStatus, xhr) => {
            this.processChangePasswordWithCallbacks(url, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processChangePasswordWithCallbacks(url, xhr, onSuccess, onFail);
        });
    }

    private processChangePasswordWithCallbacks(url: string, xhr: any, onSuccess?: any, onFail?: any) {
        try {
            var result = this.processChangePassword(xhr);
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    private processChangePassword(xhr: any) {
        var data = xhr.responseText; 
        var status = xhr.status.toString(); 

        if (status === "200") {
            var result200: any = null; 
            if (data !== undefined && data !== null && data !== "") {
                result200 = data;
            }
            return result200;
        }
        else
        {
            throw new Error("error_no_callback_for_the_received_http_status");
        }
    }

    setPassword(model: SetPasswordBindingModel): Q.Promise<any> {
        return Q.Promise<any>((resolve, reject) => {
            this.setPasswordWithCallbacks(model, (result) => resolve(result), (exception, reason) => reject(exception));
        });
    }
    
    private setPasswordWithCallbacks(model: SetPasswordBindingModel, onSuccess?: (result: any) => void, onFail?: (exception: string, reason: string) => void) {
        var url = this.baseUrl + "/api/Account/SetPassword?"; 

        var content = JSON.stringify(model ? model.toJS() : null);

        jQuery.ajax({
            url: url,
            beforeSend: this.beforeSend,
            type: "post",
            data: content,
            dataType: "text",
            headers: {
                "Content-Type": "application/json; charset=UTF-8"
            }
        }).done((data, textStatus, xhr) => {
            this.processSetPasswordWithCallbacks(url, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processSetPasswordWithCallbacks(url, xhr, onSuccess, onFail);
        });
    }

    private processSetPasswordWithCallbacks(url: string, xhr: any, onSuccess?: any, onFail?: any) {
        try {
            var result = this.processSetPassword(xhr);
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    private processSetPassword(xhr: any) {
        var data = xhr.responseText; 
        var status = xhr.status.toString(); 

        if (status === "200") {
            var result200: any = null; 
            if (data !== undefined && data !== null && data !== "") {
                result200 = data;
            }
            return result200;
        }
        else
        {
            throw new Error("error_no_callback_for_the_received_http_status");
        }
    }

    setLanguage(model: LanguageModel): Q.Promise<any> {
        return Q.Promise<any>((resolve, reject) => {
            this.setLanguageWithCallbacks(model, (result) => resolve(result), (exception, reason) => reject(exception));
        });
    }
    
    private setLanguageWithCallbacks(model: LanguageModel, onSuccess?: (result: any) => void, onFail?: (exception: string, reason: string) => void) {
        var url = this.baseUrl + "/api/Account/Language?"; 

        var content = JSON.stringify(model ? model.toJS() : null);

        jQuery.ajax({
            url: url,
            beforeSend: this.beforeSend,
            type: "post",
            data: content,
            dataType: "text",
            headers: {
                "Content-Type": "application/json; charset=UTF-8"
            }
        }).done((data, textStatus, xhr) => {
            this.processSetLanguageWithCallbacks(url, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processSetLanguageWithCallbacks(url, xhr, onSuccess, onFail);
        });
    }

    private processSetLanguageWithCallbacks(url: string, xhr: any, onSuccess?: any, onFail?: any) {
        try {
            var result = this.processSetLanguage(xhr);
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    private processSetLanguage(xhr: any) {
        var data = xhr.responseText; 
        var status = xhr.status.toString(); 

        if (status === "200") {
            var result200: any = null; 
            if (data !== undefined && data !== null && data !== "") {
                result200 = data;
            }
            return result200;
        }
        else
        {
            throw new Error("error_no_callback_for_the_received_http_status");
        }
    }

    addExternalLogin(model: AddExternalLoginBindingModel): Q.Promise<any> {
        return Q.Promise<any>((resolve, reject) => {
            this.addExternalLoginWithCallbacks(model, (result) => resolve(result), (exception, reason) => reject(exception));
        });
    }
    
    private addExternalLoginWithCallbacks(model: AddExternalLoginBindingModel, onSuccess?: (result: any) => void, onFail?: (exception: string, reason: string) => void) {
        var url = this.baseUrl + "/api/Account/AddExternalLogin?"; 

        var content = JSON.stringify(model ? model.toJS() : null);

        jQuery.ajax({
            url: url,
            beforeSend: this.beforeSend,
            type: "post",
            data: content,
            dataType: "text",
            headers: {
                "Content-Type": "application/json; charset=UTF-8"
            }
        }).done((data, textStatus, xhr) => {
            this.processAddExternalLoginWithCallbacks(url, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processAddExternalLoginWithCallbacks(url, xhr, onSuccess, onFail);
        });
    }

    private processAddExternalLoginWithCallbacks(url: string, xhr: any, onSuccess?: any, onFail?: any) {
        try {
            var result = this.processAddExternalLogin(xhr);
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    private processAddExternalLogin(xhr: any) {
        var data = xhr.responseText; 
        var status = xhr.status.toString(); 

        if (status === "200") {
            var result200: any = null; 
            if (data !== undefined && data !== null && data !== "") {
                result200 = data;
            }
            return result200;
        }
        else
        {
            throw new Error("error_no_callback_for_the_received_http_status");
        }
    }

    removeLogin(model: RemoveLoginBindingModel): Q.Promise<any> {
        return Q.Promise<any>((resolve, reject) => {
            this.removeLoginWithCallbacks(model, (result) => resolve(result), (exception, reason) => reject(exception));
        });
    }
    
    private removeLoginWithCallbacks(model: RemoveLoginBindingModel, onSuccess?: (result: any) => void, onFail?: (exception: string, reason: string) => void) {
        var url = this.baseUrl + "/api/Account/RemoveLogin?"; 

        var content = JSON.stringify(model ? model.toJS() : null);

        jQuery.ajax({
            url: url,
            beforeSend: this.beforeSend,
            type: "post",
            data: content,
            dataType: "text",
            headers: {
                "Content-Type": "application/json; charset=UTF-8"
            }
        }).done((data, textStatus, xhr) => {
            this.processRemoveLoginWithCallbacks(url, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processRemoveLoginWithCallbacks(url, xhr, onSuccess, onFail);
        });
    }

    private processRemoveLoginWithCallbacks(url: string, xhr: any, onSuccess?: any, onFail?: any) {
        try {
            var result = this.processRemoveLogin(xhr);
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    private processRemoveLogin(xhr: any) {
        var data = xhr.responseText; 
        var status = xhr.status.toString(); 

        if (status === "200") {
            var result200: any = null; 
            if (data !== undefined && data !== null && data !== "") {
                result200 = data;
            }
            return result200;
        }
        else
        {
            throw new Error("error_no_callback_for_the_received_http_status");
        }
    }

    getExternalLogin(provider: string): Q.Promise<any> {
        return Q.Promise<any>((resolve, reject) => {
            this.getExternalLoginWithCallbacks(provider, (result) => resolve(result), (exception, reason) => reject(exception));
        });
    }
    
    private getExternalLoginWithCallbacks(provider: string, onSuccess?: (result: any) => void, onFail?: (exception: string, reason: string) => void) {
        var url = this.baseUrl + "/api/Account/ExternalLogin?"; 

        if (provider === undefined)
            throw new Error("The parameter 'provider' must be defined.");
        else
            url += "provider=" + encodeURIComponent("" + provider) + "&"; 

        var content = "";

        jQuery.ajax({
            url: url,
            beforeSend: this.beforeSend,
            type: "get",
            data: content,
            dataType: "text",
            headers: {
                "Content-Type": "application/json; charset=UTF-8"
            }
        }).done((data, textStatus, xhr) => {
            this.processGetExternalLoginWithCallbacks(url, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processGetExternalLoginWithCallbacks(url, xhr, onSuccess, onFail);
        });
    }

    private processGetExternalLoginWithCallbacks(url: string, xhr: any, onSuccess?: any, onFail?: any) {
        try {
            var result = this.processGetExternalLogin(xhr);
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    private processGetExternalLogin(xhr: any) {
        var data = xhr.responseText; 
        var status = xhr.status.toString(); 

        if (status === "200") {
            var result200: any = null; 
            if (data !== undefined && data !== null && data !== "") {
                result200 = data;
            }
            return result200;
        }
        else
        {
            throw new Error("error_no_callback_for_the_received_http_status");
        }
    }

    getExternalLogins(returnUrl: string, generateState: boolean): Q.Promise<ExternalLoginViewModel[]> {
        return Q.Promise<ExternalLoginViewModel[]>((resolve, reject) => {
            this.getExternalLoginsWithCallbacks(returnUrl, generateState, (result) => resolve(result), (exception, reason) => reject(exception));
        });
    }
    
    private getExternalLoginsWithCallbacks(returnUrl: string, generateState: boolean, onSuccess?: (result: ExternalLoginViewModel[]) => void, onFail?: (exception: string, reason: string) => void) {
        var url = this.baseUrl + "/api/Account/ExternalLogins?"; 

        if (returnUrl === undefined)
            throw new Error("The parameter 'returnUrl' must be defined.");
        else
            url += "returnUrl=" + encodeURIComponent("" + returnUrl) + "&"; 
        if (generateState === null)
            throw new Error("The parameter 'generateState' cannot be null.");
        else if (generateState !== undefined)
            url += "generateState=" + encodeURIComponent("" + generateState) + "&"; 

        var content = "";

        jQuery.ajax({
            url: url,
            beforeSend: this.beforeSend,
            type: "get",
            data: content,
            dataType: "text",
            headers: {
                "Content-Type": "application/json; charset=UTF-8"
            }
        }).done((data, textStatus, xhr) => {
            this.processGetExternalLoginsWithCallbacks(url, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processGetExternalLoginsWithCallbacks(url, xhr, onSuccess, onFail);
        });
    }

    private processGetExternalLoginsWithCallbacks(url: string, xhr: any, onSuccess?: any, onFail?: any) {
        try {
            var result = this.processGetExternalLogins(xhr);
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    private processGetExternalLogins(xhr: any) {
        var data = xhr.responseText; 
        var status = xhr.status.toString(); 

        if (status === "200") {
            var result200: ExternalLoginViewModel[] = null; 
            if (data !== undefined && data !== null && data !== "") {
                var resultData200 = data === "" ? null : jQuery.parseJSON(data);
                if (resultData200 && resultData200.constructor === Array) {
                    result200 = [];
                    for (let item of resultData200)
                        result200.push(ExternalLoginViewModel.fromJS(item));
                }
            }
            return result200;
        }
        else
        {
            throw new Error("error_no_callback_for_the_received_http_status");
        }
    }

    register(model: RegisterBindingModel): Q.Promise<any> {
        return Q.Promise<any>((resolve, reject) => {
            this.registerWithCallbacks(model, (result) => resolve(result), (exception, reason) => reject(exception));
        });
    }
    
    private registerWithCallbacks(model: RegisterBindingModel, onSuccess?: (result: any) => void, onFail?: (exception: string, reason: string) => void) {
        var url = this.baseUrl + "/api/Account/Register?"; 

        var content = JSON.stringify(model ? model.toJS() : null);

        jQuery.ajax({
            url: url,
            beforeSend: this.beforeSend,
            type: "post",
            data: content,
            dataType: "text",
            headers: {
                "Content-Type": "application/json; charset=UTF-8"
            }
        }).done((data, textStatus, xhr) => {
            this.processRegisterWithCallbacks(url, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processRegisterWithCallbacks(url, xhr, onSuccess, onFail);
        });
    }

    private processRegisterWithCallbacks(url: string, xhr: any, onSuccess?: any, onFail?: any) {
        try {
            var result = this.processRegister(xhr);
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    private processRegister(xhr: any) {
        var data = xhr.responseText; 
        var status = xhr.status.toString(); 

        if (status === "200") {
            var result200: any = null; 
            if (data !== undefined && data !== null && data !== "") {
                result200 = data;
            }
            return result200;
        }
        else
        {
            throw new Error("error_no_callback_for_the_received_http_status");
        }
    }

    /**
     * Resend the email confirmation account to the given user account
     * @model (optional) 
     */
    resendConfirmationCode(model: ResendConfirmationModel): Q.Promise<any> {
        return Q.Promise<any>((resolve, reject) => {
            this.resendConfirmationCodeWithCallbacks(model, (result) => resolve(result), (exception, reason) => reject(exception));
        });
    }
    
    private resendConfirmationCodeWithCallbacks(model: ResendConfirmationModel, onSuccess?: (result: any) => void, onFail?: (exception: string, reason: string) => void) {
        var url = this.baseUrl + "/api/Account/ResendConfirmation?"; 

        var content = JSON.stringify(model ? model.toJS() : null);

        jQuery.ajax({
            url: url,
            beforeSend: this.beforeSend,
            type: "post",
            data: content,
            dataType: "text",
            headers: {
                "Content-Type": "application/json; charset=UTF-8"
            }
        }).done((data, textStatus, xhr) => {
            this.processResendConfirmationCodeWithCallbacks(url, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processResendConfirmationCodeWithCallbacks(url, xhr, onSuccess, onFail);
        });
    }

    private processResendConfirmationCodeWithCallbacks(url: string, xhr: any, onSuccess?: any, onFail?: any) {
        try {
            var result = this.processResendConfirmationCode(xhr);
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    private processResendConfirmationCode(xhr: any) {
        var data = xhr.responseText; 
        var status = xhr.status.toString(); 

        if (status === "200") {
            var result200: any = null; 
            if (data !== undefined && data !== null && data !== "") {
                result200 = data;
            }
            return result200;
        }
        else
        {
            throw new Error("error_no_callback_for_the_received_http_status");
        }
    }

    /**
     * Confirm user account using code provided in mail
     * @model (optional) Model containing id and code
     * @return Success if successfully activated
     */
    confirmEmail(model: ConfirmationModel): Q.Promise<any> {
        return Q.Promise<any>((resolve, reject) => {
            this.confirmEmailWithCallbacks(model, (result) => resolve(result), (exception, reason) => reject(exception));
        });
    }
    
    private confirmEmailWithCallbacks(model: ConfirmationModel, onSuccess?: (result: any) => void, onFail?: (exception: string, reason: string) => void) {
        var url = this.baseUrl + "/api/Account/ConfirmEmail?"; 

        var content = JSON.stringify(model ? model.toJS() : null);

        jQuery.ajax({
            url: url,
            beforeSend: this.beforeSend,
            type: "post",
            data: content,
            dataType: "text",
            headers: {
                "Content-Type": "application/json; charset=UTF-8"
            }
        }).done((data, textStatus, xhr) => {
            this.processConfirmEmailWithCallbacks(url, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processConfirmEmailWithCallbacks(url, xhr, onSuccess, onFail);
        });
    }

    private processConfirmEmailWithCallbacks(url: string, xhr: any, onSuccess?: any, onFail?: any) {
        try {
            var result = this.processConfirmEmail(xhr);
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    private processConfirmEmail(xhr: any) {
        var data = xhr.responseText; 
        var status = xhr.status.toString(); 

        if (status === "200") {
            var result200: any = null; 
            if (data !== undefined && data !== null && data !== "") {
                result200 = data;
            }
            return result200;
        }
        else
        {
            throw new Error("error_no_callback_for_the_received_http_status");
        }
    }

    /**
     * Request password reset link
     * @model (optional) 
     */
    forgotPassword(model: ForgotPasswordViewModel): Q.Promise<any> {
        return Q.Promise<any>((resolve, reject) => {
            this.forgotPasswordWithCallbacks(model, (result) => resolve(result), (exception, reason) => reject(exception));
        });
    }
    
    private forgotPasswordWithCallbacks(model: ForgotPasswordViewModel, onSuccess?: (result: any) => void, onFail?: (exception: string, reason: string) => void) {
        var url = this.baseUrl + "/api/Account/ForgotPassword?"; 

        var content = JSON.stringify(model ? model.toJS() : null);

        jQuery.ajax({
            url: url,
            beforeSend: this.beforeSend,
            type: "post",
            data: content,
            dataType: "text",
            headers: {
                "Content-Type": "application/json; charset=UTF-8"
            }
        }).done((data, textStatus, xhr) => {
            this.processForgotPasswordWithCallbacks(url, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processForgotPasswordWithCallbacks(url, xhr, onSuccess, onFail);
        });
    }

    private processForgotPasswordWithCallbacks(url: string, xhr: any, onSuccess?: any, onFail?: any) {
        try {
            var result = this.processForgotPassword(xhr);
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    private processForgotPassword(xhr: any) {
        var data = xhr.responseText; 
        var status = xhr.status.toString(); 

        if (status === "200") {
            var result200: any = null; 
            if (data !== undefined && data !== null && data !== "") {
                result200 = data;
            }
            return result200;
        }
        else
        {
            throw new Error("error_no_callback_for_the_received_http_status");
        }
    }

    /**
     * Reset password confirmation
     * @model (optional) 
     */
    resetPassword(model: ResetPasswordViewModel): Q.Promise<any> {
        return Q.Promise<any>((resolve, reject) => {
            this.resetPasswordWithCallbacks(model, (result) => resolve(result), (exception, reason) => reject(exception));
        });
    }
    
    private resetPasswordWithCallbacks(model: ResetPasswordViewModel, onSuccess?: (result: any) => void, onFail?: (exception: string, reason: string) => void) {
        var url = this.baseUrl + "/api/Account/ResetPassword?"; 

        var content = JSON.stringify(model ? model.toJS() : null);

        jQuery.ajax({
            url: url,
            beforeSend: this.beforeSend,
            type: "post",
            data: content,
            dataType: "text",
            headers: {
                "Content-Type": "application/json; charset=UTF-8"
            }
        }).done((data, textStatus, xhr) => {
            this.processResetPasswordWithCallbacks(url, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processResetPasswordWithCallbacks(url, xhr, onSuccess, onFail);
        });
    }

    private processResetPasswordWithCallbacks(url: string, xhr: any, onSuccess?: any, onFail?: any) {
        try {
            var result = this.processResetPassword(xhr);
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    private processResetPassword(xhr: any) {
        var data = xhr.responseText; 
        var status = xhr.status.toString(); 

        if (status === "200") {
            var result200: any = null; 
            if (data !== undefined && data !== null && data !== "") {
                result200 = data;
            }
            return result200;
        }
        else
        {
            throw new Error("error_no_callback_for_the_received_http_status");
        }
    }

    /**
     * Create user accout for an external login
     * @model (optional) 
     */
    registerExternal(model: RegisterExternalBindingModel): Q.Promise<any> {
        return Q.Promise<any>((resolve, reject) => {
            this.registerExternalWithCallbacks(model, (result) => resolve(result), (exception, reason) => reject(exception));
        });
    }
    
    private registerExternalWithCallbacks(model: RegisterExternalBindingModel, onSuccess?: (result: any) => void, onFail?: (exception: string, reason: string) => void) {
        var url = this.baseUrl + "/api/Account/RegisterExternal?"; 

        var content = JSON.stringify(model ? model.toJS() : null);

        jQuery.ajax({
            url: url,
            beforeSend: this.beforeSend,
            type: "post",
            data: content,
            dataType: "text",
            headers: {
                "Content-Type": "application/json; charset=UTF-8"
            }
        }).done((data, textStatus, xhr) => {
            this.processRegisterExternalWithCallbacks(url, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processRegisterExternalWithCallbacks(url, xhr, onSuccess, onFail);
        });
    }

    private processRegisterExternalWithCallbacks(url: string, xhr: any, onSuccess?: any, onFail?: any) {
        try {
            var result = this.processRegisterExternal(xhr);
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    private processRegisterExternal(xhr: any) {
        var data = xhr.responseText; 
        var status = xhr.status.toString(); 

        if (status === "200") {
            var result200: any = null; 
            if (data !== undefined && data !== null && data !== "") {
                result200 = data;
            }
            return result200;
        }
        else
        {
            throw new Error("error_no_callback_for_the_received_http_status");
        }
    }
}

export class HistoryClient {
    baseUrl: string = undefined; 
    beforeSend: any = undefined; 

    constructor(baseUrl?: string) {
        this.baseUrl = baseUrl !== undefined ? baseUrl : ""; 
    }

    /**
     * Gets the specified turn including the actions and current state of the map
     */
    getTurn(gameId: number, turnId: number): Q.Promise<HistoryTurn> {
        return Q.Promise<HistoryTurn>((resolve, reject) => {
            this.getTurnWithCallbacks(gameId, turnId, (result) => resolve(result), (exception, reason) => reject(exception));
        });
    }
    
    private getTurnWithCallbacks(gameId: number, turnId: number, onSuccess?: (result: HistoryTurn) => void, onFail?: (exception: string, reason: string) => void) {
        var url = this.baseUrl + "/api/games/{gameId}/history/{turnId}?"; 

        if (gameId === undefined || gameId === null)
            throw new Error("The parameter 'gameId' must be defined.");
        url = url.replace("{gameId}", encodeURIComponent("" + gameId)); 
        if (turnId === undefined || turnId === null)
            throw new Error("The parameter 'turnId' must be defined.");
        url = url.replace("{turnId}", encodeURIComponent("" + turnId)); 

        var content = "";

        jQuery.ajax({
            url: url,
            beforeSend: this.beforeSend,
            type: "get",
            data: content,
            dataType: "text",
            headers: {
                "Content-Type": "application/json; charset=UTF-8"
            }
        }).done((data, textStatus, xhr) => {
            this.processGetTurnWithCallbacks(url, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processGetTurnWithCallbacks(url, xhr, onSuccess, onFail);
        });
    }

    private processGetTurnWithCallbacks(url: string, xhr: any, onSuccess?: any, onFail?: any) {
        try {
            var result = this.processGetTurn(xhr);
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    private processGetTurn(xhr: any) {
        var data = xhr.responseText; 
        var status = xhr.status.toString(); 

        if (status === "200") {
            var result200: HistoryTurn = null; 
            if (data !== undefined && data !== null && data !== "") {
                var resultData200 = data === "" ? null : jQuery.parseJSON(data);
                result200 = resultData200 ? HistoryTurn.fromJS(resultData200) : null;
            }
            return result200;
        }
        else
        {
            throw new Error("error_no_callback_for_the_received_http_status");
        }
    }
}

export class LadderClient {
    baseUrl: string = undefined; 
    beforeSend: any = undefined; 

    constructor(baseUrl?: string) {
        this.baseUrl = baseUrl !== undefined ? baseUrl : ""; 
    }

    /**
     * Returns active ladders
     * @return List of ladders
     */
    getAll(): Q.Promise<LadderSummary[]> {
        return Q.Promise<LadderSummary[]>((resolve, reject) => {
            this.getAllWithCallbacks((result) => resolve(result), (exception, reason) => reject(exception));
        });
    }
    
    private getAllWithCallbacks(onSuccess?: (result: LadderSummary[]) => void, onFail?: (exception: string, reason: string) => void) {
        var url = this.baseUrl + "/api/ladder?"; 

        var content = "";

        jQuery.ajax({
            url: url,
            beforeSend: this.beforeSend,
            type: "get",
            data: content,
            dataType: "text",
            headers: {
                "Content-Type": "application/json; charset=UTF-8"
            }
        }).done((data, textStatus, xhr) => {
            this.processGetAllWithCallbacks(url, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processGetAllWithCallbacks(url, xhr, onSuccess, onFail);
        });
    }

    private processGetAllWithCallbacks(url: string, xhr: any, onSuccess?: any, onFail?: any) {
        try {
            var result = this.processGetAll(xhr);
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    private processGetAll(xhr: any) {
        var data = xhr.responseText; 
        var status = xhr.status.toString(); 

        if (status === "200") {
            var result200: LadderSummary[] = null; 
            if (data !== undefined && data !== null && data !== "") {
                var resultData200 = data === "" ? null : jQuery.parseJSON(data);
                if (resultData200 && resultData200.constructor === Array) {
                    result200 = [];
                    for (let item of resultData200)
                        result200.push(LadderSummary.fromJS(item));
                }
            }
            return result200;
        }
        else
        {
            throw new Error("error_no_callback_for_the_received_http_status");
        }
    }

    /**
     * Gets ladder identified by given id
     * @ladderId Id of ladder
     */
    get(ladderId: string): Q.Promise<Ladder> {
        return Q.Promise<Ladder>((resolve, reject) => {
            this.getWithCallbacks(ladderId, (result) => resolve(result), (exception, reason) => reject(exception));
        });
    }
    
    private getWithCallbacks(ladderId: string, onSuccess?: (result: Ladder) => void, onFail?: (exception: string, reason: string) => void) {
        var url = this.baseUrl + "/api/ladder/{ladderId}?"; 

        if (ladderId === undefined || ladderId === null)
            throw new Error("The parameter 'ladderId' must be defined.");
        url = url.replace("{ladderId}", encodeURIComponent("" + ladderId)); 

        var content = "";

        jQuery.ajax({
            url: url,
            beforeSend: this.beforeSend,
            type: "get",
            data: content,
            dataType: "text",
            headers: {
                "Content-Type": "application/json; charset=UTF-8"
            }
        }).done((data, textStatus, xhr) => {
            this.processGetWithCallbacks(url, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processGetWithCallbacks(url, xhr, onSuccess, onFail);
        });
    }

    private processGetWithCallbacks(url: string, xhr: any, onSuccess?: any, onFail?: any) {
        try {
            var result = this.processGet(xhr);
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    private processGet(xhr: any) {
        var data = xhr.responseText; 
        var status = xhr.status.toString(); 

        if (status === "200") {
            var result200: Ladder = null; 
            if (data !== undefined && data !== null && data !== "") {
                var resultData200 = data === "" ? null : jQuery.parseJSON(data);
                result200 = resultData200 ? Ladder.fromJS(resultData200) : null;
            }
            return result200;
        }
        else
        {
            throw new Error("error_no_callback_for_the_received_http_status");
        }
    }

    /**
     * Queue up for a new game in the given ladder
     * @ladderId Ladder id
     * @return Status
     */
    postJoin(ladderId: string): Q.Promise<any> {
        return Q.Promise<any>((resolve, reject) => {
            this.postJoinWithCallbacks(ladderId, (result) => resolve(result), (exception, reason) => reject(exception));
        });
    }
    
    private postJoinWithCallbacks(ladderId: string, onSuccess?: (result: any) => void, onFail?: (exception: string, reason: string) => void) {
        var url = this.baseUrl + "/api/ladder/{ladderId}/queue?"; 

        if (ladderId === undefined || ladderId === null)
            throw new Error("The parameter 'ladderId' must be defined.");
        url = url.replace("{ladderId}", encodeURIComponent("" + ladderId)); 

        var content = "";

        jQuery.ajax({
            url: url,
            beforeSend: this.beforeSend,
            type: "post",
            data: content,
            dataType: "text",
            headers: {
                "Content-Type": "application/json; charset=UTF-8"
            }
        }).done((data, textStatus, xhr) => {
            this.processPostJoinWithCallbacks(url, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processPostJoinWithCallbacks(url, xhr, onSuccess, onFail);
        });
    }

    private processPostJoinWithCallbacks(url: string, xhr: any, onSuccess?: any, onFail?: any) {
        try {
            var result = this.processPostJoin(xhr);
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    private processPostJoin(xhr: any) {
        var data = xhr.responseText; 
        var status = xhr.status.toString(); 

        if (status === "200") {
            var result200: any = null; 
            if (data !== undefined && data !== null && data !== "") {
                result200 = data;
            }
            return result200;
        }
        else
        {
            throw new Error("error_no_callback_for_the_received_http_status");
        }
    }

    /**
     * Gets ladder standings
     * @ladderId Id of ladder
     * @start (optional) Items to skip before returning
     * @count (optional) Count of standings to return
     */
    getStandings(ladderId: string, start: number, count: number): Q.Promise<LadderStanding[]> {
        return Q.Promise<LadderStanding[]>((resolve, reject) => {
            this.getStandingsWithCallbacks(ladderId, start, count, (result) => resolve(result), (exception, reason) => reject(exception));
        });
    }
    
    private getStandingsWithCallbacks(ladderId: string, start: number, count: number, onSuccess?: (result: LadderStanding[]) => void, onFail?: (exception: string, reason: string) => void) {
        var url = this.baseUrl + "/api/ladder/{ladderId}/standings?"; 

        if (ladderId === undefined || ladderId === null)
            throw new Error("The parameter 'ladderId' must be defined.");
        url = url.replace("{ladderId}", encodeURIComponent("" + ladderId)); 

        if (start === null)
            throw new Error("The parameter 'start' cannot be null.");
        else if (start !== undefined)
            url += "start=" + encodeURIComponent("" + start) + "&"; 
        if (count === null)
            throw new Error("The parameter 'count' cannot be null.");
        else if (count !== undefined)
            url += "count=" + encodeURIComponent("" + count) + "&"; 

        var content = "";

        jQuery.ajax({
            url: url,
            beforeSend: this.beforeSend,
            type: "get",
            data: content,
            dataType: "text",
            headers: {
                "Content-Type": "application/json; charset=UTF-8"
            }
        }).done((data, textStatus, xhr) => {
            this.processGetStandingsWithCallbacks(url, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processGetStandingsWithCallbacks(url, xhr, onSuccess, onFail);
        });
    }

    private processGetStandingsWithCallbacks(url: string, xhr: any, onSuccess?: any, onFail?: any) {
        try {
            var result = this.processGetStandings(xhr);
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    private processGetStandings(xhr: any) {
        var data = xhr.responseText; 
        var status = xhr.status.toString(); 

        if (status === "200") {
            var result200: LadderStanding[] = null; 
            if (data !== undefined && data !== null && data !== "") {
                var resultData200 = data === "" ? null : jQuery.parseJSON(data);
                if (resultData200 && resultData200.constructor === Array) {
                    result200 = [];
                    for (let item of resultData200)
                        result200.push(LadderStanding.fromJS(item));
                }
            }
            return result200;
        }
        else
        {
            throw new Error("error_no_callback_for_the_received_http_status");
        }
    }
}

export class MapClient {
    baseUrl: string = undefined; 
    beforeSend: any = undefined; 

    constructor(baseUrl?: string) {
        this.baseUrl = baseUrl !== undefined ? baseUrl : ""; 
    }

    getAllSummary(): Q.Promise<MapTemplateDescriptor[]> {
        return Q.Promise<MapTemplateDescriptor[]>((resolve, reject) => {
            this.getAllSummaryWithCallbacks((result) => resolve(result), (exception, reason) => reject(exception));
        });
    }
    
    private getAllSummaryWithCallbacks(onSuccess?: (result: MapTemplateDescriptor[]) => void, onFail?: (exception: string, reason: string) => void) {
        var url = this.baseUrl + "/api/map?"; 

        var content = "";

        jQuery.ajax({
            url: url,
            beforeSend: this.beforeSend,
            type: "get",
            data: content,
            dataType: "text",
            headers: {
                "Content-Type": "application/json; charset=UTF-8"
            }
        }).done((data, textStatus, xhr) => {
            this.processGetAllSummaryWithCallbacks(url, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processGetAllSummaryWithCallbacks(url, xhr, onSuccess, onFail);
        });
    }

    private processGetAllSummaryWithCallbacks(url: string, xhr: any, onSuccess?: any, onFail?: any) {
        try {
            var result = this.processGetAllSummary(xhr);
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    private processGetAllSummary(xhr: any) {
        var data = xhr.responseText; 
        var status = xhr.status.toString(); 

        if (status === "200") {
            var result200: MapTemplateDescriptor[] = null; 
            if (data !== undefined && data !== null && data !== "") {
                var resultData200 = data === "" ? null : jQuery.parseJSON(data);
                if (resultData200 && resultData200.constructor === Array) {
                    result200 = [];
                    for (let item of resultData200)
                        result200.push(MapTemplateDescriptor.fromJS(item));
                }
            }
            return result200;
        }
        else
        {
            throw new Error("error_no_callback_for_the_received_http_status");
        }
    }

    /**
     * Get map template identified by name
     */
    getMapTemplate(name: string): Q.Promise<MapTemplate> {
        return Q.Promise<MapTemplate>((resolve, reject) => {
            this.getMapTemplateWithCallbacks(name, (result) => resolve(result), (exception, reason) => reject(exception));
        });
    }
    
    private getMapTemplateWithCallbacks(name: string, onSuccess?: (result: MapTemplate) => void, onFail?: (exception: string, reason: string) => void) {
        var url = this.baseUrl + "/api/map/{name}?"; 

        if (name === undefined || name === null)
            throw new Error("The parameter 'name' must be defined.");
        url = url.replace("{name}", encodeURIComponent("" + name)); 

        var content = "";

        jQuery.ajax({
            url: url,
            beforeSend: this.beforeSend,
            type: "get",
            data: content,
            dataType: "text",
            headers: {
                "Content-Type": "application/json; charset=UTF-8"
            }
        }).done((data, textStatus, xhr) => {
            this.processGetMapTemplateWithCallbacks(url, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processGetMapTemplateWithCallbacks(url, xhr, onSuccess, onFail);
        });
    }

    private processGetMapTemplateWithCallbacks(url: string, xhr: any, onSuccess?: any, onFail?: any) {
        try {
            var result = this.processGetMapTemplate(xhr);
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    private processGetMapTemplate(xhr: any) {
        var data = xhr.responseText; 
        var status = xhr.status.toString(); 

        if (status === "200") {
            var result200: MapTemplate = null; 
            if (data !== undefined && data !== null && data !== "") {
                var resultData200 = data === "" ? null : jQuery.parseJSON(data);
                result200 = resultData200 ? MapTemplate.fromJS(resultData200) : null;
            }
            return result200;
        }
        else
        {
            throw new Error("error_no_callback_for_the_received_http_status");
        }
    }
}

export class GameClient {
    baseUrl: string = undefined; 
    beforeSend: any = undefined; 

    constructor(baseUrl?: string) {
        this.baseUrl = baseUrl !== undefined ? baseUrl : ""; 
    }

    /**
     * Get a list of open games, excluding games by the current player
     * @return List of games
     */
    getAll(): Q.Promise<GameSummary[]> {
        return Q.Promise<GameSummary[]>((resolve, reject) => {
            this.getAllWithCallbacks((result) => resolve(result), (exception, reason) => reject(exception));
        });
    }
    
    private getAllWithCallbacks(onSuccess?: (result: GameSummary[]) => void, onFail?: (exception: string, reason: string) => void) {
        var url = this.baseUrl + "/api/games/open?"; 

        var content = "";

        jQuery.ajax({
            url: url,
            beforeSend: this.beforeSend,
            type: "get",
            data: content,
            dataType: "text",
            headers: {
                "Content-Type": "application/json; charset=UTF-8"
            }
        }).done((data, textStatus, xhr) => {
            this.processGetAllWithCallbacks(url, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processGetAllWithCallbacks(url, xhr, onSuccess, onFail);
        });
    }

    private processGetAllWithCallbacks(url: string, xhr: any, onSuccess?: any, onFail?: any) {
        try {
            var result = this.processGetAll(xhr);
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    private processGetAll(xhr: any) {
        var data = xhr.responseText; 
        var status = xhr.status.toString(); 

        if (status === "200") {
            var result200: GameSummary[] = null; 
            if (data !== undefined && data !== null && data !== "") {
                var resultData200 = data === "" ? null : jQuery.parseJSON(data);
                if (resultData200 && resultData200.constructor === Array) {
                    result200 = [];
                    for (let item of resultData200)
                        result200.push(GameSummary.fromJS(item));
                }
            }
            return result200;
        }
        else
        {
            throw new Error("error_no_callback_for_the_received_http_status");
        }
    }

    /**
     * Get a list of the games for the current player
     * @return List of games for the current user
     */
    getMy(): Q.Promise<GameSummary[]> {
        return Q.Promise<GameSummary[]>((resolve, reject) => {
            this.getMyWithCallbacks((result) => resolve(result), (exception, reason) => reject(exception));
        });
    }
    
    private getMyWithCallbacks(onSuccess?: (result: GameSummary[]) => void, onFail?: (exception: string, reason: string) => void) {
        var url = this.baseUrl + "/api/games/my?"; 

        var content = "";

        jQuery.ajax({
            url: url,
            beforeSend: this.beforeSend,
            type: "get",
            data: content,
            dataType: "text",
            headers: {
                "Content-Type": "application/json; charset=UTF-8"
            }
        }).done((data, textStatus, xhr) => {
            this.processGetMyWithCallbacks(url, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processGetMyWithCallbacks(url, xhr, onSuccess, onFail);
        });
    }

    private processGetMyWithCallbacks(url: string, xhr: any, onSuccess?: any, onFail?: any) {
        try {
            var result = this.processGetMy(xhr);
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    private processGetMy(xhr: any) {
        var data = xhr.responseText; 
        var status = xhr.status.toString(); 

        if (status === "200") {
            var result200: GameSummary[] = null; 
            if (data !== undefined && data !== null && data !== "") {
                var resultData200 = data === "" ? null : jQuery.parseJSON(data);
                if (resultData200 && resultData200.constructor === Array) {
                    result200 = [];
                    for (let item of resultData200)
                        result200.push(GameSummary.fromJS(item));
                }
            }
            return result200;
        }
        else
        {
            throw new Error("error_no_callback_for_the_received_http_status");
        }
    }

    /**
     * Get list of games where it's the current player's team
     * @return List of games where it's the current user's team
     */
    getMyTurn(): Q.Promise<GameSummary[]> {
        return Q.Promise<GameSummary[]>((resolve, reject) => {
            this.getMyTurnWithCallbacks((result) => resolve(result), (exception, reason) => reject(exception));
        });
    }
    
    private getMyTurnWithCallbacks(onSuccess?: (result: GameSummary[]) => void, onFail?: (exception: string, reason: string) => void) {
        var url = this.baseUrl + "/api/games/myturn?"; 

        var content = "";

        jQuery.ajax({
            url: url,
            beforeSend: this.beforeSend,
            type: "get",
            data: content,
            dataType: "text",
            headers: {
                "Content-Type": "application/json; charset=UTF-8"
            }
        }).done((data, textStatus, xhr) => {
            this.processGetMyTurnWithCallbacks(url, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processGetMyTurnWithCallbacks(url, xhr, onSuccess, onFail);
        });
    }

    private processGetMyTurnWithCallbacks(url: string, xhr: any, onSuccess?: any, onFail?: any) {
        try {
            var result = this.processGetMyTurn(xhr);
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    private processGetMyTurn(xhr: any) {
        var data = xhr.responseText; 
        var status = xhr.status.toString(); 

        if (status === "200") {
            var result200: GameSummary[] = null; 
            if (data !== undefined && data !== null && data !== "") {
                var resultData200 = data === "" ? null : jQuery.parseJSON(data);
                if (resultData200 && resultData200.constructor === Array) {
                    result200 = [];
                    for (let item of resultData200)
                        result200.push(GameSummary.fromJS(item));
                }
            }
            return result200;
        }
        else
        {
            throw new Error("error_no_callback_for_the_received_http_status");
        }
    }

    /**
     * Create a new game
     * @creationOptions (optional) Creation options
     * @return Summary of newly created game
     */
    post(creationOptions: GameCreationOptions): Q.Promise<GameSummary> {
        return Q.Promise<GameSummary>((resolve, reject) => {
            this.postWithCallbacks(creationOptions, (result) => resolve(result), (exception, reason) => reject(exception));
        });
    }
    
    private postWithCallbacks(creationOptions: GameCreationOptions, onSuccess?: (result: GameSummary) => void, onFail?: (exception: string, reason: string) => void) {
        var url = this.baseUrl + "/api/games?"; 

        var content = JSON.stringify(creationOptions ? creationOptions.toJS() : null);

        jQuery.ajax({
            url: url,
            beforeSend: this.beforeSend,
            type: "post",
            data: content,
            dataType: "text",
            headers: {
                "Content-Type": "application/json; charset=UTF-8"
            }
        }).done((data, textStatus, xhr) => {
            this.processPostWithCallbacks(url, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processPostWithCallbacks(url, xhr, onSuccess, onFail);
        });
    }

    private processPostWithCallbacks(url: string, xhr: any, onSuccess?: any, onFail?: any) {
        try {
            var result = this.processPost(xhr);
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    private processPost(xhr: any) {
        var data = xhr.responseText; 
        var status = xhr.status.toString(); 

        if (status === "200") {
            var result200: GameSummary = null; 
            if (data !== undefined && data !== null && data !== "") {
                var resultData200 = data === "" ? null : jQuery.parseJSON(data);
                result200 = resultData200 ? GameSummary.fromJS(resultData200) : null;
            }
            return result200;
        }
        else
        {
            throw new Error("error_no_callback_for_the_received_http_status");
        }
    }

    /**
     * Get detailed information about a single game
     * @gameId Id of the requested game
     * @return Information about the requested game
     */
    get(gameId: number): Q.Promise<Game> {
        return Q.Promise<Game>((resolve, reject) => {
            this.getWithCallbacks(gameId, (result) => resolve(result), (exception, reason) => reject(exception));
        });
    }
    
    private getWithCallbacks(gameId: number, onSuccess?: (result: Game) => void, onFail?: (exception: string, reason: string) => void) {
        var url = this.baseUrl + "/api/games/{gameId}?"; 

        if (gameId === undefined || gameId === null)
            throw new Error("The parameter 'gameId' must be defined.");
        url = url.replace("{gameId}", encodeURIComponent("" + gameId)); 

        var content = "";

        jQuery.ajax({
            url: url,
            beforeSend: this.beforeSend,
            type: "get",
            data: content,
            dataType: "text",
            headers: {
                "Content-Type": "application/json; charset=UTF-8"
            }
        }).done((data, textStatus, xhr) => {
            this.processGetWithCallbacks(url, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processGetWithCallbacks(url, xhr, onSuccess, onFail);
        });
    }

    private processGetWithCallbacks(url: string, xhr: any, onSuccess?: any, onFail?: any) {
        try {
            var result = this.processGet(xhr);
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    private processGet(xhr: any) {
        var data = xhr.responseText; 
        var status = xhr.status.toString(); 

        if (status === "200") {
            var result200: Game = null; 
            if (data !== undefined && data !== null && data !== "") {
                var resultData200 = data === "" ? null : jQuery.parseJSON(data);
                result200 = resultData200 ? Game.fromJS(resultData200) : null;
            }
            return result200;
        }
        else
        {
            throw new Error("error_no_callback_for_the_received_http_status");
        }
    }

    /**
     * Cancel/delete the requested game, if possible.
     * @gameId Id of the game to delete
     * @return Status
     */
    delete(gameId: number): Q.Promise<any> {
        return Q.Promise<any>((resolve, reject) => {
            this.deleteWithCallbacks(gameId, (result) => resolve(result), (exception, reason) => reject(exception));
        });
    }
    
    private deleteWithCallbacks(gameId: number, onSuccess?: (result: any) => void, onFail?: (exception: string, reason: string) => void) {
        var url = this.baseUrl + "/api/games/{gameId}?"; 

        if (gameId === undefined || gameId === null)
            throw new Error("The parameter 'gameId' must be defined.");
        url = url.replace("{gameId}", encodeURIComponent("" + gameId)); 

        var content = "";

        jQuery.ajax({
            url: url,
            beforeSend: this.beforeSend,
            type: "delete",
            data: content,
            dataType: "text",
            headers: {
                "Content-Type": "application/json; charset=UTF-8"
            }
        }).done((data, textStatus, xhr) => {
            this.processDeleteWithCallbacks(url, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processDeleteWithCallbacks(url, xhr, onSuccess, onFail);
        });
    }

    private processDeleteWithCallbacks(url: string, xhr: any, onSuccess?: any, onFail?: any) {
        try {
            var result = this.processDelete(xhr);
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    private processDelete(xhr: any) {
        var data = xhr.responseText; 
        var status = xhr.status.toString(); 

        if (status === "200") {
            var result200: any = null; 
            if (data !== undefined && data !== null && data !== "") {
                result200 = data;
            }
            return result200;
        }
        else
        {
            throw new Error("error_no_callback_for_the_received_http_status");
        }
    }

    /**
     * Get messages for a single game
     * @gameId Id of the requested game
     * @isPublic (optional) Value indicating whether to return only public messages, default is true
     * @return Messages posted in the requested game
     */
    getMessages(gameId: number, isPublic: boolean): Q.Promise<Game> {
        return Q.Promise<Game>((resolve, reject) => {
            this.getMessagesWithCallbacks(gameId, isPublic, (result) => resolve(result), (exception, reason) => reject(exception));
        });
    }
    
    private getMessagesWithCallbacks(gameId: number, isPublic: boolean, onSuccess?: (result: Game) => void, onFail?: (exception: string, reason: string) => void) {
        var url = this.baseUrl + "/api/games/{gameId}/messages?"; 

        if (gameId === undefined || gameId === null)
            throw new Error("The parameter 'gameId' must be defined.");
        url = url.replace("{gameId}", encodeURIComponent("" + gameId)); 

        if (isPublic === null)
            throw new Error("The parameter 'isPublic' cannot be null.");
        else if (isPublic !== undefined)
            url += "isPublic=" + encodeURIComponent("" + isPublic) + "&"; 

        var content = "";

        jQuery.ajax({
            url: url,
            beforeSend: this.beforeSend,
            type: "get",
            data: content,
            dataType: "text",
            headers: {
                "Content-Type": "application/json; charset=UTF-8"
            }
        }).done((data, textStatus, xhr) => {
            this.processGetMessagesWithCallbacks(url, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processGetMessagesWithCallbacks(url, xhr, onSuccess, onFail);
        });
    }

    private processGetMessagesWithCallbacks(url: string, xhr: any, onSuccess?: any, onFail?: any) {
        try {
            var result = this.processGetMessages(xhr);
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    private processGetMessages(xhr: any) {
        var data = xhr.responseText; 
        var status = xhr.status.toString(); 

        if (status === "200") {
            var result200: Game = null; 
            if (data !== undefined && data !== null && data !== "") {
                var resultData200 = data === "" ? null : jQuery.parseJSON(data);
                result200 = resultData200 ? Game.fromJS(resultData200) : null;
            }
            return result200;
        }
        else
        {
            throw new Error("error_no_callback_for_the_received_http_status");
        }
    }

    /**
     * Join the given game
     * @gameId Id of game to join
     */
    postJoin(gameId: number): Q.Promise<any> {
        return Q.Promise<any>((resolve, reject) => {
            this.postJoinWithCallbacks(gameId, (result) => resolve(result), (exception, reason) => reject(exception));
        });
    }
    
    private postJoinWithCallbacks(gameId: number, onSuccess?: (result: any) => void, onFail?: (exception: string, reason: string) => void) {
        var url = this.baseUrl + "/api/games/{gameId}/join?"; 

        if (gameId === undefined || gameId === null)
            throw new Error("The parameter 'gameId' must be defined.");
        url = url.replace("{gameId}", encodeURIComponent("" + gameId)); 

        var content = "";

        jQuery.ajax({
            url: url,
            beforeSend: this.beforeSend,
            type: "post",
            data: content,
            dataType: "text",
            headers: {
                "Content-Type": "application/json; charset=UTF-8"
            }
        }).done((data, textStatus, xhr) => {
            this.processPostJoinWithCallbacks(url, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processPostJoinWithCallbacks(url, xhr, onSuccess, onFail);
        });
    }

    private processPostJoinWithCallbacks(url: string, xhr: any, onSuccess?: any, onFail?: any) {
        try {
            var result = this.processPostJoin(xhr);
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    private processPostJoin(xhr: any) {
        var data = xhr.responseText; 
        var status = xhr.status.toString(); 

        if (status === "200") {
            var result200: any = null; 
            if (data !== undefined && data !== null && data !== "") {
                result200 = data;
            }
            return result200;
        }
        else
        {
            throw new Error("error_no_callback_for_the_received_http_status");
        }
    }

    /**
     * Leave the given game, only possible if game hasn't started yet, and current player
is not the creator.
     * @gameId Id of game to leave
     */
    postLeave(gameId: number): Q.Promise<any> {
        return Q.Promise<any>((resolve, reject) => {
            this.postLeaveWithCallbacks(gameId, (result) => resolve(result), (exception, reason) => reject(exception));
        });
    }
    
    private postLeaveWithCallbacks(gameId: number, onSuccess?: (result: any) => void, onFail?: (exception: string, reason: string) => void) {
        var url = this.baseUrl + "/api/games/{gameId}/leave?"; 

        if (gameId === undefined || gameId === null)
            throw new Error("The parameter 'gameId' must be defined.");
        url = url.replace("{gameId}", encodeURIComponent("" + gameId)); 

        var content = "";

        jQuery.ajax({
            url: url,
            beforeSend: this.beforeSend,
            type: "post",
            data: content,
            dataType: "text",
            headers: {
                "Content-Type": "application/json; charset=UTF-8"
            }
        }).done((data, textStatus, xhr) => {
            this.processPostLeaveWithCallbacks(url, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processPostLeaveWithCallbacks(url, xhr, onSuccess, onFail);
        });
    }

    private processPostLeaveWithCallbacks(url: string, xhr: any, onSuccess?: any, onFail?: any) {
        try {
            var result = this.processPostLeave(xhr);
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    private processPostLeave(xhr: any) {
        var data = xhr.responseText; 
        var status = xhr.status.toString(); 

        if (status === "200") {
            var result200: any = null; 
            if (data !== undefined && data !== null && data !== "") {
                result200 = data;
            }
            return result200;
        }
        else
        {
            throw new Error("error_no_callback_for_the_received_http_status");
        }
    }

    /**
     * Surrender in the given game, only possible if current player
and game are still active.
     * @gameId Id of game to surrender in
     */
    postSurrender(gameId: number): Q.Promise<GameSummary> {
        return Q.Promise<GameSummary>((resolve, reject) => {
            this.postSurrenderWithCallbacks(gameId, (result) => resolve(result), (exception, reason) => reject(exception));
        });
    }
    
    private postSurrenderWithCallbacks(gameId: number, onSuccess?: (result: GameSummary) => void, onFail?: (exception: string, reason: string) => void) {
        var url = this.baseUrl + "/api/games/{gameId}/surrender?"; 

        if (gameId === undefined || gameId === null)
            throw new Error("The parameter 'gameId' must be defined.");
        url = url.replace("{gameId}", encodeURIComponent("" + gameId)); 

        var content = "";

        jQuery.ajax({
            url: url,
            beforeSend: this.beforeSend,
            type: "post",
            data: content,
            dataType: "text",
            headers: {
                "Content-Type": "application/json; charset=UTF-8"
            }
        }).done((data, textStatus, xhr) => {
            this.processPostSurrenderWithCallbacks(url, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processPostSurrenderWithCallbacks(url, xhr, onSuccess, onFail);
        });
    }

    private processPostSurrenderWithCallbacks(url: string, xhr: any, onSuccess?: any, onFail?: any) {
        try {
            var result = this.processPostSurrender(xhr);
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    private processPostSurrender(xhr: any) {
        var data = xhr.responseText; 
        var status = xhr.status.toString(); 

        if (status === "200") {
            var result200: GameSummary = null; 
            if (data !== undefined && data !== null && data !== "") {
                var resultData200 = data === "" ? null : jQuery.parseJSON(data);
                result200 = resultData200 ? GameSummary.fromJS(resultData200) : null;
            }
            return result200;
        }
        else
        {
            throw new Error("error_no_callback_for_the_received_http_status");
        }
    }

    /**
     * Hides the given game for the current player
     * @gameId Id of game to hide
     */
    patchHide(gameId: number): Q.Promise<any> {
        return Q.Promise<any>((resolve, reject) => {
            this.patchHideWithCallbacks(gameId, (result) => resolve(result), (exception, reason) => reject(exception));
        });
    }
    
    private patchHideWithCallbacks(gameId: number, onSuccess?: (result: any) => void, onFail?: (exception: string, reason: string) => void) {
        var url = this.baseUrl + "/api/games/{gameId}/hide?"; 

        if (gameId === undefined || gameId === null)
            throw new Error("The parameter 'gameId' must be defined.");
        url = url.replace("{gameId}", encodeURIComponent("" + gameId)); 

        var content = "";

        jQuery.ajax({
            url: url,
            beforeSend: this.beforeSend,
            type: "post",
            data: content,
            dataType: "text",
            headers: {
                "Content-Type": "application/json; charset=UTF-8"
            }
        }).done((data, textStatus, xhr) => {
            this.processPatchHideWithCallbacks(url, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processPatchHideWithCallbacks(url, xhr, onSuccess, onFail);
        });
    }

    private processPatchHideWithCallbacks(url: string, xhr: any, onSuccess?: any, onFail?: any) {
        try {
            var result = this.processPatchHide(xhr);
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    private processPatchHide(xhr: any) {
        var data = xhr.responseText; 
        var status = xhr.status.toString(); 

        if (status === "200") {
            var result200: any = null; 
            if (data !== undefined && data !== null && data !== "") {
                result200 = data;
            }
            return result200;
        }
        else
        {
            throw new Error("error_no_callback_for_the_received_http_status");
        }
    }

    /**
     * Hide all games which can be hidden for the current player
     */
    patchHideAll(): Q.Promise<any> {
        return Q.Promise<any>((resolve, reject) => {
            this.patchHideAllWithCallbacks((result) => resolve(result), (exception, reason) => reject(exception));
        });
    }
    
    private patchHideAllWithCallbacks(onSuccess?: (result: any) => void, onFail?: (exception: string, reason: string) => void) {
        var url = this.baseUrl + "/api/games/hide?"; 

        var content = "";

        jQuery.ajax({
            url: url,
            beforeSend: this.beforeSend,
            type: "post",
            data: content,
            dataType: "text",
            headers: {
                "Content-Type": "application/json; charset=UTF-8"
            }
        }).done((data, textStatus, xhr) => {
            this.processPatchHideAllWithCallbacks(url, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processPatchHideAllWithCallbacks(url, xhr, onSuccess, onFail);
        });
    }

    private processPatchHideAllWithCallbacks(url: string, xhr: any, onSuccess?: any, onFail?: any) {
        try {
            var result = this.processPatchHideAll(xhr);
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    private processPatchHideAll(xhr: any) {
        var data = xhr.responseText; 
        var status = xhr.status.toString(); 

        if (status === "200") {
            var result200: any = null; 
            if (data !== undefined && data !== null && data !== "") {
                result200 = data;
            }
            return result200;
        }
        else
        {
            throw new Error("error_no_callback_for_the_received_http_status");
        }
    }
}

export class MessageClient {
    baseUrl: string = undefined; 
    beforeSend: any = undefined; 

    constructor(baseUrl?: string) {
        this.baseUrl = baseUrl !== undefined ? baseUrl : ""; 
    }

    getAll(folder: MessageFolderAsInteger): Q.Promise<Message[]> {
        return Q.Promise<Message[]>((resolve, reject) => {
            this.getAllWithCallbacks(folder, (result) => resolve(result), (exception, reason) => reject(exception));
        });
    }
    
    private getAllWithCallbacks(folder: MessageFolderAsInteger, onSuccess?: (result: Message[]) => void, onFail?: (exception: string, reason: string) => void) {
        var url = this.baseUrl + "/api/messages/folder/{folder}?"; 

        if (folder === undefined || folder === null)
            throw new Error("The parameter 'folder' must be defined.");
        url = url.replace("{folder}", encodeURIComponent("" + folder)); 

        var content = "";

        jQuery.ajax({
            url: url,
            beforeSend: this.beforeSend,
            type: "get",
            data: content,
            dataType: "text",
            headers: {
                "Content-Type": "application/json; charset=UTF-8"
            }
        }).done((data, textStatus, xhr) => {
            this.processGetAllWithCallbacks(url, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processGetAllWithCallbacks(url, xhr, onSuccess, onFail);
        });
    }

    private processGetAllWithCallbacks(url: string, xhr: any, onSuccess?: any, onFail?: any) {
        try {
            var result = this.processGetAll(xhr);
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    private processGetAll(xhr: any) {
        var data = xhr.responseText; 
        var status = xhr.status.toString(); 

        if (status === "200") {
            var result200: Message[] = null; 
            if (data !== undefined && data !== null && data !== "") {
                var resultData200 = data === "" ? null : jQuery.parseJSON(data);
                if (resultData200 && resultData200.constructor === Array) {
                    result200 = [];
                    for (let item of resultData200)
                        result200.push(Message.fromJS(item));
                }
            }
            return result200;
        }
        else
        {
            throw new Error("error_no_callback_for_the_received_http_status");
        }
    }

    get(messageId: string): Q.Promise<Message> {
        return Q.Promise<Message>((resolve, reject) => {
            this.getWithCallbacks(messageId, (result) => resolve(result), (exception, reason) => reject(exception));
        });
    }
    
    private getWithCallbacks(messageId: string, onSuccess?: (result: Message) => void, onFail?: (exception: string, reason: string) => void) {
        var url = this.baseUrl + "/api/messages/{messageId}?"; 

        if (messageId === undefined || messageId === null)
            throw new Error("The parameter 'messageId' must be defined.");
        url = url.replace("{messageId}", encodeURIComponent("" + messageId)); 

        var content = "";

        jQuery.ajax({
            url: url,
            beforeSend: this.beforeSend,
            type: "get",
            data: content,
            dataType: "text",
            headers: {
                "Content-Type": "application/json; charset=UTF-8"
            }
        }).done((data, textStatus, xhr) => {
            this.processGetWithCallbacks(url, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processGetWithCallbacks(url, xhr, onSuccess, onFail);
        });
    }

    private processGetWithCallbacks(url: string, xhr: any, onSuccess?: any, onFail?: any) {
        try {
            var result = this.processGet(xhr);
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    private processGet(xhr: any) {
        var data = xhr.responseText; 
        var status = xhr.status.toString(); 

        if (status === "200") {
            var result200: Message = null; 
            if (data !== undefined && data !== null && data !== "") {
                var resultData200 = data === "" ? null : jQuery.parseJSON(data);
                result200 = resultData200 ? Message.fromJS(resultData200) : null;
            }
            return result200;
        }
        else
        {
            throw new Error("error_no_callback_for_the_received_http_status");
        }
    }

    patchMarkRead(messageId: string): Q.Promise<any> {
        return Q.Promise<any>((resolve, reject) => {
            this.patchMarkReadWithCallbacks(messageId, (result) => resolve(result), (exception, reason) => reject(exception));
        });
    }
    
    private patchMarkReadWithCallbacks(messageId: string, onSuccess?: (result: any) => void, onFail?: (exception: string, reason: string) => void) {
        var url = this.baseUrl + "/api/messages/{messageId}?"; 

        if (messageId === undefined || messageId === null)
            throw new Error("The parameter 'messageId' must be defined.");
        url = url.replace("{messageId}", encodeURIComponent("" + messageId)); 

        var content = "";

        jQuery.ajax({
            url: url,
            beforeSend: this.beforeSend,
            type: "post",
            data: content,
            dataType: "text",
            headers: {
                "Content-Type": "application/json; charset=UTF-8"
            }
        }).done((data, textStatus, xhr) => {
            this.processPatchMarkReadWithCallbacks(url, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processPatchMarkReadWithCallbacks(url, xhr, onSuccess, onFail);
        });
    }

    private processPatchMarkReadWithCallbacks(url: string, xhr: any, onSuccess?: any, onFail?: any) {
        try {
            var result = this.processPatchMarkRead(xhr);
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    private processPatchMarkRead(xhr: any) {
        var data = xhr.responseText; 
        var status = xhr.status.toString(); 

        if (status === "200") {
            var result200: any = null; 
            if (data !== undefined && data !== null && data !== "") {
                result200 = data;
            }
            return result200;
        }
        else
        {
            throw new Error("error_no_callback_for_the_received_http_status");
        }
    }

    delete(messageId: string): Q.Promise<any> {
        return Q.Promise<any>((resolve, reject) => {
            this.deleteWithCallbacks(messageId, (result) => resolve(result), (exception, reason) => reject(exception));
        });
    }
    
    private deleteWithCallbacks(messageId: string, onSuccess?: (result: any) => void, onFail?: (exception: string, reason: string) => void) {
        var url = this.baseUrl + "/api/messages/{messageId}?"; 

        if (messageId === undefined || messageId === null)
            throw new Error("The parameter 'messageId' must be defined.");
        url = url.replace("{messageId}", encodeURIComponent("" + messageId)); 

        var content = "";

        jQuery.ajax({
            url: url,
            beforeSend: this.beforeSend,
            type: "delete",
            data: content,
            dataType: "text",
            headers: {
                "Content-Type": "application/json; charset=UTF-8"
            }
        }).done((data, textStatus, xhr) => {
            this.processDeleteWithCallbacks(url, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processDeleteWithCallbacks(url, xhr, onSuccess, onFail);
        });
    }

    private processDeleteWithCallbacks(url: string, xhr: any, onSuccess?: any, onFail?: any) {
        try {
            var result = this.processDelete(xhr);
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    private processDelete(xhr: any) {
        var data = xhr.responseText; 
        var status = xhr.status.toString(); 

        if (status === "200") {
            var result200: any = null; 
            if (data !== undefined && data !== null && data !== "") {
                result200 = data;
            }
            return result200;
        }
        else
        {
            throw new Error("error_no_callback_for_the_received_http_status");
        }
    }

    getFolderInformation(): Q.Promise<FolderInformation> {
        return Q.Promise<FolderInformation>((resolve, reject) => {
            this.getFolderInformationWithCallbacks((result) => resolve(result), (exception, reason) => reject(exception));
        });
    }
    
    private getFolderInformationWithCallbacks(onSuccess?: (result: FolderInformation) => void, onFail?: (exception: string, reason: string) => void) {
        var url = this.baseUrl + "/api/messages/folders?"; 

        var content = "";

        jQuery.ajax({
            url: url,
            beforeSend: this.beforeSend,
            type: "get",
            data: content,
            dataType: "text",
            headers: {
                "Content-Type": "application/json; charset=UTF-8"
            }
        }).done((data, textStatus, xhr) => {
            this.processGetFolderInformationWithCallbacks(url, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processGetFolderInformationWithCallbacks(url, xhr, onSuccess, onFail);
        });
    }

    private processGetFolderInformationWithCallbacks(url: string, xhr: any, onSuccess?: any, onFail?: any) {
        try {
            var result = this.processGetFolderInformation(xhr);
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    private processGetFolderInformation(xhr: any) {
        var data = xhr.responseText; 
        var status = xhr.status.toString(); 

        if (status === "200") {
            var result200: FolderInformation = null; 
            if (data !== undefined && data !== null && data !== "") {
                var resultData200 = data === "" ? null : jQuery.parseJSON(data);
                result200 = resultData200 ? FolderInformation.fromJS(resultData200) : null;
            }
            return result200;
        }
        else
        {
            throw new Error("error_no_callback_for_the_received_http_status");
        }
    }

    postSend(message: SendMessage): Q.Promise<any> {
        return Q.Promise<any>((resolve, reject) => {
            this.postSendWithCallbacks(message, (result) => resolve(result), (exception, reason) => reject(exception));
        });
    }
    
    private postSendWithCallbacks(message: SendMessage, onSuccess?: (result: any) => void, onFail?: (exception: string, reason: string) => void) {
        var url = this.baseUrl + "/api/messages?"; 

        var content = JSON.stringify(message ? message.toJS() : null);

        jQuery.ajax({
            url: url,
            beforeSend: this.beforeSend,
            type: "post",
            data: content,
            dataType: "text",
            headers: {
                "Content-Type": "application/json; charset=UTF-8"
            }
        }).done((data, textStatus, xhr) => {
            this.processPostSendWithCallbacks(url, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processPostSendWithCallbacks(url, xhr, onSuccess, onFail);
        });
    }

    private processPostSendWithCallbacks(url: string, xhr: any, onSuccess?: any, onFail?: any) {
        try {
            var result = this.processPostSend(xhr);
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    private processPostSend(xhr: any) {
        var data = xhr.responseText; 
        var status = xhr.status.toString(); 

        if (status === "200") {
            var result200: any = null; 
            if (data !== undefined && data !== null && data !== "") {
                result200 = data;
            }
            return result200;
        }
        else
        {
            throw new Error("error_no_callback_for_the_received_http_status");
        }
    }
}

export class NewsClient {
    baseUrl: string = undefined; 
    beforeSend: any = undefined; 

    constructor(baseUrl?: string) {
        this.baseUrl = baseUrl !== undefined ? baseUrl : ""; 
    }

    /**
     * Returns the last 10 news items for all languages
     * @return List of news items
     */
    getAll(): Q.Promise<NewsItem[]> {
        return Q.Promise<NewsItem[]>((resolve, reject) => {
            this.getAllWithCallbacks((result) => resolve(result), (exception, reason) => reject(exception));
        });
    }
    
    private getAllWithCallbacks(onSuccess?: (result: NewsItem[]) => void, onFail?: (exception: string, reason: string) => void) {
        var url = this.baseUrl + "/api/news?"; 

        var content = "";

        jQuery.ajax({
            url: url,
            beforeSend: this.beforeSend,
            type: "get",
            data: content,
            dataType: "text",
            headers: {
                "Content-Type": "application/json; charset=UTF-8"
            }
        }).done((data, textStatus, xhr) => {
            this.processGetAllWithCallbacks(url, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processGetAllWithCallbacks(url, xhr, onSuccess, onFail);
        });
    }

    private processGetAllWithCallbacks(url: string, xhr: any, onSuccess?: any, onFail?: any) {
        try {
            var result = this.processGetAll(xhr);
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    private processGetAll(xhr: any) {
        var data = xhr.responseText; 
        var status = xhr.status.toString(); 

        if (status === "200") {
            var result200: NewsItem[] = null; 
            if (data !== undefined && data !== null && data !== "") {
                var resultData200 = data === "" ? null : jQuery.parseJSON(data);
                if (resultData200 && resultData200.constructor === Array) {
                    result200 = [];
                    for (let item of resultData200)
                        result200.push(NewsItem.fromJS(item));
                }
            }
            return result200;
        }
        else
        {
            throw new Error("error_no_callback_for_the_received_http_status");
        }
    }
}

export class NotificationClient {
    baseUrl: string = undefined; 
    beforeSend: any = undefined; 

    constructor(baseUrl?: string) {
        this.baseUrl = baseUrl !== undefined ? baseUrl : ""; 
    }

    /**
     * Get notification summary for current user
     */
    getSummary(): Q.Promise<any> {
        return Q.Promise<any>((resolve, reject) => {
            this.getSummaryWithCallbacks((result) => resolve(result), (exception, reason) => reject(exception));
        });
    }
    
    private getSummaryWithCallbacks(onSuccess?: (result: any) => void, onFail?: (exception: string, reason: string) => void) {
        var url = this.baseUrl + "/api/notifications/summary?"; 

        var content = "";

        jQuery.ajax({
            url: url,
            beforeSend: this.beforeSend,
            type: "get",
            data: content,
            dataType: "text",
            headers: {
                "Content-Type": "application/json; charset=UTF-8"
            }
        }).done((data, textStatus, xhr) => {
            this.processGetSummaryWithCallbacks(url, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processGetSummaryWithCallbacks(url, xhr, onSuccess, onFail);
        });
    }

    private processGetSummaryWithCallbacks(url: string, xhr: any, onSuccess?: any, onFail?: any) {
        try {
            var result = this.processGetSummary(xhr);
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    private processGetSummary(xhr: any) {
        var data = xhr.responseText; 
        var status = xhr.status.toString(); 

        if (status === "200") {
            var result200: any = null; 
            if (data !== undefined && data !== null && data !== "") {
                result200 = data;
            }
            return result200;
        }
        else
        {
            throw new Error("error_no_callback_for_the_received_http_status");
        }
    }
}

export class PlayClient {
    baseUrl: string = undefined; 
    beforeSend: any = undefined; 

    constructor(baseUrl?: string) {
        this.baseUrl = baseUrl !== undefined ? baseUrl : ""; 
    }

    /**
     * Place units to countries.
     * @gameId Id of the game
     * @placeUnitsOptions (optional) List of country/unit count pairs
     * @return GameActionResult of action
     */
    postPlace(gameId: number, placeUnitsOptions: PlaceUnitsOptions[]): Q.Promise<GameActionResult> {
        return Q.Promise<GameActionResult>((resolve, reject) => {
            this.postPlaceWithCallbacks(gameId, placeUnitsOptions, (result) => resolve(result), (exception, reason) => reject(exception));
        });
    }
    
    private postPlaceWithCallbacks(gameId: number, placeUnitsOptions: PlaceUnitsOptions[], onSuccess?: (result: GameActionResult) => void, onFail?: (exception: string, reason: string) => void) {
        var url = this.baseUrl + "/api/games/{gameId}/play/place?"; 

        if (gameId === undefined || gameId === null)
            throw new Error("The parameter 'gameId' must be defined.");
        url = url.replace("{gameId}", encodeURIComponent("" + gameId)); 

        var contentData = [];
        if (placeUnitsOptions) {
            for (let item of placeUnitsOptions)
                contentData.push(item.toJS());
        }
        var content = JSON.stringify(placeUnitsOptions ? contentData : null);

        jQuery.ajax({
            url: url,
            beforeSend: this.beforeSend,
            type: "post",
            data: content,
            dataType: "text",
            headers: {
                "Content-Type": "application/json; charset=UTF-8"
            }
        }).done((data, textStatus, xhr) => {
            this.processPostPlaceWithCallbacks(url, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processPostPlaceWithCallbacks(url, xhr, onSuccess, onFail);
        });
    }

    private processPostPlaceWithCallbacks(url: string, xhr: any, onSuccess?: any, onFail?: any) {
        try {
            var result = this.processPostPlace(xhr);
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    private processPostPlace(xhr: any) {
        var data = xhr.responseText; 
        var status = xhr.status.toString(); 

        if (status === "200") {
            var result200: GameActionResult = null; 
            if (data !== undefined && data !== null && data !== "") {
                var resultData200 = data === "" ? null : jQuery.parseJSON(data);
                result200 = resultData200 ? GameActionResult.fromJS(resultData200) : null;
            }
            return result200;
        }
        else
        {
            throw new Error("error_no_callback_for_the_received_http_status");
        }
    }

    /**
     * Exchange cards for the current player. Which cards to exchange is automatically chosen to gain the most bonus for the player.
     * @gameId Id of the game
     * @return GameActionResult of action
     */
    postExchange(gameId: number): Q.Promise<GameActionResult> {
        return Q.Promise<GameActionResult>((resolve, reject) => {
            this.postExchangeWithCallbacks(gameId, (result) => resolve(result), (exception, reason) => reject(exception));
        });
    }
    
    private postExchangeWithCallbacks(gameId: number, onSuccess?: (result: GameActionResult) => void, onFail?: (exception: string, reason: string) => void) {
        var url = this.baseUrl + "/api/games/{gameId}/play/exchange?"; 

        if (gameId === undefined || gameId === null)
            throw new Error("The parameter 'gameId' must be defined.");
        url = url.replace("{gameId}", encodeURIComponent("" + gameId)); 

        var content = "";

        jQuery.ajax({
            url: url,
            beforeSend: this.beforeSend,
            type: "post",
            data: content,
            dataType: "text",
            headers: {
                "Content-Type": "application/json; charset=UTF-8"
            }
        }).done((data, textStatus, xhr) => {
            this.processPostExchangeWithCallbacks(url, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processPostExchangeWithCallbacks(url, xhr, onSuccess, onFail);
        });
    }

    private processPostExchangeWithCallbacks(url: string, xhr: any, onSuccess?: any, onFail?: any) {
        try {
            var result = this.processPostExchange(xhr);
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    private processPostExchange(xhr: any) {
        var data = xhr.responseText; 
        var status = xhr.status.toString(); 

        if (status === "200") {
            var result200: GameActionResult = null; 
            if (data !== undefined && data !== null && data !== "") {
                var resultData200 = data === "" ? null : jQuery.parseJSON(data);
                result200 = resultData200 ? GameActionResult.fromJS(resultData200) : null;
            }
            return result200;
        }
        else
        {
            throw new Error("error_no_callback_for_the_received_http_status");
        }
    }

    /**
     * Attack from one to another country.
     * @gameId Id of the game
     * @options (optional) Options for the command
     * @return GameActionResult of action
     */
    postAttack(gameId: number, options: AttackOptions): Q.Promise<GameActionResult> {
        return Q.Promise<GameActionResult>((resolve, reject) => {
            this.postAttackWithCallbacks(gameId, options, (result) => resolve(result), (exception, reason) => reject(exception));
        });
    }
    
    private postAttackWithCallbacks(gameId: number, options: AttackOptions, onSuccess?: (result: GameActionResult) => void, onFail?: (exception: string, reason: string) => void) {
        var url = this.baseUrl + "/api/games/{gameId}/play/attack?"; 

        if (gameId === undefined || gameId === null)
            throw new Error("The parameter 'gameId' must be defined.");
        url = url.replace("{gameId}", encodeURIComponent("" + gameId)); 

        var content = JSON.stringify(options ? options.toJS() : null);

        jQuery.ajax({
            url: url,
            beforeSend: this.beforeSend,
            type: "post",
            data: content,
            dataType: "text",
            headers: {
                "Content-Type": "application/json; charset=UTF-8"
            }
        }).done((data, textStatus, xhr) => {
            this.processPostAttackWithCallbacks(url, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processPostAttackWithCallbacks(url, xhr, onSuccess, onFail);
        });
    }

    private processPostAttackWithCallbacks(url: string, xhr: any, onSuccess?: any, onFail?: any) {
        try {
            var result = this.processPostAttack(xhr);
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    private processPostAttack(xhr: any) {
        var data = xhr.responseText; 
        var status = xhr.status.toString(); 

        if (status === "200") {
            var result200: GameActionResult = null; 
            if (data !== undefined && data !== null && data !== "") {
                var resultData200 = data === "" ? null : jQuery.parseJSON(data);
                result200 = resultData200 ? GameActionResult.fromJS(resultData200) : null;
            }
            return result200;
        }
        else
        {
            throw new Error("error_no_callback_for_the_received_http_status");
        }
    }

    /**
     * Switch to moving.
     * @gameId Id of the game
     * @return GameActionResult of action
     */
    postEndAttack(gameId: number): Q.Promise<GameActionResult> {
        return Q.Promise<GameActionResult>((resolve, reject) => {
            this.postEndAttackWithCallbacks(gameId, (result) => resolve(result), (exception, reason) => reject(exception));
        });
    }
    
    private postEndAttackWithCallbacks(gameId: number, onSuccess?: (result: GameActionResult) => void, onFail?: (exception: string, reason: string) => void) {
        var url = this.baseUrl + "/api/games/{gameId}/play/endattack?"; 

        if (gameId === undefined || gameId === null)
            throw new Error("The parameter 'gameId' must be defined.");
        url = url.replace("{gameId}", encodeURIComponent("" + gameId)); 

        var content = "";

        jQuery.ajax({
            url: url,
            beforeSend: this.beforeSend,
            type: "post",
            data: content,
            dataType: "text",
            headers: {
                "Content-Type": "application/json; charset=UTF-8"
            }
        }).done((data, textStatus, xhr) => {
            this.processPostEndAttackWithCallbacks(url, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processPostEndAttackWithCallbacks(url, xhr, onSuccess, onFail);
        });
    }

    private processPostEndAttackWithCallbacks(url: string, xhr: any, onSuccess?: any, onFail?: any) {
        try {
            var result = this.processPostEndAttack(xhr);
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    private processPostEndAttack(xhr: any) {
        var data = xhr.responseText; 
        var status = xhr.status.toString(); 

        if (status === "200") {
            var result200: GameActionResult = null; 
            if (data !== undefined && data !== null && data !== "") {
                var resultData200 = data === "" ? null : jQuery.parseJSON(data);
                result200 = resultData200 ? GameActionResult.fromJS(resultData200) : null;
            }
            return result200;
        }
        else
        {
            throw new Error("error_no_callback_for_the_received_http_status");
        }
    }

    /**
     * Move units between countries. Only allowed after placing. Cancels any attacks that the player had left before. Attacking is not
possible anymore after moving.
     * @gameId Id of the game
     * @options (optional) Options for the command
     * @return GameActionResult of action
     */
    postMove(gameId: number, options: MoveOptions): Q.Promise<GameActionResult> {
        return Q.Promise<GameActionResult>((resolve, reject) => {
            this.postMoveWithCallbacks(gameId, options, (result) => resolve(result), (exception, reason) => reject(exception));
        });
    }
    
    private postMoveWithCallbacks(gameId: number, options: MoveOptions, onSuccess?: (result: GameActionResult) => void, onFail?: (exception: string, reason: string) => void) {
        var url = this.baseUrl + "/api/games/{gameId}/play/move?"; 

        if (gameId === undefined || gameId === null)
            throw new Error("The parameter 'gameId' must be defined.");
        url = url.replace("{gameId}", encodeURIComponent("" + gameId)); 

        var content = JSON.stringify(options ? options.toJS() : null);

        jQuery.ajax({
            url: url,
            beforeSend: this.beforeSend,
            type: "post",
            data: content,
            dataType: "text",
            headers: {
                "Content-Type": "application/json; charset=UTF-8"
            }
        }).done((data, textStatus, xhr) => {
            this.processPostMoveWithCallbacks(url, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processPostMoveWithCallbacks(url, xhr, onSuccess, onFail);
        });
    }

    private processPostMoveWithCallbacks(url: string, xhr: any, onSuccess?: any, onFail?: any) {
        try {
            var result = this.processPostMove(xhr);
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    private processPostMove(xhr: any) {
        var data = xhr.responseText; 
        var status = xhr.status.toString(); 

        if (status === "200") {
            var result200: GameActionResult = null; 
            if (data !== undefined && data !== null && data !== "") {
                var resultData200 = data === "" ? null : jQuery.parseJSON(data);
                result200 = resultData200 ? GameActionResult.fromJS(resultData200) : null;
            }
            return result200;
        }
        else
        {
            throw new Error("error_no_callback_for_the_received_http_status");
        }
    }

    /**
     * End the current turn
     * @gameId Id of the game
     * @return GameActionResult of action
     */
    postEndTurn(gameId: number): Q.Promise<Game> {
        return Q.Promise<Game>((resolve, reject) => {
            this.postEndTurnWithCallbacks(gameId, (result) => resolve(result), (exception, reason) => reject(exception));
        });
    }
    
    private postEndTurnWithCallbacks(gameId: number, onSuccess?: (result: Game) => void, onFail?: (exception: string, reason: string) => void) {
        var url = this.baseUrl + "/api/games/{gameId}/play/endturn?"; 

        if (gameId === undefined || gameId === null)
            throw new Error("The parameter 'gameId' must be defined.");
        url = url.replace("{gameId}", encodeURIComponent("" + gameId)); 

        var content = "";

        jQuery.ajax({
            url: url,
            beforeSend: this.beforeSend,
            type: "post",
            data: content,
            dataType: "text",
            headers: {
                "Content-Type": "application/json; charset=UTF-8"
            }
        }).done((data, textStatus, xhr) => {
            this.processPostEndTurnWithCallbacks(url, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processPostEndTurnWithCallbacks(url, xhr, onSuccess, onFail);
        });
    }

    private processPostEndTurnWithCallbacks(url: string, xhr: any, onSuccess?: any, onFail?: any) {
        try {
            var result = this.processPostEndTurn(xhr);
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    private processPostEndTurn(xhr: any) {
        var data = xhr.responseText; 
        var status = xhr.status.toString(); 

        if (status === "200") {
            var result200: Game = null; 
            if (data !== undefined && data !== null && data !== "") {
                var resultData200 = data === "" ? null : jQuery.parseJSON(data);
                result200 = resultData200 ? Game.fromJS(resultData200) : null;
            }
            return result200;
        }
        else
        {
            throw new Error("error_no_callback_for_the_received_http_status");
        }
    }
}

export class TournamentClient {
    baseUrl: string = undefined; 
    beforeSend: any = undefined; 

    constructor(baseUrl?: string) {
        this.baseUrl = baseUrl !== undefined ? baseUrl : ""; 
    }

    /**
     * Returns tournaments
     * @return List of tournaments
     */
    getAll(): Q.Promise<Tournament[]> {
        return Q.Promise<Tournament[]>((resolve, reject) => {
            this.getAllWithCallbacks((result) => resolve(result), (exception, reason) => reject(exception));
        });
    }
    
    private getAllWithCallbacks(onSuccess?: (result: Tournament[]) => void, onFail?: (exception: string, reason: string) => void) {
        var url = this.baseUrl + "/api/tournaments?"; 

        var content = "";

        jQuery.ajax({
            url: url,
            beforeSend: this.beforeSend,
            type: "get",
            data: content,
            dataType: "text",
            headers: {
                "Content-Type": "application/json; charset=UTF-8"
            }
        }).done((data, textStatus, xhr) => {
            this.processGetAllWithCallbacks(url, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processGetAllWithCallbacks(url, xhr, onSuccess, onFail);
        });
    }

    private processGetAllWithCallbacks(url: string, xhr: any, onSuccess?: any, onFail?: any) {
        try {
            var result = this.processGetAll(xhr);
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    private processGetAll(xhr: any) {
        var data = xhr.responseText; 
        var status = xhr.status.toString(); 

        if (status === "200") {
            var result200: Tournament[] = null; 
            if (data !== undefined && data !== null && data !== "") {
                var resultData200 = data === "" ? null : jQuery.parseJSON(data);
                if (resultData200 && resultData200.constructor === Array) {
                    result200 = [];
                    for (let item of resultData200)
                        result200.push(Tournament.fromJS(item));
                }
            }
            return result200;
        }
        else
        {
            throw new Error("error_no_callback_for_the_received_http_status");
        }
    }

    /**
     * Get tournament identified by Id
     * @tournamentId Id of tournament
     */
    getById(tournamentId: string): Q.Promise<Tournament> {
        return Q.Promise<Tournament>((resolve, reject) => {
            this.getByIdWithCallbacks(tournamentId, (result) => resolve(result), (exception, reason) => reject(exception));
        });
    }
    
    private getByIdWithCallbacks(tournamentId: string, onSuccess?: (result: Tournament) => void, onFail?: (exception: string, reason: string) => void) {
        var url = this.baseUrl + "/api/tournaments/{tournamentId}?"; 

        if (tournamentId === undefined || tournamentId === null)
            throw new Error("The parameter 'tournamentId' must be defined.");
        url = url.replace("{tournamentId}", encodeURIComponent("" + tournamentId)); 

        var content = "";

        jQuery.ajax({
            url: url,
            beforeSend: this.beforeSend,
            type: "get",
            data: content,
            dataType: "text",
            headers: {
                "Content-Type": "application/json; charset=UTF-8"
            }
        }).done((data, textStatus, xhr) => {
            this.processGetByIdWithCallbacks(url, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processGetByIdWithCallbacks(url, xhr, onSuccess, onFail);
        });
    }

    private processGetByIdWithCallbacks(url: string, xhr: any, onSuccess?: any, onFail?: any) {
        try {
            var result = this.processGetById(xhr);
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    private processGetById(xhr: any) {
        var data = xhr.responseText; 
        var status = xhr.status.toString(); 

        if (status === "200") {
            var result200: Tournament = null; 
            if (data !== undefined && data !== null && data !== "") {
                var resultData200 = data === "" ? null : jQuery.parseJSON(data);
                result200 = resultData200 ? Tournament.fromJS(resultData200) : null;
            }
            return result200;
        }
        else
        {
            throw new Error("error_no_callback_for_the_received_http_status");
        }
    }

    /**
     * Join tournament
     * @tournamentId Id of tournament
     */
    postJoin(tournamentId: string): Q.Promise<TournamentTeam> {
        return Q.Promise<TournamentTeam>((resolve, reject) => {
            this.postJoinWithCallbacks(tournamentId, (result) => resolve(result), (exception, reason) => reject(exception));
        });
    }
    
    private postJoinWithCallbacks(tournamentId: string, onSuccess?: (result: TournamentTeam) => void, onFail?: (exception: string, reason: string) => void) {
        var url = this.baseUrl + "/api/tournaments/{tournamentId}?"; 

        if (tournamentId === undefined || tournamentId === null)
            throw new Error("The parameter 'tournamentId' must be defined.");
        url = url.replace("{tournamentId}", encodeURIComponent("" + tournamentId)); 

        var content = "";

        jQuery.ajax({
            url: url,
            beforeSend: this.beforeSend,
            type: "post",
            data: content,
            dataType: "text",
            headers: {
                "Content-Type": "application/json; charset=UTF-8"
            }
        }).done((data, textStatus, xhr) => {
            this.processPostJoinWithCallbacks(url, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processPostJoinWithCallbacks(url, xhr, onSuccess, onFail);
        });
    }

    private processPostJoinWithCallbacks(url: string, xhr: any, onSuccess?: any, onFail?: any) {
        try {
            var result = this.processPostJoin(xhr);
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    private processPostJoin(xhr: any) {
        var data = xhr.responseText; 
        var status = xhr.status.toString(); 

        if (status === "200") {
            var result200: TournamentTeam = null; 
            if (data !== undefined && data !== null && data !== "") {
                var resultData200 = data === "" ? null : jQuery.parseJSON(data);
                result200 = resultData200 ? TournamentTeam.fromJS(resultData200) : null;
            }
            return result200;
        }
        else
        {
            throw new Error("error_no_callback_for_the_received_http_status");
        }
    }

    /**
     * Get teams for tournament
     * @tournamentId Id of tournament
     */
    getTeams(tournamentId: string): Q.Promise<TournamentTeam[]> {
        return Q.Promise<TournamentTeam[]>((resolve, reject) => {
            this.getTeamsWithCallbacks(tournamentId, (result) => resolve(result), (exception, reason) => reject(exception));
        });
    }
    
    private getTeamsWithCallbacks(tournamentId: string, onSuccess?: (result: TournamentTeam[]) => void, onFail?: (exception: string, reason: string) => void) {
        var url = this.baseUrl + "/api/tournaments/{tournamentId}/teams?"; 

        if (tournamentId === undefined || tournamentId === null)
            throw new Error("The parameter 'tournamentId' must be defined.");
        url = url.replace("{tournamentId}", encodeURIComponent("" + tournamentId)); 

        var content = "";

        jQuery.ajax({
            url: url,
            beforeSend: this.beforeSend,
            type: "get",
            data: content,
            dataType: "text",
            headers: {
                "Content-Type": "application/json; charset=UTF-8"
            }
        }).done((data, textStatus, xhr) => {
            this.processGetTeamsWithCallbacks(url, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processGetTeamsWithCallbacks(url, xhr, onSuccess, onFail);
        });
    }

    private processGetTeamsWithCallbacks(url: string, xhr: any, onSuccess?: any, onFail?: any) {
        try {
            var result = this.processGetTeams(xhr);
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    private processGetTeams(xhr: any) {
        var data = xhr.responseText; 
        var status = xhr.status.toString(); 

        if (status === "200") {
            var result200: TournamentTeam[] = null; 
            if (data !== undefined && data !== null && data !== "") {
                var resultData200 = data === "" ? null : jQuery.parseJSON(data);
                if (resultData200 && resultData200.constructor === Array) {
                    result200 = [];
                    for (let item of resultData200)
                        result200.push(TournamentTeam.fromJS(item));
                }
            }
            return result200;
        }
        else
        {
            throw new Error("error_no_callback_for_the_received_http_status");
        }
    }

    /**
     * Create new team for a tournament
     * @tournamentId Id of tournament
     * @name Name of team
     * @password (optional) Optional password for team
     * @return Summary of newly created team
     */
    postCreateTeam(tournamentId: string, name: string, password: string): Q.Promise<TournamentTeamSummary> {
        return Q.Promise<TournamentTeamSummary>((resolve, reject) => {
            this.postCreateTeamWithCallbacks(tournamentId, name, password, (result) => resolve(result), (exception, reason) => reject(exception));
        });
    }
    
    private postCreateTeamWithCallbacks(tournamentId: string, name: string, password: string, onSuccess?: (result: TournamentTeamSummary) => void, onFail?: (exception: string, reason: string) => void) {
        var url = this.baseUrl + "/api/tournaments/{tournamentId}/teams?"; 

        if (tournamentId === undefined || tournamentId === null)
            throw new Error("The parameter 'tournamentId' must be defined.");
        url = url.replace("{tournamentId}", encodeURIComponent("" + tournamentId)); 

        if (name === undefined)
            throw new Error("The parameter 'name' must be defined.");
        else
            url += "name=" + encodeURIComponent("" + name) + "&"; 
        if (password !== undefined)
            url += "password=" + encodeURIComponent("" + password) + "&"; 

        var content = "";

        jQuery.ajax({
            url: url,
            beforeSend: this.beforeSend,
            type: "post",
            data: content,
            dataType: "text",
            headers: {
                "Content-Type": "application/json; charset=UTF-8"
            }
        }).done((data, textStatus, xhr) => {
            this.processPostCreateTeamWithCallbacks(url, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processPostCreateTeamWithCallbacks(url, xhr, onSuccess, onFail);
        });
    }

    private processPostCreateTeamWithCallbacks(url: string, xhr: any, onSuccess?: any, onFail?: any) {
        try {
            var result = this.processPostCreateTeam(xhr);
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    private processPostCreateTeam(xhr: any) {
        var data = xhr.responseText; 
        var status = xhr.status.toString(); 

        if (status === "200") {
            var result200: TournamentTeamSummary = null; 
            if (data !== undefined && data !== null && data !== "") {
                var resultData200 = data === "" ? null : jQuery.parseJSON(data);
                result200 = resultData200 ? TournamentTeamSummary.fromJS(resultData200) : null;
            }
            return result200;
        }
        else
        {
            throw new Error("error_no_callback_for_the_received_http_status");
        }
    }

    /**
     * Join existing team
     * @tournamentId Id of tournament
     * @teamId Id of team
     * @password (optional) Optional password for team to join
     */
    postJoinTeam(tournamentId: string, teamId: string, password: string): Q.Promise<any> {
        return Q.Promise<any>((resolve, reject) => {
            this.postJoinTeamWithCallbacks(tournamentId, teamId, password, (result) => resolve(result), (exception, reason) => reject(exception));
        });
    }
    
    private postJoinTeamWithCallbacks(tournamentId: string, teamId: string, password: string, onSuccess?: (result: any) => void, onFail?: (exception: string, reason: string) => void) {
        var url = this.baseUrl + "/api/tournaments/{tournamentId}/teams/{teamId}?"; 

        if (tournamentId === undefined || tournamentId === null)
            throw new Error("The parameter 'tournamentId' must be defined.");
        url = url.replace("{tournamentId}", encodeURIComponent("" + tournamentId)); 
        if (teamId === undefined || teamId === null)
            throw new Error("The parameter 'teamId' must be defined.");
        url = url.replace("{teamId}", encodeURIComponent("" + teamId)); 

        if (password !== undefined)
            url += "password=" + encodeURIComponent("" + password) + "&"; 

        var content = "";

        jQuery.ajax({
            url: url,
            beforeSend: this.beforeSend,
            type: "post",
            data: content,
            dataType: "text",
            headers: {
                "Content-Type": "application/json; charset=UTF-8"
            }
        }).done((data, textStatus, xhr) => {
            this.processPostJoinTeamWithCallbacks(url, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processPostJoinTeamWithCallbacks(url, xhr, onSuccess, onFail);
        });
    }

    private processPostJoinTeamWithCallbacks(url: string, xhr: any, onSuccess?: any, onFail?: any) {
        try {
            var result = this.processPostJoinTeam(xhr);
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    private processPostJoinTeam(xhr: any) {
        var data = xhr.responseText; 
        var status = xhr.status.toString(); 

        if (status === "200") {
            var result200: any = null; 
            if (data !== undefined && data !== null && data !== "") {
                result200 = data;
            }
            return result200;
        }
        else
        {
            throw new Error("error_no_callback_for_the_received_http_status");
        }
    }

    /**
     * Delete a team. Only allowed if user created it
     * @tournamentId Id of tournament
     * @teamId Id of team to delete
     */
    deleteTeam(tournamentId: string, teamId: string): Q.Promise<any> {
        return Q.Promise<any>((resolve, reject) => {
            this.deleteTeamWithCallbacks(tournamentId, teamId, (result) => resolve(result), (exception, reason) => reject(exception));
        });
    }
    
    private deleteTeamWithCallbacks(tournamentId: string, teamId: string, onSuccess?: (result: any) => void, onFail?: (exception: string, reason: string) => void) {
        var url = this.baseUrl + "/api/tournaments/{tournamentId}/teams/{teamId}?"; 

        if (tournamentId === undefined || tournamentId === null)
            throw new Error("The parameter 'tournamentId' must be defined.");
        url = url.replace("{tournamentId}", encodeURIComponent("" + tournamentId)); 
        if (teamId === undefined || teamId === null)
            throw new Error("The parameter 'teamId' must be defined.");
        url = url.replace("{teamId}", encodeURIComponent("" + teamId)); 

        var content = "";

        jQuery.ajax({
            url: url,
            beforeSend: this.beforeSend,
            type: "delete",
            data: content,
            dataType: "text",
            headers: {
                "Content-Type": "application/json; charset=UTF-8"
            }
        }).done((data, textStatus, xhr) => {
            this.processDeleteTeamWithCallbacks(url, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processDeleteTeamWithCallbacks(url, xhr, onSuccess, onFail);
        });
    }

    private processDeleteTeamWithCallbacks(url: string, xhr: any, onSuccess?: any, onFail?: any) {
        try {
            var result = this.processDeleteTeam(xhr);
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    private processDeleteTeam(xhr: any) {
        var data = xhr.responseText; 
        var status = xhr.status.toString(); 

        if (status === "200") {
            var result200: any = null; 
            if (data !== undefined && data !== null && data !== "") {
                result200 = data;
            }
            return result200;
        }
        else
        {
            throw new Error("error_no_callback_for_the_received_http_status");
        }
    }

    /**
     * Leave a team and tournament
     * @tournamentId Id of tournament
     */
    leaveTournament(tournamentId: string): Q.Promise<any> {
        return Q.Promise<any>((resolve, reject) => {
            this.leaveTournamentWithCallbacks(tournamentId, (result) => resolve(result), (exception, reason) => reject(exception));
        });
    }
    
    private leaveTournamentWithCallbacks(tournamentId: string, onSuccess?: (result: any) => void, onFail?: (exception: string, reason: string) => void) {
        var url = this.baseUrl + "/api/tournaments/{tournamentId}/teams/me?"; 

        if (tournamentId === undefined || tournamentId === null)
            throw new Error("The parameter 'tournamentId' must be defined.");
        url = url.replace("{tournamentId}", encodeURIComponent("" + tournamentId)); 

        var content = "";

        jQuery.ajax({
            url: url,
            beforeSend: this.beforeSend,
            type: "post",
            data: content,
            dataType: "text",
            headers: {
                "Content-Type": "application/json; charset=UTF-8"
            }
        }).done((data, textStatus, xhr) => {
            this.processLeaveTournamentWithCallbacks(url, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processLeaveTournamentWithCallbacks(url, xhr, onSuccess, onFail);
        });
    }

    private processLeaveTournamentWithCallbacks(url: string, xhr: any, onSuccess?: any, onFail?: any) {
        try {
            var result = this.processLeaveTournament(xhr);
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    private processLeaveTournament(xhr: any) {
        var data = xhr.responseText; 
        var status = xhr.status.toString(); 

        if (status === "200") {
            var result200: any = null; 
            if (data !== undefined && data !== null && data !== "") {
                result200 = data;
            }
            return result200;
        }
        else
        {
            throw new Error("error_no_callback_for_the_received_http_status");
        }
    }
}

export class UserClient {
    baseUrl: string = undefined; 
    beforeSend: any = undefined; 

    constructor(baseUrl?: string) {
        this.baseUrl = baseUrl !== undefined ? baseUrl : ""; 
    }

    /**
     * Find users starting with the given query
     * @query Query to search for
     */
    findUsers(query: string): Q.Promise<UserReference[]> {
        return Q.Promise<UserReference[]>((resolve, reject) => {
            this.findUsersWithCallbacks(query, (result) => resolve(result), (exception, reason) => reject(exception));
        });
    }
    
    private findUsersWithCallbacks(query: string, onSuccess?: (result: UserReference[]) => void, onFail?: (exception: string, reason: string) => void) {
        var url = this.baseUrl + "/api/users/find/{query}?"; 

        if (query === undefined || query === null)
            throw new Error("The parameter 'query' must be defined.");
        url = url.replace("{query}", encodeURIComponent("" + query)); 

        var content = "";

        jQuery.ajax({
            url: url,
            beforeSend: this.beforeSend,
            type: "get",
            data: content,
            dataType: "text",
            headers: {
                "Content-Type": "application/json; charset=UTF-8"
            }
        }).done((data, textStatus, xhr) => {
            this.processFindUsersWithCallbacks(url, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processFindUsersWithCallbacks(url, xhr, onSuccess, onFail);
        });
    }

    private processFindUsersWithCallbacks(url: string, xhr: any, onSuccess?: any, onFail?: any) {
        try {
            var result = this.processFindUsers(xhr);
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    private processFindUsers(xhr: any) {
        var data = xhr.responseText; 
        var status = xhr.status.toString(); 

        if (status === "200") {
            var result200: UserReference[] = null; 
            if (data !== undefined && data !== null && data !== "") {
                var resultData200 = data === "" ? null : jQuery.parseJSON(data);
                if (resultData200 && resultData200.constructor === Array) {
                    result200 = [];
                    for (let item of resultData200)
                        result200.push(UserReference.fromJS(item));
                }
            }
            return result200;
        }
        else
        {
            throw new Error("error_no_callback_for_the_received_http_status");
        }
    }
}

export class UserInfo { 
    userId: string; 
    userName: string; 
    hasRegistered: boolean; 
    loginProvider: string; 
    language: string; 
    roles: string[];

    constructor(data?: any) {
        if (data !== undefined) {
            this.userId = data["UserId"] !== undefined ? data["UserId"] : null;
            this.userName = data["UserName"] !== undefined ? data["UserName"] : null;
            this.hasRegistered = data["HasRegistered"] !== undefined ? data["HasRegistered"] : null;
            this.loginProvider = data["LoginProvider"] !== undefined ? data["LoginProvider"] : null;
            this.language = data["Language"] !== undefined ? data["Language"] : null;
            if (data["Roles"] && data["Roles"].constructor === Array) {
                this.roles = [];
                for (let item of data["Roles"])
                    this.roles.push(item);
            }
        }
    }

    static fromJS(data: any): UserInfo {
        return new UserInfo(data);
    }

    toJS(data?: any) {
        data = data === undefined ? {} : data;
        data["UserId"] = this.userId !== undefined ? this.userId : null;
        data["UserName"] = this.userName !== undefined ? this.userName : null;
        data["HasRegistered"] = this.hasRegistered !== undefined ? this.hasRegistered : null;
        data["LoginProvider"] = this.loginProvider !== undefined ? this.loginProvider : null;
        data["Language"] = this.language !== undefined ? this.language : null;
        if (this.roles && this.roles.constructor === Array) {
            data["Roles"] = [];
            for (let item of this.roles)
                data["Roles"].push(item);
        }
        return data; 
    }

    toJSON() {
        return JSON.stringify(this.toJS());
    }

    clone() {
        var json = this.toJSON();
        return new UserInfo(JSON.parse(json));
    }
}

export class ManageInfoViewModel { 
    localLoginProvider: string; 
    userName: string; 
    logins: UserLoginInfoViewModel[]; 
    externalLoginProviders: ExternalLoginViewModel[];

    constructor(data?: any) {
        if (data !== undefined) {
            this.localLoginProvider = data["LocalLoginProvider"] !== undefined ? data["LocalLoginProvider"] : null;
            this.userName = data["UserName"] !== undefined ? data["UserName"] : null;
            if (data["Logins"] && data["Logins"].constructor === Array) {
                this.logins = [];
                for (let item of data["Logins"])
                    this.logins.push(UserLoginInfoViewModel.fromJS(item));
            }
            if (data["ExternalLoginProviders"] && data["ExternalLoginProviders"].constructor === Array) {
                this.externalLoginProviders = [];
                for (let item of data["ExternalLoginProviders"])
                    this.externalLoginProviders.push(ExternalLoginViewModel.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ManageInfoViewModel {
        return new ManageInfoViewModel(data);
    }

    toJS(data?: any) {
        data = data === undefined ? {} : data;
        data["LocalLoginProvider"] = this.localLoginProvider !== undefined ? this.localLoginProvider : null;
        data["UserName"] = this.userName !== undefined ? this.userName : null;
        if (this.logins && this.logins.constructor === Array) {
            data["Logins"] = [];
            for (let item of this.logins)
                data["Logins"].push(item.toJS());
        }
        if (this.externalLoginProviders && this.externalLoginProviders.constructor === Array) {
            data["ExternalLoginProviders"] = [];
            for (let item of this.externalLoginProviders)
                data["ExternalLoginProviders"].push(item.toJS());
        }
        return data; 
    }

    toJSON() {
        return JSON.stringify(this.toJS());
    }

    clone() {
        var json = this.toJSON();
        return new ManageInfoViewModel(JSON.parse(json));
    }
}

export class UserLoginInfoViewModel { 
    loginProvider: string; 
    providerKey: string;

    constructor(data?: any) {
        if (data !== undefined) {
            this.loginProvider = data["LoginProvider"] !== undefined ? data["LoginProvider"] : null;
            this.providerKey = data["ProviderKey"] !== undefined ? data["ProviderKey"] : null;
        }
    }

    static fromJS(data: any): UserLoginInfoViewModel {
        return new UserLoginInfoViewModel(data);
    }

    toJS(data?: any) {
        data = data === undefined ? {} : data;
        data["LoginProvider"] = this.loginProvider !== undefined ? this.loginProvider : null;
        data["ProviderKey"] = this.providerKey !== undefined ? this.providerKey : null;
        return data; 
    }

    toJSON() {
        return JSON.stringify(this.toJS());
    }

    clone() {
        var json = this.toJSON();
        return new UserLoginInfoViewModel(JSON.parse(json));
    }
}

export class ExternalLoginViewModel { 
    name: string; 
    url: string; 
    state: string;

    constructor(data?: any) {
        if (data !== undefined) {
            this.name = data["Name"] !== undefined ? data["Name"] : null;
            this.url = data["Url"] !== undefined ? data["Url"] : null;
            this.state = data["State"] !== undefined ? data["State"] : null;
        }
    }

    static fromJS(data: any): ExternalLoginViewModel {
        return new ExternalLoginViewModel(data);
    }

    toJS(data?: any) {
        data = data === undefined ? {} : data;
        data["Name"] = this.name !== undefined ? this.name : null;
        data["Url"] = this.url !== undefined ? this.url : null;
        data["State"] = this.state !== undefined ? this.state : null;
        return data; 
    }

    toJSON() {
        return JSON.stringify(this.toJS());
    }

    clone() {
        var json = this.toJSON();
        return new ExternalLoginViewModel(JSON.parse(json));
    }
}

export class ChangePasswordBindingModel { 
    oldPassword: string; 
    newPassword: string; 
    confirmPassword: string;

    constructor(data?: any) {
        if (data !== undefined) {
            this.oldPassword = data["OldPassword"] !== undefined ? data["OldPassword"] : null;
            this.newPassword = data["NewPassword"] !== undefined ? data["NewPassword"] : null;
            this.confirmPassword = data["ConfirmPassword"] !== undefined ? data["ConfirmPassword"] : null;
        }
    }

    static fromJS(data: any): ChangePasswordBindingModel {
        return new ChangePasswordBindingModel(data);
    }

    toJS(data?: any) {
        data = data === undefined ? {} : data;
        data["OldPassword"] = this.oldPassword !== undefined ? this.oldPassword : null;
        data["NewPassword"] = this.newPassword !== undefined ? this.newPassword : null;
        data["ConfirmPassword"] = this.confirmPassword !== undefined ? this.confirmPassword : null;
        return data; 
    }

    toJSON() {
        return JSON.stringify(this.toJS());
    }

    clone() {
        var json = this.toJSON();
        return new ChangePasswordBindingModel(JSON.parse(json));
    }
}

export class SetPasswordBindingModel { 
    newPassword: string; 
    confirmPassword: string;

    constructor(data?: any) {
        if (data !== undefined) {
            this.newPassword = data["NewPassword"] !== undefined ? data["NewPassword"] : null;
            this.confirmPassword = data["ConfirmPassword"] !== undefined ? data["ConfirmPassword"] : null;
        }
    }

    static fromJS(data: any): SetPasswordBindingModel {
        return new SetPasswordBindingModel(data);
    }

    toJS(data?: any) {
        data = data === undefined ? {} : data;
        data["NewPassword"] = this.newPassword !== undefined ? this.newPassword : null;
        data["ConfirmPassword"] = this.confirmPassword !== undefined ? this.confirmPassword : null;
        return data; 
    }

    toJSON() {
        return JSON.stringify(this.toJS());
    }

    clone() {
        var json = this.toJSON();
        return new SetPasswordBindingModel(JSON.parse(json));
    }
}

export class LanguageModel { 
    language: string;

    constructor(data?: any) {
        if (data !== undefined) {
            this.language = data["Language"] !== undefined ? data["Language"] : null;
        }
    }

    static fromJS(data: any): LanguageModel {
        return new LanguageModel(data);
    }

    toJS(data?: any) {
        data = data === undefined ? {} : data;
        data["Language"] = this.language !== undefined ? this.language : null;
        return data; 
    }

    toJSON() {
        return JSON.stringify(this.toJS());
    }

    clone() {
        var json = this.toJSON();
        return new LanguageModel(JSON.parse(json));
    }
}

export class AddExternalLoginBindingModel { 
    externalAccessToken: string;

    constructor(data?: any) {
        if (data !== undefined) {
            this.externalAccessToken = data["ExternalAccessToken"] !== undefined ? data["ExternalAccessToken"] : null;
        }
    }

    static fromJS(data: any): AddExternalLoginBindingModel {
        return new AddExternalLoginBindingModel(data);
    }

    toJS(data?: any) {
        data = data === undefined ? {} : data;
        data["ExternalAccessToken"] = this.externalAccessToken !== undefined ? this.externalAccessToken : null;
        return data; 
    }

    toJSON() {
        return JSON.stringify(this.toJS());
    }

    clone() {
        var json = this.toJSON();
        return new AddExternalLoginBindingModel(JSON.parse(json));
    }
}

export class RemoveLoginBindingModel { 
    loginProvider: string; 
    providerKey: string;

    constructor(data?: any) {
        if (data !== undefined) {
            this.loginProvider = data["LoginProvider"] !== undefined ? data["LoginProvider"] : null;
            this.providerKey = data["ProviderKey"] !== undefined ? data["ProviderKey"] : null;
        }
    }

    static fromJS(data: any): RemoveLoginBindingModel {
        return new RemoveLoginBindingModel(data);
    }

    toJS(data?: any) {
        data = data === undefined ? {} : data;
        data["LoginProvider"] = this.loginProvider !== undefined ? this.loginProvider : null;
        data["ProviderKey"] = this.providerKey !== undefined ? this.providerKey : null;
        return data; 
    }

    toJSON() {
        return JSON.stringify(this.toJS());
    }

    clone() {
        var json = this.toJSON();
        return new RemoveLoginBindingModel(JSON.parse(json));
    }
}

export class RegisterBindingModel { 
    userName: string; 
    password: string; 
    confirmPassword: string; 
    email: string; 
    language: string; 
    callbackUrl: string;

    constructor(data?: any) {
        if (data !== undefined) {
            this.userName = data["UserName"] !== undefined ? data["UserName"] : null;
            this.password = data["Password"] !== undefined ? data["Password"] : null;
            this.confirmPassword = data["ConfirmPassword"] !== undefined ? data["ConfirmPassword"] : null;
            this.email = data["Email"] !== undefined ? data["Email"] : null;
            this.language = data["Language"] !== undefined ? data["Language"] : null;
            this.callbackUrl = data["CallbackUrl"] !== undefined ? data["CallbackUrl"] : null;
        }
    }

    static fromJS(data: any): RegisterBindingModel {
        return new RegisterBindingModel(data);
    }

    toJS(data?: any) {
        data = data === undefined ? {} : data;
        data["UserName"] = this.userName !== undefined ? this.userName : null;
        data["Password"] = this.password !== undefined ? this.password : null;
        data["ConfirmPassword"] = this.confirmPassword !== undefined ? this.confirmPassword : null;
        data["Email"] = this.email !== undefined ? this.email : null;
        data["Language"] = this.language !== undefined ? this.language : null;
        data["CallbackUrl"] = this.callbackUrl !== undefined ? this.callbackUrl : null;
        return data; 
    }

    toJSON() {
        return JSON.stringify(this.toJS());
    }

    clone() {
        var json = this.toJSON();
        return new RegisterBindingModel(JSON.parse(json));
    }
}

export class ResendConfirmationModel { 
    callbackUrl: string; 
    userName: string; 
    password: string; 
    language: string;

    constructor(data?: any) {
        if (data !== undefined) {
            this.callbackUrl = data["CallbackUrl"] !== undefined ? data["CallbackUrl"] : null;
            this.userName = data["UserName"] !== undefined ? data["UserName"] : null;
            this.password = data["Password"] !== undefined ? data["Password"] : null;
            this.language = data["Language"] !== undefined ? data["Language"] : null;
        }
    }

    static fromJS(data: any): ResendConfirmationModel {
        return new ResendConfirmationModel(data);
    }

    toJS(data?: any) {
        data = data === undefined ? {} : data;
        data["CallbackUrl"] = this.callbackUrl !== undefined ? this.callbackUrl : null;
        data["UserName"] = this.userName !== undefined ? this.userName : null;
        data["Password"] = this.password !== undefined ? this.password : null;
        data["Language"] = this.language !== undefined ? this.language : null;
        return data; 
    }

    toJSON() {
        return JSON.stringify(this.toJS());
    }

    clone() {
        var json = this.toJSON();
        return new ResendConfirmationModel(JSON.parse(json));
    }
}

export class ConfirmationModel { 
    userId: string; 
    code: string;

    constructor(data?: any) {
        if (data !== undefined) {
            this.userId = data["UserId"] !== undefined ? data["UserId"] : null;
            this.code = data["Code"] !== undefined ? data["Code"] : null;
        }
    }

    static fromJS(data: any): ConfirmationModel {
        return new ConfirmationModel(data);
    }

    toJS(data?: any) {
        data = data === undefined ? {} : data;
        data["UserId"] = this.userId !== undefined ? this.userId : null;
        data["Code"] = this.code !== undefined ? this.code : null;
        return data; 
    }

    toJSON() {
        return JSON.stringify(this.toJS());
    }

    clone() {
        var json = this.toJSON();
        return new ConfirmationModel(JSON.parse(json));
    }
}

export class ForgotPasswordViewModel { 
    callbackUrl: string; 
    userName: string; 
    email: string; 
    language: string;

    constructor(data?: any) {
        if (data !== undefined) {
            this.callbackUrl = data["CallbackUrl"] !== undefined ? data["CallbackUrl"] : null;
            this.userName = data["UserName"] !== undefined ? data["UserName"] : null;
            this.email = data["Email"] !== undefined ? data["Email"] : null;
            this.language = data["Language"] !== undefined ? data["Language"] : null;
        }
    }

    static fromJS(data: any): ForgotPasswordViewModel {
        return new ForgotPasswordViewModel(data);
    }

    toJS(data?: any) {
        data = data === undefined ? {} : data;
        data["CallbackUrl"] = this.callbackUrl !== undefined ? this.callbackUrl : null;
        data["UserName"] = this.userName !== undefined ? this.userName : null;
        data["Email"] = this.email !== undefined ? this.email : null;
        data["Language"] = this.language !== undefined ? this.language : null;
        return data; 
    }

    toJSON() {
        return JSON.stringify(this.toJS());
    }

    clone() {
        var json = this.toJSON();
        return new ForgotPasswordViewModel(JSON.parse(json));
    }
}

export class ResetPasswordViewModel { 
    userId: string; 
    password: string; 
    confirmPassword: string; 
    code: string;

    constructor(data?: any) {
        if (data !== undefined) {
            this.userId = data["UserId"] !== undefined ? data["UserId"] : null;
            this.password = data["Password"] !== undefined ? data["Password"] : null;
            this.confirmPassword = data["ConfirmPassword"] !== undefined ? data["ConfirmPassword"] : null;
            this.code = data["Code"] !== undefined ? data["Code"] : null;
        }
    }

    static fromJS(data: any): ResetPasswordViewModel {
        return new ResetPasswordViewModel(data);
    }

    toJS(data?: any) {
        data = data === undefined ? {} : data;
        data["UserId"] = this.userId !== undefined ? this.userId : null;
        data["Password"] = this.password !== undefined ? this.password : null;
        data["ConfirmPassword"] = this.confirmPassword !== undefined ? this.confirmPassword : null;
        data["Code"] = this.code !== undefined ? this.code : null;
        return data; 
    }

    toJSON() {
        return JSON.stringify(this.toJS());
    }

    clone() {
        var json = this.toJSON();
        return new ResetPasswordViewModel(JSON.parse(json));
    }
}

export class RegisterExternalBindingModel { 
    userName: string;

    constructor(data?: any) {
        if (data !== undefined) {
            this.userName = data["UserName"] !== undefined ? data["UserName"] : null;
        }
    }

    static fromJS(data: any): RegisterExternalBindingModel {
        return new RegisterExternalBindingModel(data);
    }

    toJS(data?: any) {
        data = data === undefined ? {} : data;
        data["UserName"] = this.userName !== undefined ? this.userName : null;
        return data; 
    }

    toJSON() {
        return JSON.stringify(this.toJS());
    }

    clone() {
        var json = this.toJSON();
        return new RegisterExternalBindingModel(JSON.parse(json));
    }
}

export class HistoryTurn { 
    gameId: number; 
    turnId: number; 
    actions: HistoryEntry[]; 
    game: Game;

    constructor(data?: any) {
        if (data !== undefined) {
            this.gameId = data["GameId"] !== undefined ? data["GameId"] : null;
            this.turnId = data["TurnId"] !== undefined ? data["TurnId"] : null;
            if (data["Actions"] && data["Actions"].constructor === Array) {
                this.actions = [];
                for (let item of data["Actions"])
                    this.actions.push(HistoryEntry.fromJS(item));
            }
            this.game = data["Game"] ? Game.fromJS(data["Game"]) : null;
        }
    }

    static fromJS(data: any): HistoryTurn {
        return new HistoryTurn(data);
    }

    toJS(data?: any) {
        data = data === undefined ? {} : data;
        data["GameId"] = this.gameId !== undefined ? this.gameId : null;
        data["TurnId"] = this.turnId !== undefined ? this.turnId : null;
        if (this.actions && this.actions.constructor === Array) {
            data["Actions"] = [];
            for (let item of this.actions)
                data["Actions"].push(item.toJS());
        }
        data["Game"] = this.game ? this.game.toJS() : null;
        return data; 
    }

    toJSON() {
        return JSON.stringify(this.toJS());
    }

    clone() {
        var json = this.toJSON();
        return new HistoryTurn(JSON.parse(json));
    }
}

export class HistoryEntry { 
    id: number; 
    turnNo: number; 
    dateTime: Date; 
    actorId: string; 
    otherPlayerId: string; 
    action: HistoryActionAsInteger; 
    originIdentifier: string; 
    destinationIdentifier: string; 
    units: number; 
    unitsLost: number; 
    unitsLostOther: number; 
    result: boolean;

    constructor(data?: any) {
        if (data !== undefined) {
            this.id = data["Id"] !== undefined ? data["Id"] : null;
            this.turnNo = data["TurnNo"] !== undefined ? data["TurnNo"] : null;
            this.dateTime = data["DateTime"] ? new Date(data["DateTime"].toString()) : null;
            this.actorId = data["ActorId"] !== undefined ? data["ActorId"] : null;
            this.otherPlayerId = data["OtherPlayerId"] !== undefined ? data["OtherPlayerId"] : null;
            this.action = data["Action"] !== undefined ? data["Action"] : null;
            this.originIdentifier = data["OriginIdentifier"] !== undefined ? data["OriginIdentifier"] : null;
            this.destinationIdentifier = data["DestinationIdentifier"] !== undefined ? data["DestinationIdentifier"] : null;
            this.units = data["Units"] !== undefined ? data["Units"] : null;
            this.unitsLost = data["UnitsLost"] !== undefined ? data["UnitsLost"] : null;
            this.unitsLostOther = data["UnitsLostOther"] !== undefined ? data["UnitsLostOther"] : null;
            this.result = data["Result"] !== undefined ? data["Result"] : null;
        }
    }

    static fromJS(data: any): HistoryEntry {
        return new HistoryEntry(data);
    }

    toJS(data?: any) {
        data = data === undefined ? {} : data;
        data["Id"] = this.id !== undefined ? this.id : null;
        data["TurnNo"] = this.turnNo !== undefined ? this.turnNo : null;
        data["DateTime"] = this.dateTime ? this.dateTime.toISOString() : null;
        data["ActorId"] = this.actorId !== undefined ? this.actorId : null;
        data["OtherPlayerId"] = this.otherPlayerId !== undefined ? this.otherPlayerId : null;
        data["Action"] = this.action !== undefined ? this.action : null;
        data["OriginIdentifier"] = this.originIdentifier !== undefined ? this.originIdentifier : null;
        data["DestinationIdentifier"] = this.destinationIdentifier !== undefined ? this.destinationIdentifier : null;
        data["Units"] = this.units !== undefined ? this.units : null;
        data["UnitsLost"] = this.unitsLost !== undefined ? this.unitsLost : null;
        data["UnitsLostOther"] = this.unitsLostOther !== undefined ? this.unitsLostOther : null;
        data["Result"] = this.result !== undefined ? this.result : null;
        return data; 
    }

    toJSON() {
        return JSON.stringify(this.toJS());
    }

    clone() {
        var json = this.toJSON();
        return new HistoryEntry(JSON.parse(json));
    }
}

export enum HistoryActionAsInteger {
    None = 0, 
    StartGame = 1, 
    EndGame = 2, 
    PlaceUnits = 3, 
    Attack = 4, 
    Move = 5, 
    ExchangeCards = 6, 
    PlayerLost = 7, 
    PlayerWon = 8, 
    PlayerTimeout = 9, 
    OwnerChange = 10, 
    EndTurn = 11, 
}

export class Game { 
    id: number; 
    type: GameTypeAsInteger; 
    name: string; 
    mapTemplate: string; 
    teams: Team[]; 
    state: GameStateAsInteger; 
    playState: PlayStateAsInteger; 
    currentPlayer: PlayerSummary; 
    map: Map; 
    options: GameOptions; 
    lastModifiedAt: Date; 
    timeoutSecondsLeft: number; 
    turnCounter: number; 
    unitsToPlace: number; 
    attacksInCurrentTurn: number; 
    movesInCurrentTurn: number;

    constructor(data?: any) {
        if (data !== undefined) {
            this.id = data["Id"] !== undefined ? data["Id"] : null;
            this.type = data["Type"] !== undefined ? data["Type"] : null;
            this.name = data["Name"] !== undefined ? data["Name"] : null;
            this.mapTemplate = data["MapTemplate"] !== undefined ? data["MapTemplate"] : null;
            if (data["Teams"] && data["Teams"].constructor === Array) {
                this.teams = [];
                for (let item of data["Teams"])
                    this.teams.push(Team.fromJS(item));
            }
            this.state = data["State"] !== undefined ? data["State"] : null;
            this.playState = data["PlayState"] !== undefined ? data["PlayState"] : null;
            this.currentPlayer = data["CurrentPlayer"] ? PlayerSummary.fromJS(data["CurrentPlayer"]) : null;
            this.map = data["Map"] ? Map.fromJS(data["Map"]) : null;
            this.options = data["Options"] ? GameOptions.fromJS(data["Options"]) : null;
            this.lastModifiedAt = data["LastModifiedAt"] ? new Date(data["LastModifiedAt"].toString()) : null;
            this.timeoutSecondsLeft = data["TimeoutSecondsLeft"] !== undefined ? data["TimeoutSecondsLeft"] : null;
            this.turnCounter = data["TurnCounter"] !== undefined ? data["TurnCounter"] : null;
            this.unitsToPlace = data["UnitsToPlace"] !== undefined ? data["UnitsToPlace"] : null;
            this.attacksInCurrentTurn = data["AttacksInCurrentTurn"] !== undefined ? data["AttacksInCurrentTurn"] : null;
            this.movesInCurrentTurn = data["MovesInCurrentTurn"] !== undefined ? data["MovesInCurrentTurn"] : null;
        }
    }

    static fromJS(data: any): Game {
        return new Game(data);
    }

    toJS(data?: any) {
        data = data === undefined ? {} : data;
        data["Id"] = this.id !== undefined ? this.id : null;
        data["Type"] = this.type !== undefined ? this.type : null;
        data["Name"] = this.name !== undefined ? this.name : null;
        data["MapTemplate"] = this.mapTemplate !== undefined ? this.mapTemplate : null;
        if (this.teams && this.teams.constructor === Array) {
            data["Teams"] = [];
            for (let item of this.teams)
                data["Teams"].push(item.toJS());
        }
        data["State"] = this.state !== undefined ? this.state : null;
        data["PlayState"] = this.playState !== undefined ? this.playState : null;
        data["CurrentPlayer"] = this.currentPlayer ? this.currentPlayer.toJS() : null;
        data["Map"] = this.map ? this.map.toJS() : null;
        data["Options"] = this.options ? this.options.toJS() : null;
        data["LastModifiedAt"] = this.lastModifiedAt ? this.lastModifiedAt.toISOString() : null;
        data["TimeoutSecondsLeft"] = this.timeoutSecondsLeft !== undefined ? this.timeoutSecondsLeft : null;
        data["TurnCounter"] = this.turnCounter !== undefined ? this.turnCounter : null;
        data["UnitsToPlace"] = this.unitsToPlace !== undefined ? this.unitsToPlace : null;
        data["AttacksInCurrentTurn"] = this.attacksInCurrentTurn !== undefined ? this.attacksInCurrentTurn : null;
        data["MovesInCurrentTurn"] = this.movesInCurrentTurn !== undefined ? this.movesInCurrentTurn : null;
        return data; 
    }

    toJSON() {
        return JSON.stringify(this.toJS());
    }

    clone() {
        var json = this.toJSON();
        return new Game(JSON.parse(json));
    }
}

export enum GameTypeAsInteger {
    Fun = 0, 
    Ranking = 1, 
    Tournament = 2, 
}

export class Team { 
    id: string; 
    playOrder: number; 
    players: Player[];

    constructor(data?: any) {
        if (data !== undefined) {
            this.id = data["Id"] !== undefined ? data["Id"] : null;
            this.playOrder = data["PlayOrder"] !== undefined ? data["PlayOrder"] : null;
            if (data["Players"] && data["Players"].constructor === Array) {
                this.players = [];
                for (let item of data["Players"])
                    this.players.push(Player.fromJS(item));
            }
        }
    }

    static fromJS(data: any): Team {
        return new Team(data);
    }

    toJS(data?: any) {
        data = data === undefined ? {} : data;
        data["Id"] = this.id !== undefined ? this.id : null;
        data["PlayOrder"] = this.playOrder !== undefined ? this.playOrder : null;
        if (this.players && this.players.constructor === Array) {
            data["Players"] = [];
            for (let item of this.players)
                data["Players"].push(item.toJS());
        }
        return data; 
    }

    toJSON() {
        return JSON.stringify(this.toJS());
    }

    clone() {
        var json = this.toJSON();
        return new Team(JSON.parse(json));
    }
}

export class PlayerSummary { 
    id: string; 
    userId: string; 
    name: string; 
    state: PlayerStateAsInteger; 
    outcome: PlayerOutcomeAsInteger; 
    teamId: string; 
    playOrder: number; 
    timeouts: number;

    constructor(data?: any) {
        if (data !== undefined) {
            this.id = data["Id"] !== undefined ? data["Id"] : null;
            this.userId = data["UserId"] !== undefined ? data["UserId"] : null;
            this.name = data["Name"] !== undefined ? data["Name"] : null;
            this.state = data["State"] !== undefined ? data["State"] : null;
            this.outcome = data["Outcome"] !== undefined ? data["Outcome"] : null;
            this.teamId = data["TeamId"] !== undefined ? data["TeamId"] : null;
            this.playOrder = data["PlayOrder"] !== undefined ? data["PlayOrder"] : null;
            this.timeouts = data["Timeouts"] !== undefined ? data["Timeouts"] : null;
        }
    }

    static fromJS(data: any): PlayerSummary {
        return new PlayerSummary(data);
    }

    toJS(data?: any) {
        data = data === undefined ? {} : data;
        data["Id"] = this.id !== undefined ? this.id : null;
        data["UserId"] = this.userId !== undefined ? this.userId : null;
        data["Name"] = this.name !== undefined ? this.name : null;
        data["State"] = this.state !== undefined ? this.state : null;
        data["Outcome"] = this.outcome !== undefined ? this.outcome : null;
        data["TeamId"] = this.teamId !== undefined ? this.teamId : null;
        data["PlayOrder"] = this.playOrder !== undefined ? this.playOrder : null;
        data["Timeouts"] = this.timeouts !== undefined ? this.timeouts : null;
        return data; 
    }

    toJSON() {
        return JSON.stringify(this.toJS());
    }

    clone() {
        var json = this.toJSON();
        return new PlayerSummary(JSON.parse(json));
    }
}

export class Player extends PlayerSummary { 
    cards: BonusCardAsInteger[]; 
    placedInitialUnits: boolean; 
    numberOfUnits: number; 
    numberOfCountries: number;

    constructor(data?: any) {
        super(data);
        if (data !== undefined) {
            if (data["Cards"] && data["Cards"].constructor === Array) {
                this.cards = [];
                for (let item of data["Cards"])
                    this.cards.push(item);
            }
            this.placedInitialUnits = data["PlacedInitialUnits"] !== undefined ? data["PlacedInitialUnits"] : null;
            this.numberOfUnits = data["NumberOfUnits"] !== undefined ? data["NumberOfUnits"] : null;
            this.numberOfCountries = data["NumberOfCountries"] !== undefined ? data["NumberOfCountries"] : null;
        }
    }

    static fromJS(data: any): Player {
        return new Player(data);
    }

    toJS(data?: any) {
        data = data === undefined ? {} : data;
        if (this.cards && this.cards.constructor === Array) {
            data["Cards"] = [];
            for (let item of this.cards)
                data["Cards"].push(item);
        }
        data["PlacedInitialUnits"] = this.placedInitialUnits !== undefined ? this.placedInitialUnits : null;
        data["NumberOfUnits"] = this.numberOfUnits !== undefined ? this.numberOfUnits : null;
        data["NumberOfCountries"] = this.numberOfCountries !== undefined ? this.numberOfCountries : null;
        super.toJS(data);
        return data; 
    }

    toJSON() {
        return JSON.stringify(this.toJS());
    }

    clone() {
        var json = this.toJSON();
        return new Player(JSON.parse(json));
    }
}

export enum BonusCardAsInteger {
    A = 0, 
    B = 1, 
    C = 2, 
}

export enum PlayerStateAsInteger {
    None = 0, 
    Active = 1, 
    InActive = 2, 
}

export enum PlayerOutcomeAsInteger {
    None = 0, 
    Won = 1, 
    Defeated = 2, 
    Surrendered = 3, 
    Timeout = 4, 
}

export enum GameStateAsInteger {
    None = 0, 
    Open = 1, 
    Active = 2, 
    Ended = 3, 
}

export enum PlayStateAsInteger {
    None = 0, 
    PlaceUnits = 1, 
    Attack = 2, 
    Move = 3, 
    Done = 4, 
}

export class Map { 
    countries: Country[];

    constructor(data?: any) {
        if (data !== undefined) {
            if (data["Countries"] && data["Countries"].constructor === Array) {
                this.countries = [];
                for (let item of data["Countries"])
                    this.countries.push(Country.fromJS(item));
            }
        }
    }

    static fromJS(data: any): Map {
        return new Map(data);
    }

    toJS(data?: any) {
        data = data === undefined ? {} : data;
        if (this.countries && this.countries.constructor === Array) {
            data["Countries"] = [];
            for (let item of this.countries)
                data["Countries"].push(item.toJS());
        }
        return data; 
    }

    toJSON() {
        return JSON.stringify(this.toJS());
    }

    clone() {
        var json = this.toJSON();
        return new Map(JSON.parse(json));
    }
}

export class Country { 
    identifier: string; 
    playerId: string; 
    teamId: string; 
    units: number;

    constructor(data?: any) {
        if (data !== undefined) {
            this.identifier = data["Identifier"] !== undefined ? data["Identifier"] : null;
            this.playerId = data["PlayerId"] !== undefined ? data["PlayerId"] : null;
            this.teamId = data["TeamId"] !== undefined ? data["TeamId"] : null;
            this.units = data["Units"] !== undefined ? data["Units"] : null;
        }
    }

    static fromJS(data: any): Country {
        return new Country(data);
    }

    toJS(data?: any) {
        data = data === undefined ? {} : data;
        data["Identifier"] = this.identifier !== undefined ? this.identifier : null;
        data["PlayerId"] = this.playerId !== undefined ? this.playerId : null;
        data["TeamId"] = this.teamId !== undefined ? this.teamId : null;
        data["Units"] = this.units !== undefined ? this.units : null;
        return data; 
    }

    toJSON() {
        return JSON.stringify(this.toJS());
    }

    clone() {
        var json = this.toJSON();
        return new Country(JSON.parse(json));
    }
}

export class GameOptions { 
    numberOfPlayersPerTeam: number; 
    numberOfTeams: number; 
    minUnitsPerCountry: number; 
    newUnitsPerTurn: number; 
    attacksPerTurn: number; 
    movesPerTurn: number; 
    initialCountryUnits: number; 
    mapDistribution: MapDistributionAsInteger; 
    timeoutInSeconds: number; 
    maximumTimeoutsPerPlayer: number; 
    maximumNumberOfCards: number; 
    victoryConditions: VictoryConditionTypeAsInteger[]; 
    visibilityModifier: VisibilityModifierTypeAsInteger[];

    constructor(data?: any) {
        if (data !== undefined) {
            this.numberOfPlayersPerTeam = data["NumberOfPlayersPerTeam"] !== undefined ? data["NumberOfPlayersPerTeam"] : null;
            this.numberOfTeams = data["NumberOfTeams"] !== undefined ? data["NumberOfTeams"] : null;
            this.minUnitsPerCountry = data["MinUnitsPerCountry"] !== undefined ? data["MinUnitsPerCountry"] : null;
            this.newUnitsPerTurn = data["NewUnitsPerTurn"] !== undefined ? data["NewUnitsPerTurn"] : null;
            this.attacksPerTurn = data["AttacksPerTurn"] !== undefined ? data["AttacksPerTurn"] : null;
            this.movesPerTurn = data["MovesPerTurn"] !== undefined ? data["MovesPerTurn"] : null;
            this.initialCountryUnits = data["InitialCountryUnits"] !== undefined ? data["InitialCountryUnits"] : null;
            this.mapDistribution = data["MapDistribution"] !== undefined ? data["MapDistribution"] : null;
            this.timeoutInSeconds = data["TimeoutInSeconds"] !== undefined ? data["TimeoutInSeconds"] : null;
            this.maximumTimeoutsPerPlayer = data["MaximumTimeoutsPerPlayer"] !== undefined ? data["MaximumTimeoutsPerPlayer"] : null;
            this.maximumNumberOfCards = data["MaximumNumberOfCards"] !== undefined ? data["MaximumNumberOfCards"] : null;
            if (data["VictoryConditions"] && data["VictoryConditions"].constructor === Array) {
                this.victoryConditions = [];
                for (let item of data["VictoryConditions"])
                    this.victoryConditions.push(item);
            }
            if (data["VisibilityModifier"] && data["VisibilityModifier"].constructor === Array) {
                this.visibilityModifier = [];
                for (let item of data["VisibilityModifier"])
                    this.visibilityModifier.push(item);
            }
        }
    }

    static fromJS(data: any): GameOptions {
        return new GameOptions(data);
    }

    toJS(data?: any) {
        data = data === undefined ? {} : data;
        data["NumberOfPlayersPerTeam"] = this.numberOfPlayersPerTeam !== undefined ? this.numberOfPlayersPerTeam : null;
        data["NumberOfTeams"] = this.numberOfTeams !== undefined ? this.numberOfTeams : null;
        data["MinUnitsPerCountry"] = this.minUnitsPerCountry !== undefined ? this.minUnitsPerCountry : null;
        data["NewUnitsPerTurn"] = this.newUnitsPerTurn !== undefined ? this.newUnitsPerTurn : null;
        data["AttacksPerTurn"] = this.attacksPerTurn !== undefined ? this.attacksPerTurn : null;
        data["MovesPerTurn"] = this.movesPerTurn !== undefined ? this.movesPerTurn : null;
        data["InitialCountryUnits"] = this.initialCountryUnits !== undefined ? this.initialCountryUnits : null;
        data["MapDistribution"] = this.mapDistribution !== undefined ? this.mapDistribution : null;
        data["TimeoutInSeconds"] = this.timeoutInSeconds !== undefined ? this.timeoutInSeconds : null;
        data["MaximumTimeoutsPerPlayer"] = this.maximumTimeoutsPerPlayer !== undefined ? this.maximumTimeoutsPerPlayer : null;
        data["MaximumNumberOfCards"] = this.maximumNumberOfCards !== undefined ? this.maximumNumberOfCards : null;
        if (this.victoryConditions && this.victoryConditions.constructor === Array) {
            data["VictoryConditions"] = [];
            for (let item of this.victoryConditions)
                data["VictoryConditions"].push(item);
        }
        if (this.visibilityModifier && this.visibilityModifier.constructor === Array) {
            data["VisibilityModifier"] = [];
            for (let item of this.visibilityModifier)
                data["VisibilityModifier"].push(item);
        }
        return data; 
    }

    toJSON() {
        return JSON.stringify(this.toJS());
    }

    clone() {
        var json = this.toJSON();
        return new GameOptions(JSON.parse(json));
    }
}

export enum MapDistributionAsInteger {
    Default = 0, 
    Malibu = 1, 
    TeamCluster = 2, 
}

export enum VictoryConditionTypeAsInteger {
    Survival = 0, 
    ControlContinent = 1, 
}

export enum VisibilityModifierTypeAsInteger {
    None = 0, 
    Fog = 1, 
}

export class LadderSummary { 
    id: string; 
    name: string; 
    options: GameOptions; 
    standing: LadderStanding; 
    isQueued: boolean; 
    queueCount: number; 
    mapTemplates: string[];

    constructor(data?: any) {
        if (data !== undefined) {
            this.id = data["Id"] !== undefined ? data["Id"] : null;
            this.name = data["Name"] !== undefined ? data["Name"] : null;
            this.options = data["Options"] ? GameOptions.fromJS(data["Options"]) : null;
            this.standing = data["Standing"] ? LadderStanding.fromJS(data["Standing"]) : null;
            this.isQueued = data["IsQueued"] !== undefined ? data["IsQueued"] : null;
            this.queueCount = data["QueueCount"] !== undefined ? data["QueueCount"] : null;
            if (data["MapTemplates"] && data["MapTemplates"].constructor === Array) {
                this.mapTemplates = [];
                for (let item of data["MapTemplates"])
                    this.mapTemplates.push(item);
            }
        }
    }

    static fromJS(data: any): LadderSummary {
        return new LadderSummary(data);
    }

    toJS(data?: any) {
        data = data === undefined ? {} : data;
        data["Id"] = this.id !== undefined ? this.id : null;
        data["Name"] = this.name !== undefined ? this.name : null;
        data["Options"] = this.options ? this.options.toJS() : null;
        data["Standing"] = this.standing ? this.standing.toJS() : null;
        data["IsQueued"] = this.isQueued !== undefined ? this.isQueued : null;
        data["QueueCount"] = this.queueCount !== undefined ? this.queueCount : null;
        if (this.mapTemplates && this.mapTemplates.constructor === Array) {
            data["MapTemplates"] = [];
            for (let item of this.mapTemplates)
                data["MapTemplates"].push(item);
        }
        return data; 
    }

    toJSON() {
        return JSON.stringify(this.toJS());
    }

    clone() {
        var json = this.toJSON();
        return new LadderSummary(JSON.parse(json));
    }
}

export class LadderStanding { 
    userId: string; 
    userName: string; 
    position: number; 
    gamesPlayed: number; 
    gamesWon: number; 
    gamesLost: number; 
    rating: number; 
    lastGame: Date;

    constructor(data?: any) {
        if (data !== undefined) {
            this.userId = data["UserId"] !== undefined ? data["UserId"] : null;
            this.userName = data["UserName"] !== undefined ? data["UserName"] : null;
            this.position = data["Position"] !== undefined ? data["Position"] : null;
            this.gamesPlayed = data["GamesPlayed"] !== undefined ? data["GamesPlayed"] : null;
            this.gamesWon = data["GamesWon"] !== undefined ? data["GamesWon"] : null;
            this.gamesLost = data["GamesLost"] !== undefined ? data["GamesLost"] : null;
            this.rating = data["Rating"] !== undefined ? data["Rating"] : null;
            this.lastGame = data["LastGame"] ? new Date(data["LastGame"].toString()) : null;
        }
    }

    static fromJS(data: any): LadderStanding {
        return new LadderStanding(data);
    }

    toJS(data?: any) {
        data = data === undefined ? {} : data;
        data["UserId"] = this.userId !== undefined ? this.userId : null;
        data["UserName"] = this.userName !== undefined ? this.userName : null;
        data["Position"] = this.position !== undefined ? this.position : null;
        data["GamesPlayed"] = this.gamesPlayed !== undefined ? this.gamesPlayed : null;
        data["GamesWon"] = this.gamesWon !== undefined ? this.gamesWon : null;
        data["GamesLost"] = this.gamesLost !== undefined ? this.gamesLost : null;
        data["Rating"] = this.rating !== undefined ? this.rating : null;
        data["LastGame"] = this.lastGame ? this.lastGame.toISOString() : null;
        return data; 
    }

    toJSON() {
        return JSON.stringify(this.toJS());
    }

    clone() {
        var json = this.toJSON();
        return new LadderStanding(JSON.parse(json));
    }
}

export class Ladder extends LadderSummary { 
    standings: LadderStanding[]; 
    isActive: boolean;

    constructor(data?: any) {
        super(data);
        if (data !== undefined) {
            if (data["Standings"] && data["Standings"].constructor === Array) {
                this.standings = [];
                for (let item of data["Standings"])
                    this.standings.push(LadderStanding.fromJS(item));
            }
            this.isActive = data["IsActive"] !== undefined ? data["IsActive"] : null;
        }
    }

    static fromJS(data: any): Ladder {
        return new Ladder(data);
    }

    toJS(data?: any) {
        data = data === undefined ? {} : data;
        if (this.standings && this.standings.constructor === Array) {
            data["Standings"] = [];
            for (let item of this.standings)
                data["Standings"].push(item.toJS());
        }
        data["IsActive"] = this.isActive !== undefined ? this.isActive : null;
        super.toJS(data);
        return data; 
    }

    toJSON() {
        return JSON.stringify(this.toJS());
    }

    clone() {
        var json = this.toJSON();
        return new Ladder(JSON.parse(json));
    }
}

export class MapTemplateDescriptor { 
    name: string;

    constructor(data?: any) {
        if (data !== undefined) {
            this.name = data["Name"] !== undefined ? data["Name"] : null;
        }
    }

    static fromJS(data: any): MapTemplateDescriptor {
        return new MapTemplateDescriptor(data);
    }

    toJS(data?: any) {
        data = data === undefined ? {} : data;
        data["Name"] = this.name !== undefined ? this.name : null;
        return data; 
    }

    toJSON() {
        return JSON.stringify(this.toJS());
    }

    clone() {
        var json = this.toJSON();
        return new MapTemplateDescriptor(JSON.parse(json));
    }
}

export class MapTemplate { 
    name: string; 
    image: string; 
    countries: CountryTemplate[]; 
    connections: Connection[]; 
    continents: Continent[];

    constructor(data?: any) {
        if (data !== undefined) {
            this.name = data["Name"] !== undefined ? data["Name"] : null;
            this.image = data["Image"] !== undefined ? data["Image"] : null;
            if (data["Countries"] && data["Countries"].constructor === Array) {
                this.countries = [];
                for (let item of data["Countries"])
                    this.countries.push(CountryTemplate.fromJS(item));
            }
            if (data["Connections"] && data["Connections"].constructor === Array) {
                this.connections = [];
                for (let item of data["Connections"])
                    this.connections.push(Connection.fromJS(item));
            }
            if (data["Continents"] && data["Continents"].constructor === Array) {
                this.continents = [];
                for (let item of data["Continents"])
                    this.continents.push(Continent.fromJS(item));
            }
        }
    }

    static fromJS(data: any): MapTemplate {
        return new MapTemplate(data);
    }

    toJS(data?: any) {
        data = data === undefined ? {} : data;
        data["Name"] = this.name !== undefined ? this.name : null;
        data["Image"] = this.image !== undefined ? this.image : null;
        if (this.countries && this.countries.constructor === Array) {
            data["Countries"] = [];
            for (let item of this.countries)
                data["Countries"].push(item.toJS());
        }
        if (this.connections && this.connections.constructor === Array) {
            data["Connections"] = [];
            for (let item of this.connections)
                data["Connections"].push(item.toJS());
        }
        if (this.continents && this.continents.constructor === Array) {
            data["Continents"] = [];
            for (let item of this.continents)
                data["Continents"].push(item.toJS());
        }
        return data; 
    }

    toJSON() {
        return JSON.stringify(this.toJS());
    }

    clone() {
        var json = this.toJSON();
        return new MapTemplate(JSON.parse(json));
    }
}

export class CountryTemplate { 
    identifier: string; 
    name: string; 
    x: number; 
    y: number;

    constructor(data?: any) {
        if (data !== undefined) {
            this.identifier = data["Identifier"] !== undefined ? data["Identifier"] : null;
            this.name = data["Name"] !== undefined ? data["Name"] : null;
            this.x = data["X"] !== undefined ? data["X"] : null;
            this.y = data["Y"] !== undefined ? data["Y"] : null;
        }
    }

    static fromJS(data: any): CountryTemplate {
        return new CountryTemplate(data);
    }

    toJS(data?: any) {
        data = data === undefined ? {} : data;
        data["Identifier"] = this.identifier !== undefined ? this.identifier : null;
        data["Name"] = this.name !== undefined ? this.name : null;
        data["X"] = this.x !== undefined ? this.x : null;
        data["Y"] = this.y !== undefined ? this.y : null;
        return data; 
    }

    toJSON() {
        return JSON.stringify(this.toJS());
    }

    clone() {
        var json = this.toJSON();
        return new CountryTemplate(JSON.parse(json));
    }
}

export class Connection { 
    origin: string; 
    destination: string;

    constructor(data?: any) {
        if (data !== undefined) {
            this.origin = data["Origin"] !== undefined ? data["Origin"] : null;
            this.destination = data["Destination"] !== undefined ? data["Destination"] : null;
        }
    }

    static fromJS(data: any): Connection {
        return new Connection(data);
    }

    toJS(data?: any) {
        data = data === undefined ? {} : data;
        data["Origin"] = this.origin !== undefined ? this.origin : null;
        data["Destination"] = this.destination !== undefined ? this.destination : null;
        return data; 
    }

    toJSON() {
        return JSON.stringify(this.toJS());
    }

    clone() {
        var json = this.toJSON();
        return new Connection(JSON.parse(json));
    }
}

export class Continent { 
    id: number; 
    name: string; 
    bonus: number; 
    countries: string[];

    constructor(data?: any) {
        if (data !== undefined) {
            this.id = data["Id"] !== undefined ? data["Id"] : null;
            this.name = data["Name"] !== undefined ? data["Name"] : null;
            this.bonus = data["Bonus"] !== undefined ? data["Bonus"] : null;
            if (data["Countries"] && data["Countries"].constructor === Array) {
                this.countries = [];
                for (let item of data["Countries"])
                    this.countries.push(item);
            }
        }
    }

    static fromJS(data: any): Continent {
        return new Continent(data);
    }

    toJS(data?: any) {
        data = data === undefined ? {} : data;
        data["Id"] = this.id !== undefined ? this.id : null;
        data["Name"] = this.name !== undefined ? this.name : null;
        data["Bonus"] = this.bonus !== undefined ? this.bonus : null;
        if (this.countries && this.countries.constructor === Array) {
            data["Countries"] = [];
            for (let item of this.countries)
                data["Countries"].push(item);
        }
        return data; 
    }

    toJSON() {
        return JSON.stringify(this.toJS());
    }

    clone() {
        var json = this.toJSON();
        return new Continent(JSON.parse(json));
    }
}

export class GameSummary { 
    id: number; 
    type: GameTypeAsInteger; 
    name: string; 
    ladderId: string; 
    ladderName: string; 
    options: GameOptions; 
    createdByUserId: string; 
    createdByName: string; 
    startedAt: Date; 
    lastActionAt: Date; 
    timeoutSecondsLeft: number; 
    mapTemplate: string; 
    state: GameStateAsInteger; 
    currentPlayer: PlayerSummary; 
    teams: TeamSummary[];

    constructor(data?: any) {
        if (data !== undefined) {
            this.id = data["Id"] !== undefined ? data["Id"] : null;
            this.type = data["Type"] !== undefined ? data["Type"] : null;
            this.name = data["Name"] !== undefined ? data["Name"] : null;
            this.ladderId = data["LadderId"] !== undefined ? data["LadderId"] : null;
            this.ladderName = data["LadderName"] !== undefined ? data["LadderName"] : null;
            this.options = data["Options"] ? GameOptions.fromJS(data["Options"]) : null;
            this.createdByUserId = data["CreatedByUserId"] !== undefined ? data["CreatedByUserId"] : null;
            this.createdByName = data["CreatedByName"] !== undefined ? data["CreatedByName"] : null;
            this.startedAt = data["StartedAt"] ? new Date(data["StartedAt"].toString()) : null;
            this.lastActionAt = data["LastActionAt"] ? new Date(data["LastActionAt"].toString()) : null;
            this.timeoutSecondsLeft = data["TimeoutSecondsLeft"] !== undefined ? data["TimeoutSecondsLeft"] : null;
            this.mapTemplate = data["MapTemplate"] !== undefined ? data["MapTemplate"] : null;
            this.state = data["State"] !== undefined ? data["State"] : null;
            this.currentPlayer = data["CurrentPlayer"] ? PlayerSummary.fromJS(data["CurrentPlayer"]) : null;
            if (data["Teams"] && data["Teams"].constructor === Array) {
                this.teams = [];
                for (let item of data["Teams"])
                    this.teams.push(TeamSummary.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GameSummary {
        return new GameSummary(data);
    }

    toJS(data?: any) {
        data = data === undefined ? {} : data;
        data["Id"] = this.id !== undefined ? this.id : null;
        data["Type"] = this.type !== undefined ? this.type : null;
        data["Name"] = this.name !== undefined ? this.name : null;
        data["LadderId"] = this.ladderId !== undefined ? this.ladderId : null;
        data["LadderName"] = this.ladderName !== undefined ? this.ladderName : null;
        data["Options"] = this.options ? this.options.toJS() : null;
        data["CreatedByUserId"] = this.createdByUserId !== undefined ? this.createdByUserId : null;
        data["CreatedByName"] = this.createdByName !== undefined ? this.createdByName : null;
        data["StartedAt"] = this.startedAt ? this.startedAt.toISOString() : null;
        data["LastActionAt"] = this.lastActionAt ? this.lastActionAt.toISOString() : null;
        data["TimeoutSecondsLeft"] = this.timeoutSecondsLeft !== undefined ? this.timeoutSecondsLeft : null;
        data["MapTemplate"] = this.mapTemplate !== undefined ? this.mapTemplate : null;
        data["State"] = this.state !== undefined ? this.state : null;
        data["CurrentPlayer"] = this.currentPlayer ? this.currentPlayer.toJS() : null;
        if (this.teams && this.teams.constructor === Array) {
            data["Teams"] = [];
            for (let item of this.teams)
                data["Teams"].push(item.toJS());
        }
        return data; 
    }

    toJSON() {
        return JSON.stringify(this.toJS());
    }

    clone() {
        var json = this.toJSON();
        return new GameSummary(JSON.parse(json));
    }
}

export class TeamSummary { 
    id: string; 
    playOrder: number; 
    players: PlayerSummary[];

    constructor(data?: any) {
        if (data !== undefined) {
            this.id = data["Id"] !== undefined ? data["Id"] : null;
            this.playOrder = data["PlayOrder"] !== undefined ? data["PlayOrder"] : null;
            if (data["Players"] && data["Players"].constructor === Array) {
                this.players = [];
                for (let item of data["Players"])
                    this.players.push(PlayerSummary.fromJS(item));
            }
        }
    }

    static fromJS(data: any): TeamSummary {
        return new TeamSummary(data);
    }

    toJS(data?: any) {
        data = data === undefined ? {} : data;
        data["Id"] = this.id !== undefined ? this.id : null;
        data["PlayOrder"] = this.playOrder !== undefined ? this.playOrder : null;
        if (this.players && this.players.constructor === Array) {
            data["Players"] = [];
            for (let item of this.players)
                data["Players"].push(item.toJS());
        }
        return data; 
    }

    toJSON() {
        return JSON.stringify(this.toJS());
    }

    clone() {
        var json = this.toJSON();
        return new TeamSummary(JSON.parse(json));
    }
}

export class GameCreationOptions extends GameOptions { 
    name: string; 
    addBot: boolean; 
    mapTemplate: string;

    constructor(data?: any) {
        super(data);
        if (data !== undefined) {
            this.name = data["Name"] !== undefined ? data["Name"] : null;
            this.addBot = data["AddBot"] !== undefined ? data["AddBot"] : null;
            this.mapTemplate = data["MapTemplate"] !== undefined ? data["MapTemplate"] : null;
        }
    }

    static fromJS(data: any): GameCreationOptions {
        return new GameCreationOptions(data);
    }

    toJS(data?: any) {
        data = data === undefined ? {} : data;
        data["Name"] = this.name !== undefined ? this.name : null;
        data["AddBot"] = this.addBot !== undefined ? this.addBot : null;
        data["MapTemplate"] = this.mapTemplate !== undefined ? this.mapTemplate : null;
        super.toJS(data);
        return data; 
    }

    toJSON() {
        return JSON.stringify(this.toJS());
    }

    clone() {
        var json = this.toJSON();
        return new GameCreationOptions(JSON.parse(json));
    }
}

export enum MessageFolderAsInteger {
    None = 0, 
    Inbox = 1, 
    Sent = 2, 
}

export class SendMessage { 
    to: UserReference; 
    subject: string; 
    text: string;

    constructor(data?: any) {
        if (data !== undefined) {
            this.to = data["To"] ? UserReference.fromJS(data["To"]) : null;
            this.subject = data["Subject"] !== undefined ? data["Subject"] : null;
            this.text = data["Text"] !== undefined ? data["Text"] : null;
        }
    }

    static fromJS(data: any): SendMessage {
        return new SendMessage(data);
    }

    toJS(data?: any) {
        data = data === undefined ? {} : data;
        data["To"] = this.to ? this.to.toJS() : null;
        data["Subject"] = this.subject !== undefined ? this.subject : null;
        data["Text"] = this.text !== undefined ? this.text : null;
        return data; 
    }

    toJSON() {
        return JSON.stringify(this.toJS());
    }

    clone() {
        var json = this.toJSON();
        return new SendMessage(JSON.parse(json));
    }
}

export class Message extends SendMessage { 
    id: string; 
    from: UserReference; 
    folder: MessageFolderAsInteger; 
    sentAt: Date; 
    isRead: boolean;

    constructor(data?: any) {
        super(data);
        if (data !== undefined) {
            this.id = data["Id"] !== undefined ? data["Id"] : null;
            this.from = data["From"] ? UserReference.fromJS(data["From"]) : null;
            this.folder = data["Folder"] !== undefined ? data["Folder"] : null;
            this.sentAt = data["SentAt"] ? new Date(data["SentAt"].toString()) : null;
            this.isRead = data["IsRead"] !== undefined ? data["IsRead"] : null;
        }
    }

    static fromJS(data: any): Message {
        return new Message(data);
    }

    toJS(data?: any) {
        data = data === undefined ? {} : data;
        data["Id"] = this.id !== undefined ? this.id : null;
        data["From"] = this.from ? this.from.toJS() : null;
        data["Folder"] = this.folder !== undefined ? this.folder : null;
        data["SentAt"] = this.sentAt ? this.sentAt.toISOString() : null;
        data["IsRead"] = this.isRead !== undefined ? this.isRead : null;
        super.toJS(data);
        return data; 
    }

    toJSON() {
        return JSON.stringify(this.toJS());
    }

    clone() {
        var json = this.toJSON();
        return new Message(JSON.parse(json));
    }
}

export class UserReference { 
    id: string; 
    name: string;

    constructor(data?: any) {
        if (data !== undefined) {
            this.id = data["Id"] !== undefined ? data["Id"] : null;
            this.name = data["Name"] !== undefined ? data["Name"] : null;
        }
    }

    static fromJS(data: any): UserReference {
        return new UserReference(data);
    }

    toJS(data?: any) {
        data = data === undefined ? {} : data;
        data["Id"] = this.id !== undefined ? this.id : null;
        data["Name"] = this.name !== undefined ? this.name : null;
        return data; 
    }

    toJSON() {
        return JSON.stringify(this.toJS());
    }

    clone() {
        var json = this.toJSON();
        return new UserReference(JSON.parse(json));
    }
}

export class FolderInformation { 
    folder: MessageFolderAsInteger; 
    count: number; 
    unreadCount: number;

    constructor(data?: any) {
        if (data !== undefined) {
            this.folder = data["Folder"] !== undefined ? data["Folder"] : null;
            this.count = data["Count"] !== undefined ? data["Count"] : null;
            this.unreadCount = data["UnreadCount"] !== undefined ? data["UnreadCount"] : null;
        }
    }

    static fromJS(data: any): FolderInformation {
        return new FolderInformation(data);
    }

    toJS(data?: any) {
        data = data === undefined ? {} : data;
        data["Folder"] = this.folder !== undefined ? this.folder : null;
        data["Count"] = this.count !== undefined ? this.count : null;
        data["UnreadCount"] = this.unreadCount !== undefined ? this.unreadCount : null;
        return data; 
    }

    toJSON() {
        return JSON.stringify(this.toJS());
    }

    clone() {
        var json = this.toJSON();
        return new FolderInformation(JSON.parse(json));
    }
}

export class NewsItem { 
    dateTime: Date; 
    postedBy: string; 
    content: NewsContent[];

    constructor(data?: any) {
        if (data !== undefined) {
            this.dateTime = data["DateTime"] ? new Date(data["DateTime"].toString()) : null;
            this.postedBy = data["PostedBy"] !== undefined ? data["PostedBy"] : null;
            if (data["Content"] && data["Content"].constructor === Array) {
                this.content = [];
                for (let item of data["Content"])
                    this.content.push(NewsContent.fromJS(item));
            }
        }
    }

    static fromJS(data: any): NewsItem {
        return new NewsItem(data);
    }

    toJS(data?: any) {
        data = data === undefined ? {} : data;
        data["DateTime"] = this.dateTime ? this.dateTime.toISOString() : null;
        data["PostedBy"] = this.postedBy !== undefined ? this.postedBy : null;
        if (this.content && this.content.constructor === Array) {
            data["Content"] = [];
            for (let item of this.content)
                data["Content"].push(item.toJS());
        }
        return data; 
    }

    toJSON() {
        return JSON.stringify(this.toJS());
    }

    clone() {
        var json = this.toJSON();
        return new NewsItem(JSON.parse(json));
    }
}

export class NewsContent { 
    language: string; 
    title: string; 
    text: string;

    constructor(data?: any) {
        if (data !== undefined) {
            this.language = data["Language"] !== undefined ? data["Language"] : null;
            this.title = data["Title"] !== undefined ? data["Title"] : null;
            this.text = data["Text"] !== undefined ? data["Text"] : null;
        }
    }

    static fromJS(data: any): NewsContent {
        return new NewsContent(data);
    }

    toJS(data?: any) {
        data = data === undefined ? {} : data;
        data["Language"] = this.language !== undefined ? this.language : null;
        data["Title"] = this.title !== undefined ? this.title : null;
        data["Text"] = this.text !== undefined ? this.text : null;
        return data; 
    }

    toJSON() {
        return JSON.stringify(this.toJS());
    }

    clone() {
        var json = this.toJSON();
        return new NewsContent(JSON.parse(json));
    }
}

export class PlaceUnitsOptions { 
    countryIdentifier: string; 
    numberOfUnits: number;

    constructor(data?: any) {
        if (data !== undefined) {
            this.countryIdentifier = data["CountryIdentifier"] !== undefined ? data["CountryIdentifier"] : null;
            this.numberOfUnits = data["NumberOfUnits"] !== undefined ? data["NumberOfUnits"] : null;
        }
    }

    static fromJS(data: any): PlaceUnitsOptions {
        return new PlaceUnitsOptions(data);
    }

    toJS(data?: any) {
        data = data === undefined ? {} : data;
        data["CountryIdentifier"] = this.countryIdentifier !== undefined ? this.countryIdentifier : null;
        data["NumberOfUnits"] = this.numberOfUnits !== undefined ? this.numberOfUnits : null;
        return data; 
    }

    toJSON() {
        return JSON.stringify(this.toJS());
    }

    clone() {
        var json = this.toJSON();
        return new PlaceUnitsOptions(JSON.parse(json));
    }
}

export class GameActionResult { 
    id: number; 
    teams: Team[]; 
    state: GameStateAsInteger; 
    playState: PlayStateAsInteger; 
    countryUpdates: Country[]; 
    actionResult: ActionResultAsInteger; 
    attacksInCurrentTurn: number; 
    movesInCurrentTurn: number; 
    cards: BonusCardAsInteger[]; 
    currentPlayer: Player;

    constructor(data?: any) {
        if (data !== undefined) {
            this.id = data["Id"] !== undefined ? data["Id"] : null;
            if (data["Teams"] && data["Teams"].constructor === Array) {
                this.teams = [];
                for (let item of data["Teams"])
                    this.teams.push(Team.fromJS(item));
            }
            this.state = data["State"] !== undefined ? data["State"] : null;
            this.playState = data["PlayState"] !== undefined ? data["PlayState"] : null;
            if (data["CountryUpdates"] && data["CountryUpdates"].constructor === Array) {
                this.countryUpdates = [];
                for (let item of data["CountryUpdates"])
                    this.countryUpdates.push(Country.fromJS(item));
            }
            this.actionResult = data["ActionResult"] !== undefined ? data["ActionResult"] : null;
            this.attacksInCurrentTurn = data["AttacksInCurrentTurn"] !== undefined ? data["AttacksInCurrentTurn"] : null;
            this.movesInCurrentTurn = data["MovesInCurrentTurn"] !== undefined ? data["MovesInCurrentTurn"] : null;
            if (data["Cards"] && data["Cards"].constructor === Array) {
                this.cards = [];
                for (let item of data["Cards"])
                    this.cards.push(item);
            }
            this.currentPlayer = data["CurrentPlayer"] ? Player.fromJS(data["CurrentPlayer"]) : null;
        }
    }

    static fromJS(data: any): GameActionResult {
        return new GameActionResult(data);
    }

    toJS(data?: any) {
        data = data === undefined ? {} : data;
        data["Id"] = this.id !== undefined ? this.id : null;
        if (this.teams && this.teams.constructor === Array) {
            data["Teams"] = [];
            for (let item of this.teams)
                data["Teams"].push(item.toJS());
        }
        data["State"] = this.state !== undefined ? this.state : null;
        data["PlayState"] = this.playState !== undefined ? this.playState : null;
        if (this.countryUpdates && this.countryUpdates.constructor === Array) {
            data["CountryUpdates"] = [];
            for (let item of this.countryUpdates)
                data["CountryUpdates"].push(item.toJS());
        }
        data["ActionResult"] = this.actionResult !== undefined ? this.actionResult : null;
        data["AttacksInCurrentTurn"] = this.attacksInCurrentTurn !== undefined ? this.attacksInCurrentTurn : null;
        data["MovesInCurrentTurn"] = this.movesInCurrentTurn !== undefined ? this.movesInCurrentTurn : null;
        if (this.cards && this.cards.constructor === Array) {
            data["Cards"] = [];
            for (let item of this.cards)
                data["Cards"].push(item);
        }
        data["CurrentPlayer"] = this.currentPlayer ? this.currentPlayer.toJS() : null;
        return data; 
    }

    toJSON() {
        return JSON.stringify(this.toJS());
    }

    clone() {
        var json = this.toJSON();
        return new GameActionResult(JSON.parse(json));
    }
}

export enum ActionResultAsInteger {
    None = 0, 
    Successful = 1, 
    NotSuccessful = 2, 
}

export class AttackOptions { 
    originCountryIdentifier: string; 
    destinationCountryIdentifier: string; 
    numberOfUnits: number;

    constructor(data?: any) {
        if (data !== undefined) {
            this.originCountryIdentifier = data["OriginCountryIdentifier"] !== undefined ? data["OriginCountryIdentifier"] : null;
            this.destinationCountryIdentifier = data["DestinationCountryIdentifier"] !== undefined ? data["DestinationCountryIdentifier"] : null;
            this.numberOfUnits = data["NumberOfUnits"] !== undefined ? data["NumberOfUnits"] : null;
        }
    }

    static fromJS(data: any): AttackOptions {
        return new AttackOptions(data);
    }

    toJS(data?: any) {
        data = data === undefined ? {} : data;
        data["OriginCountryIdentifier"] = this.originCountryIdentifier !== undefined ? this.originCountryIdentifier : null;
        data["DestinationCountryIdentifier"] = this.destinationCountryIdentifier !== undefined ? this.destinationCountryIdentifier : null;
        data["NumberOfUnits"] = this.numberOfUnits !== undefined ? this.numberOfUnits : null;
        return data; 
    }

    toJSON() {
        return JSON.stringify(this.toJS());
    }

    clone() {
        var json = this.toJSON();
        return new AttackOptions(JSON.parse(json));
    }
}

export class MoveOptions { 
    originCountryIdentifier: string; 
    destinationCountryIdentifier: string; 
    numberOfUnits: number;

    constructor(data?: any) {
        if (data !== undefined) {
            this.originCountryIdentifier = data["OriginCountryIdentifier"] !== undefined ? data["OriginCountryIdentifier"] : null;
            this.destinationCountryIdentifier = data["DestinationCountryIdentifier"] !== undefined ? data["DestinationCountryIdentifier"] : null;
            this.numberOfUnits = data["NumberOfUnits"] !== undefined ? data["NumberOfUnits"] : null;
        }
    }

    static fromJS(data: any): MoveOptions {
        return new MoveOptions(data);
    }

    toJS(data?: any) {
        data = data === undefined ? {} : data;
        data["OriginCountryIdentifier"] = this.originCountryIdentifier !== undefined ? this.originCountryIdentifier : null;
        data["DestinationCountryIdentifier"] = this.destinationCountryIdentifier !== undefined ? this.destinationCountryIdentifier : null;
        data["NumberOfUnits"] = this.numberOfUnits !== undefined ? this.numberOfUnits : null;
        return data; 
    }

    toJSON() {
        return JSON.stringify(this.toJS());
    }

    clone() {
        var json = this.toJSON();
        return new MoveOptions(JSON.parse(json));
    }
}

export class TournamentSummary { 
    id: string; 
    name: string; 
    state: TournamentStateAsInteger; 
    options: GameOptions; 
    numberOfTeams: number; 
    numberOfGroupGames: number; 
    numberOfKnockoutGames: number; 
    numberOfFinalGames: number; 
    startOfRegistration: Date; 
    startOfTournament: Date; 
    endOfTournament: Date; 
    completion: number;

    constructor(data?: any) {
        if (data !== undefined) {
            this.id = data["Id"] !== undefined ? data["Id"] : null;
            this.name = data["Name"] !== undefined ? data["Name"] : null;
            this.state = data["State"] !== undefined ? data["State"] : null;
            this.options = data["Options"] ? GameOptions.fromJS(data["Options"]) : null;
            this.numberOfTeams = data["NumberOfTeams"] !== undefined ? data["NumberOfTeams"] : null;
            this.numberOfGroupGames = data["NumberOfGroupGames"] !== undefined ? data["NumberOfGroupGames"] : null;
            this.numberOfKnockoutGames = data["NumberOfKnockoutGames"] !== undefined ? data["NumberOfKnockoutGames"] : null;
            this.numberOfFinalGames = data["NumberOfFinalGames"] !== undefined ? data["NumberOfFinalGames"] : null;
            this.startOfRegistration = data["StartOfRegistration"] ? new Date(data["StartOfRegistration"].toString()) : null;
            this.startOfTournament = data["StartOfTournament"] ? new Date(data["StartOfTournament"].toString()) : null;
            this.endOfTournament = data["EndOfTournament"] ? new Date(data["EndOfTournament"].toString()) : null;
            this.completion = data["Completion"] !== undefined ? data["Completion"] : null;
        }
    }

    static fromJS(data: any): TournamentSummary {
        return new TournamentSummary(data);
    }

    toJS(data?: any) {
        data = data === undefined ? {} : data;
        data["Id"] = this.id !== undefined ? this.id : null;
        data["Name"] = this.name !== undefined ? this.name : null;
        data["State"] = this.state !== undefined ? this.state : null;
        data["Options"] = this.options ? this.options.toJS() : null;
        data["NumberOfTeams"] = this.numberOfTeams !== undefined ? this.numberOfTeams : null;
        data["NumberOfGroupGames"] = this.numberOfGroupGames !== undefined ? this.numberOfGroupGames : null;
        data["NumberOfKnockoutGames"] = this.numberOfKnockoutGames !== undefined ? this.numberOfKnockoutGames : null;
        data["NumberOfFinalGames"] = this.numberOfFinalGames !== undefined ? this.numberOfFinalGames : null;
        data["StartOfRegistration"] = this.startOfRegistration ? this.startOfRegistration.toISOString() : null;
        data["StartOfTournament"] = this.startOfTournament ? this.startOfTournament.toISOString() : null;
        data["EndOfTournament"] = this.endOfTournament ? this.endOfTournament.toISOString() : null;
        data["Completion"] = this.completion !== undefined ? this.completion : null;
        return data; 
    }

    toJSON() {
        return JSON.stringify(this.toJS());
    }

    clone() {
        var json = this.toJSON();
        return new TournamentSummary(JSON.parse(json));
    }
}

export class Tournament extends TournamentSummary { 
    teams: TournamentTeam[]; 
    groups: TournamentGroup[]; 
    pairings: TournamentPairing[]; 
    mapTemplates: string[]; 
    winner: TournamentTeam; 
    phase: number;

    constructor(data?: any) {
        super(data);
        if (data !== undefined) {
            if (data["Teams"] && data["Teams"].constructor === Array) {
                this.teams = [];
                for (let item of data["Teams"])
                    this.teams.push(TournamentTeam.fromJS(item));
            }
            if (data["Groups"] && data["Groups"].constructor === Array) {
                this.groups = [];
                for (let item of data["Groups"])
                    this.groups.push(TournamentGroup.fromJS(item));
            }
            if (data["Pairings"] && data["Pairings"].constructor === Array) {
                this.pairings = [];
                for (let item of data["Pairings"])
                    this.pairings.push(TournamentPairing.fromJS(item));
            }
            if (data["MapTemplates"] && data["MapTemplates"].constructor === Array) {
                this.mapTemplates = [];
                for (let item of data["MapTemplates"])
                    this.mapTemplates.push(item);
            }
            this.winner = data["Winner"] ? TournamentTeam.fromJS(data["Winner"]) : null;
            this.phase = data["Phase"] !== undefined ? data["Phase"] : null;
        }
    }

    static fromJS(data: any): Tournament {
        return new Tournament(data);
    }

    toJS(data?: any) {
        data = data === undefined ? {} : data;
        if (this.teams && this.teams.constructor === Array) {
            data["Teams"] = [];
            for (let item of this.teams)
                data["Teams"].push(item.toJS());
        }
        if (this.groups && this.groups.constructor === Array) {
            data["Groups"] = [];
            for (let item of this.groups)
                data["Groups"].push(item.toJS());
        }
        if (this.pairings && this.pairings.constructor === Array) {
            data["Pairings"] = [];
            for (let item of this.pairings)
                data["Pairings"].push(item.toJS());
        }
        if (this.mapTemplates && this.mapTemplates.constructor === Array) {
            data["MapTemplates"] = [];
            for (let item of this.mapTemplates)
                data["MapTemplates"].push(item);
        }
        data["Winner"] = this.winner ? this.winner.toJS() : null;
        data["Phase"] = this.phase !== undefined ? this.phase : null;
        super.toJS(data);
        return data; 
    }

    toJSON() {
        return JSON.stringify(this.toJS());
    }

    clone() {
        var json = this.toJSON();
        return new Tournament(JSON.parse(json));
    }
}

export class TournamentTeamSummary { 
    id: string; 
    name: string; 
    groupOrder: number; 
    state: TournamentTeamStateAsInteger;

    constructor(data?: any) {
        if (data !== undefined) {
            this.id = data["Id"] !== undefined ? data["Id"] : null;
            this.name = data["Name"] !== undefined ? data["Name"] : null;
            this.groupOrder = data["GroupOrder"] !== undefined ? data["GroupOrder"] : null;
            this.state = data["State"] !== undefined ? data["State"] : null;
        }
    }

    static fromJS(data: any): TournamentTeamSummary {
        return new TournamentTeamSummary(data);
    }

    toJS(data?: any) {
        data = data === undefined ? {} : data;
        data["Id"] = this.id !== undefined ? this.id : null;
        data["Name"] = this.name !== undefined ? this.name : null;
        data["GroupOrder"] = this.groupOrder !== undefined ? this.groupOrder : null;
        data["State"] = this.state !== undefined ? this.state : null;
        return data; 
    }

    toJSON() {
        return JSON.stringify(this.toJS());
    }

    clone() {
        var json = this.toJSON();
        return new TournamentTeamSummary(JSON.parse(json));
    }
}

export class TournamentTeam extends TournamentTeamSummary { 
    participants: UserReference[];

    constructor(data?: any) {
        super(data);
        if (data !== undefined) {
            if (data["Participants"] && data["Participants"].constructor === Array) {
                this.participants = [];
                for (let item of data["Participants"])
                    this.participants.push(UserReference.fromJS(item));
            }
        }
    }

    static fromJS(data: any): TournamentTeam {
        return new TournamentTeam(data);
    }

    toJS(data?: any) {
        data = data === undefined ? {} : data;
        if (this.participants && this.participants.constructor === Array) {
            data["Participants"] = [];
            for (let item of this.participants)
                data["Participants"].push(item.toJS());
        }
        super.toJS(data);
        return data; 
    }

    toJSON() {
        return JSON.stringify(this.toJS());
    }

    clone() {
        var json = this.toJSON();
        return new TournamentTeam(JSON.parse(json));
    }
}

export enum TournamentTeamStateAsInteger {
    Open = 0, 
    Active = 1, 
    InActive = 2, 
}

export class TournamentGroup { 
    id: string; 
    teams: TournamentTeamSummary[];

    constructor(data?: any) {
        if (data !== undefined) {
            this.id = data["Id"] !== undefined ? data["Id"] : null;
            if (data["Teams"] && data["Teams"].constructor === Array) {
                this.teams = [];
                for (let item of data["Teams"])
                    this.teams.push(TournamentTeamSummary.fromJS(item));
            }
        }
    }

    static fromJS(data: any): TournamentGroup {
        return new TournamentGroup(data);
    }

    toJS(data?: any) {
        data = data === undefined ? {} : data;
        data["Id"] = this.id !== undefined ? this.id : null;
        if (this.teams && this.teams.constructor === Array) {
            data["Teams"] = [];
            for (let item of this.teams)
                data["Teams"].push(item.toJS());
        }
        return data; 
    }

    toJSON() {
        return JSON.stringify(this.toJS());
    }

    clone() {
        var json = this.toJSON();
        return new TournamentGroup(JSON.parse(json));
    }
}

export class TournamentPairing { 
    teamA: TournamentTeamSummary; 
    teamB: TournamentTeamSummary; 
    teamAWon: number; 
    teamBWon: number; 
    numberOfGames: number; 
    phase: number; 
    order: number;

    constructor(data?: any) {
        if (data !== undefined) {
            this.teamA = data["TeamA"] ? TournamentTeamSummary.fromJS(data["TeamA"]) : null;
            this.teamB = data["TeamB"] ? TournamentTeamSummary.fromJS(data["TeamB"]) : null;
            this.teamAWon = data["TeamAWon"] !== undefined ? data["TeamAWon"] : null;
            this.teamBWon = data["TeamBWon"] !== undefined ? data["TeamBWon"] : null;
            this.numberOfGames = data["NumberOfGames"] !== undefined ? data["NumberOfGames"] : null;
            this.phase = data["Phase"] !== undefined ? data["Phase"] : null;
            this.order = data["Order"] !== undefined ? data["Order"] : null;
        }
    }

    static fromJS(data: any): TournamentPairing {
        return new TournamentPairing(data);
    }

    toJS(data?: any) {
        data = data === undefined ? {} : data;
        data["TeamA"] = this.teamA ? this.teamA.toJS() : null;
        data["TeamB"] = this.teamB ? this.teamB.toJS() : null;
        data["TeamAWon"] = this.teamAWon !== undefined ? this.teamAWon : null;
        data["TeamBWon"] = this.teamBWon !== undefined ? this.teamBWon : null;
        data["NumberOfGames"] = this.numberOfGames !== undefined ? this.numberOfGames : null;
        data["Phase"] = this.phase !== undefined ? this.phase : null;
        data["Order"] = this.order !== undefined ? this.order : null;
        return data; 
    }

    toJSON() {
        return JSON.stringify(this.toJS());
    }

    clone() {
        var json = this.toJSON();
        return new TournamentPairing(JSON.parse(json));
    }
}

export enum TournamentStateAsInteger {
    Open = 0, 
    Groups = 1, 
    Knockout = 2, 
    Closed = 3, 
}