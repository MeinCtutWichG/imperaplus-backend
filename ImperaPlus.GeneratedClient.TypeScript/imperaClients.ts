//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v3.26.6040.40944 (http://NSwag.org)
// </auto-generated>
//----------------------

export class AccountClient {
    baseUrl: string = undefined; 
    beforeSend: any = undefined; 

    constructor(baseUrl?: string) {
        this.baseUrl = baseUrl !== undefined ? baseUrl : ""; 
    }

    /**
     * Checks if a username is available
     * @userName Username to check
     * @return True if username is available
     */
    getUserNameAvailable(userName: string): Q.Promise<any> {
        return Q.Promise<any>((resolve, reject) => {
            this.getUserNameAvailableWithCallbacks(userName, (result) => resolve(result), (exception, reason) => reject(exception));
        });
    }
    
    private getUserNameAvailableWithCallbacks(userName: string, onSuccess?: (result: any) => void, onFail?: (exception: string, reason: string) => void) {
        var url = this.baseUrl + "/api/Account/UserNameAvailable?"; 

        if (userName === undefined)
            throw new Error("The parameter 'userName' must be defined.");
        else
            url += "userName=" + encodeURIComponent("" + userName) + "&"; 

        var content = "";

        jQuery.ajax({
            url: url,
            beforeSend: this.beforeSend,
            type: "get",
            data: content,
            dataType: "text",
            headers: {
                "Content-Type": "application/json; charset=UTF-8"
            }
        }).done((data, textStatus, xhr) => {
            this.processGetUserNameAvailableWithCallbacks(url, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processGetUserNameAvailableWithCallbacks(url, xhr, onSuccess, onFail);
        });
    }

    private processGetUserNameAvailableWithCallbacks(url: string, xhr: any, onSuccess?: any, onFail?: any) {
        try {
            var result = this.processGetUserNameAvailable(xhr);
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    private processGetUserNameAvailable(xhr: any) {
        var data = xhr.responseText; 
        var status = xhr.status.toString(); 

        if (status === "200") {
            var result200: any = null; 
            if (data !== undefined && data !== null && data !== "") {
                result200 = data;
            }
            return result200;
        }
        else
        {
            throw new Error("error_no_callback_for_the_received_http_status");
        }
    }

    /**
     * Get user information
     */
    getUserInfo(): Q.Promise<UserInfo> {
        return Q.Promise<UserInfo>((resolve, reject) => {
            this.getUserInfoWithCallbacks((result) => resolve(result), (exception, reason) => reject(exception));
        });
    }
    
    private getUserInfoWithCallbacks(onSuccess?: (result: UserInfo) => void, onFail?: (exception: string, reason: string) => void) {
        var url = this.baseUrl + "/api/Account/UserInfo?"; 

        var content = "";

        jQuery.ajax({
            url: url,
            beforeSend: this.beforeSend,
            type: "get",
            data: content,
            dataType: "text",
            headers: {
                "Content-Type": "application/json; charset=UTF-8"
            }
        }).done((data, textStatus, xhr) => {
            this.processGetUserInfoWithCallbacks(url, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processGetUserInfoWithCallbacks(url, xhr, onSuccess, onFail);
        });
    }

    private processGetUserInfoWithCallbacks(url: string, xhr: any, onSuccess?: any, onFail?: any) {
        try {
            var result = this.processGetUserInfo(xhr);
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    private processGetUserInfo(xhr: any) {
        var data = xhr.responseText; 
        var status = xhr.status.toString(); 

        if (status === "200") {
            var result200: UserInfo = null; 
            if (data !== undefined && data !== null && data !== "") {
                result200 = data === "" ? null : <UserInfo>jQuery.parseJSON(data);
            }
            return result200;
        }
        else
        {
            throw new Error("error_no_callback_for_the_received_http_status");
        }
    }

    /**
     * Get user information for an external user (i.e., just logged in using an external provider)
     */
    getExternalUserInfo(): Q.Promise<UserInfo> {
        return Q.Promise<UserInfo>((resolve, reject) => {
            this.getExternalUserInfoWithCallbacks((result) => resolve(result), (exception, reason) => reject(exception));
        });
    }
    
    private getExternalUserInfoWithCallbacks(onSuccess?: (result: UserInfo) => void, onFail?: (exception: string, reason: string) => void) {
        var url = this.baseUrl + "/api/Account/ExternalUserInfo?"; 

        var content = "";

        jQuery.ajax({
            url: url,
            beforeSend: this.beforeSend,
            type: "get",
            data: content,
            dataType: "text",
            headers: {
                "Content-Type": "application/json; charset=UTF-8"
            }
        }).done((data, textStatus, xhr) => {
            this.processGetExternalUserInfoWithCallbacks(url, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processGetExternalUserInfoWithCallbacks(url, xhr, onSuccess, onFail);
        });
    }

    private processGetExternalUserInfoWithCallbacks(url: string, xhr: any, onSuccess?: any, onFail?: any) {
        try {
            var result = this.processGetExternalUserInfo(xhr);
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    private processGetExternalUserInfo(xhr: any) {
        var data = xhr.responseText; 
        var status = xhr.status.toString(); 

        if (status === "200") {
            var result200: UserInfo = null; 
            if (data !== undefined && data !== null && data !== "") {
                result200 = data === "" ? null : <UserInfo>jQuery.parseJSON(data);
            }
            return result200;
        }
        else
        {
            throw new Error("error_no_callback_for_the_received_http_status");
        }
    }

    logout(): Q.Promise<any> {
        return Q.Promise<any>((resolve, reject) => {
            this.logoutWithCallbacks((result) => resolve(result), (exception, reason) => reject(exception));
        });
    }
    
    private logoutWithCallbacks(onSuccess?: (result: any) => void, onFail?: (exception: string, reason: string) => void) {
        var url = this.baseUrl + "/api/Account/Logout?"; 

        var content = "";

        jQuery.ajax({
            url: url,
            beforeSend: this.beforeSend,
            type: "post",
            data: content,
            dataType: "text",
            headers: {
                "Content-Type": "application/json; charset=UTF-8"
            }
        }).done((data, textStatus, xhr) => {
            this.processLogoutWithCallbacks(url, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processLogoutWithCallbacks(url, xhr, onSuccess, onFail);
        });
    }

    private processLogoutWithCallbacks(url: string, xhr: any, onSuccess?: any, onFail?: any) {
        try {
            var result = this.processLogout(xhr);
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    private processLogout(xhr: any) {
        var data = xhr.responseText; 
        var status = xhr.status.toString(); 

        if (status === "200") {
            var result200: any = null; 
            if (data !== undefined && data !== null && data !== "") {
                result200 = data;
            }
            return result200;
        }
        else
        {
            throw new Error("error_no_callback_for_the_received_http_status");
        }
    }

    getManageInfo(returnUrl: string, generateState: boolean): Q.Promise<ManageInfoViewModel> {
        return Q.Promise<ManageInfoViewModel>((resolve, reject) => {
            this.getManageInfoWithCallbacks(returnUrl, generateState, (result) => resolve(result), (exception, reason) => reject(exception));
        });
    }
    
    private getManageInfoWithCallbacks(returnUrl: string, generateState: boolean, onSuccess?: (result: ManageInfoViewModel) => void, onFail?: (exception: string, reason: string) => void) {
        var url = this.baseUrl + "/api/Account/ManageInfo?"; 

        if (returnUrl === undefined)
            throw new Error("The parameter 'returnUrl' must be defined.");
        else
            url += "returnUrl=" + encodeURIComponent("" + returnUrl) + "&"; 
        if (generateState === null)
            throw new Error("The parameter 'generateState' cannot be null.");
        else if (generateState !== undefined)
            url += "generateState=" + encodeURIComponent("" + generateState) + "&"; 

        var content = "";

        jQuery.ajax({
            url: url,
            beforeSend: this.beforeSend,
            type: "get",
            data: content,
            dataType: "text",
            headers: {
                "Content-Type": "application/json; charset=UTF-8"
            }
        }).done((data, textStatus, xhr) => {
            this.processGetManageInfoWithCallbacks(url, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processGetManageInfoWithCallbacks(url, xhr, onSuccess, onFail);
        });
    }

    private processGetManageInfoWithCallbacks(url: string, xhr: any, onSuccess?: any, onFail?: any) {
        try {
            var result = this.processGetManageInfo(xhr);
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    private processGetManageInfo(xhr: any) {
        var data = xhr.responseText; 
        var status = xhr.status.toString(); 

        if (status === "200") {
            var result200: ManageInfoViewModel = null; 
            if (data !== undefined && data !== null && data !== "") {
                result200 = data === "" ? null : <ManageInfoViewModel>jQuery.parseJSON(data);
            }
            return result200;
        }
        else
        {
            throw new Error("error_no_callback_for_the_received_http_status");
        }
    }

    changePassword(model: ChangePasswordBindingModel): Q.Promise<any> {
        return Q.Promise<any>((resolve, reject) => {
            this.changePasswordWithCallbacks(model, (result) => resolve(result), (exception, reason) => reject(exception));
        });
    }
    
    private changePasswordWithCallbacks(model: ChangePasswordBindingModel, onSuccess?: (result: any) => void, onFail?: (exception: string, reason: string) => void) {
        var url = this.baseUrl + "/api/Account/ChangePassword?"; 

        var content = JSON.stringify(model);

        jQuery.ajax({
            url: url,
            beforeSend: this.beforeSend,
            type: "post",
            data: content,
            dataType: "text",
            headers: {
                "Content-Type": "application/json; charset=UTF-8"
            }
        }).done((data, textStatus, xhr) => {
            this.processChangePasswordWithCallbacks(url, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processChangePasswordWithCallbacks(url, xhr, onSuccess, onFail);
        });
    }

    private processChangePasswordWithCallbacks(url: string, xhr: any, onSuccess?: any, onFail?: any) {
        try {
            var result = this.processChangePassword(xhr);
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    private processChangePassword(xhr: any) {
        var data = xhr.responseText; 
        var status = xhr.status.toString(); 

        if (status === "200") {
            var result200: any = null; 
            if (data !== undefined && data !== null && data !== "") {
                result200 = data;
            }
            return result200;
        }
        else
        {
            throw new Error("error_no_callback_for_the_received_http_status");
        }
    }

    setPassword(model: SetPasswordBindingModel): Q.Promise<any> {
        return Q.Promise<any>((resolve, reject) => {
            this.setPasswordWithCallbacks(model, (result) => resolve(result), (exception, reason) => reject(exception));
        });
    }
    
    private setPasswordWithCallbacks(model: SetPasswordBindingModel, onSuccess?: (result: any) => void, onFail?: (exception: string, reason: string) => void) {
        var url = this.baseUrl + "/api/Account/SetPassword?"; 

        var content = JSON.stringify(model);

        jQuery.ajax({
            url: url,
            beforeSend: this.beforeSend,
            type: "post",
            data: content,
            dataType: "text",
            headers: {
                "Content-Type": "application/json; charset=UTF-8"
            }
        }).done((data, textStatus, xhr) => {
            this.processSetPasswordWithCallbacks(url, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processSetPasswordWithCallbacks(url, xhr, onSuccess, onFail);
        });
    }

    private processSetPasswordWithCallbacks(url: string, xhr: any, onSuccess?: any, onFail?: any) {
        try {
            var result = this.processSetPassword(xhr);
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    private processSetPassword(xhr: any) {
        var data = xhr.responseText; 
        var status = xhr.status.toString(); 

        if (status === "200") {
            var result200: any = null; 
            if (data !== undefined && data !== null && data !== "") {
                result200 = data;
            }
            return result200;
        }
        else
        {
            throw new Error("error_no_callback_for_the_received_http_status");
        }
    }

    setLanguage(model: LanguageModel): Q.Promise<any> {
        return Q.Promise<any>((resolve, reject) => {
            this.setLanguageWithCallbacks(model, (result) => resolve(result), (exception, reason) => reject(exception));
        });
    }
    
    private setLanguageWithCallbacks(model: LanguageModel, onSuccess?: (result: any) => void, onFail?: (exception: string, reason: string) => void) {
        var url = this.baseUrl + "/api/Account/Language?"; 

        var content = JSON.stringify(model);

        jQuery.ajax({
            url: url,
            beforeSend: this.beforeSend,
            type: "post",
            data: content,
            dataType: "text",
            headers: {
                "Content-Type": "application/json; charset=UTF-8"
            }
        }).done((data, textStatus, xhr) => {
            this.processSetLanguageWithCallbacks(url, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processSetLanguageWithCallbacks(url, xhr, onSuccess, onFail);
        });
    }

    private processSetLanguageWithCallbacks(url: string, xhr: any, onSuccess?: any, onFail?: any) {
        try {
            var result = this.processSetLanguage(xhr);
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    private processSetLanguage(xhr: any) {
        var data = xhr.responseText; 
        var status = xhr.status.toString(); 

        if (status === "200") {
            var result200: any = null; 
            if (data !== undefined && data !== null && data !== "") {
                result200 = data;
            }
            return result200;
        }
        else
        {
            throw new Error("error_no_callback_for_the_received_http_status");
        }
    }

    addExternalLogin(model: AddExternalLoginBindingModel): Q.Promise<any> {
        return Q.Promise<any>((resolve, reject) => {
            this.addExternalLoginWithCallbacks(model, (result) => resolve(result), (exception, reason) => reject(exception));
        });
    }
    
    private addExternalLoginWithCallbacks(model: AddExternalLoginBindingModel, onSuccess?: (result: any) => void, onFail?: (exception: string, reason: string) => void) {
        var url = this.baseUrl + "/api/Account/AddExternalLogin?"; 

        var content = JSON.stringify(model);

        jQuery.ajax({
            url: url,
            beforeSend: this.beforeSend,
            type: "post",
            data: content,
            dataType: "text",
            headers: {
                "Content-Type": "application/json; charset=UTF-8"
            }
        }).done((data, textStatus, xhr) => {
            this.processAddExternalLoginWithCallbacks(url, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processAddExternalLoginWithCallbacks(url, xhr, onSuccess, onFail);
        });
    }

    private processAddExternalLoginWithCallbacks(url: string, xhr: any, onSuccess?: any, onFail?: any) {
        try {
            var result = this.processAddExternalLogin(xhr);
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    private processAddExternalLogin(xhr: any) {
        var data = xhr.responseText; 
        var status = xhr.status.toString(); 

        if (status === "200") {
            var result200: any = null; 
            if (data !== undefined && data !== null && data !== "") {
                result200 = data;
            }
            return result200;
        }
        else
        {
            throw new Error("error_no_callback_for_the_received_http_status");
        }
    }

    removeLogin(model: RemoveLoginBindingModel): Q.Promise<any> {
        return Q.Promise<any>((resolve, reject) => {
            this.removeLoginWithCallbacks(model, (result) => resolve(result), (exception, reason) => reject(exception));
        });
    }
    
    private removeLoginWithCallbacks(model: RemoveLoginBindingModel, onSuccess?: (result: any) => void, onFail?: (exception: string, reason: string) => void) {
        var url = this.baseUrl + "/api/Account/RemoveLogin?"; 

        var content = JSON.stringify(model);

        jQuery.ajax({
            url: url,
            beforeSend: this.beforeSend,
            type: "post",
            data: content,
            dataType: "text",
            headers: {
                "Content-Type": "application/json; charset=UTF-8"
            }
        }).done((data, textStatus, xhr) => {
            this.processRemoveLoginWithCallbacks(url, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processRemoveLoginWithCallbacks(url, xhr, onSuccess, onFail);
        });
    }

    private processRemoveLoginWithCallbacks(url: string, xhr: any, onSuccess?: any, onFail?: any) {
        try {
            var result = this.processRemoveLogin(xhr);
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    private processRemoveLogin(xhr: any) {
        var data = xhr.responseText; 
        var status = xhr.status.toString(); 

        if (status === "200") {
            var result200: any = null; 
            if (data !== undefined && data !== null && data !== "") {
                result200 = data;
            }
            return result200;
        }
        else
        {
            throw new Error("error_no_callback_for_the_received_http_status");
        }
    }

    getExternalLogin(provider: string): Q.Promise<any> {
        return Q.Promise<any>((resolve, reject) => {
            this.getExternalLoginWithCallbacks(provider, (result) => resolve(result), (exception, reason) => reject(exception));
        });
    }
    
    private getExternalLoginWithCallbacks(provider: string, onSuccess?: (result: any) => void, onFail?: (exception: string, reason: string) => void) {
        var url = this.baseUrl + "/api/Account/ExternalLogin?"; 

        if (provider === undefined)
            throw new Error("The parameter 'provider' must be defined.");
        else
            url += "provider=" + encodeURIComponent("" + provider) + "&"; 

        var content = "";

        jQuery.ajax({
            url: url,
            beforeSend: this.beforeSend,
            type: "get",
            data: content,
            dataType: "text",
            headers: {
                "Content-Type": "application/json; charset=UTF-8"
            }
        }).done((data, textStatus, xhr) => {
            this.processGetExternalLoginWithCallbacks(url, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processGetExternalLoginWithCallbacks(url, xhr, onSuccess, onFail);
        });
    }

    private processGetExternalLoginWithCallbacks(url: string, xhr: any, onSuccess?: any, onFail?: any) {
        try {
            var result = this.processGetExternalLogin(xhr);
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    private processGetExternalLogin(xhr: any) {
        var data = xhr.responseText; 
        var status = xhr.status.toString(); 

        if (status === "200") {
            var result200: any = null; 
            if (data !== undefined && data !== null && data !== "") {
                result200 = data;
            }
            return result200;
        }
        else
        {
            throw new Error("error_no_callback_for_the_received_http_status");
        }
    }

    getExternalLogins(returnUrl: string, generateState: boolean): Q.Promise<ExternalLoginViewModel[]> {
        return Q.Promise<ExternalLoginViewModel[]>((resolve, reject) => {
            this.getExternalLoginsWithCallbacks(returnUrl, generateState, (result) => resolve(result), (exception, reason) => reject(exception));
        });
    }
    
    private getExternalLoginsWithCallbacks(returnUrl: string, generateState: boolean, onSuccess?: (result: ExternalLoginViewModel[]) => void, onFail?: (exception: string, reason: string) => void) {
        var url = this.baseUrl + "/api/Account/ExternalLogins?"; 

        if (returnUrl === undefined)
            throw new Error("The parameter 'returnUrl' must be defined.");
        else
            url += "returnUrl=" + encodeURIComponent("" + returnUrl) + "&"; 
        if (generateState === null)
            throw new Error("The parameter 'generateState' cannot be null.");
        else if (generateState !== undefined)
            url += "generateState=" + encodeURIComponent("" + generateState) + "&"; 

        var content = "";

        jQuery.ajax({
            url: url,
            beforeSend: this.beforeSend,
            type: "get",
            data: content,
            dataType: "text",
            headers: {
                "Content-Type": "application/json; charset=UTF-8"
            }
        }).done((data, textStatus, xhr) => {
            this.processGetExternalLoginsWithCallbacks(url, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processGetExternalLoginsWithCallbacks(url, xhr, onSuccess, onFail);
        });
    }

    private processGetExternalLoginsWithCallbacks(url: string, xhr: any, onSuccess?: any, onFail?: any) {
        try {
            var result = this.processGetExternalLogins(xhr);
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    private processGetExternalLogins(xhr: any) {
        var data = xhr.responseText; 
        var status = xhr.status.toString(); 

        if (status === "200") {
            var result200: ExternalLoginViewModel[] = null; 
            if (data !== undefined && data !== null && data !== "") {
                result200 = data === "" ? null : <ExternalLoginViewModel[]>jQuery.parseJSON(data);
            }
            return result200;
        }
        else
        {
            throw new Error("error_no_callback_for_the_received_http_status");
        }
    }

    register(model: RegisterBindingModel): Q.Promise<any> {
        return Q.Promise<any>((resolve, reject) => {
            this.registerWithCallbacks(model, (result) => resolve(result), (exception, reason) => reject(exception));
        });
    }
    
    private registerWithCallbacks(model: RegisterBindingModel, onSuccess?: (result: any) => void, onFail?: (exception: string, reason: string) => void) {
        var url = this.baseUrl + "/api/Account/Register?"; 

        var content = JSON.stringify(model);

        jQuery.ajax({
            url: url,
            beforeSend: this.beforeSend,
            type: "post",
            data: content,
            dataType: "text",
            headers: {
                "Content-Type": "application/json; charset=UTF-8"
            }
        }).done((data, textStatus, xhr) => {
            this.processRegisterWithCallbacks(url, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processRegisterWithCallbacks(url, xhr, onSuccess, onFail);
        });
    }

    private processRegisterWithCallbacks(url: string, xhr: any, onSuccess?: any, onFail?: any) {
        try {
            var result = this.processRegister(xhr);
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    private processRegister(xhr: any) {
        var data = xhr.responseText; 
        var status = xhr.status.toString(); 

        if (status === "200") {
            var result200: any = null; 
            if (data !== undefined && data !== null && data !== "") {
                result200 = data;
            }
            return result200;
        }
        else
        {
            throw new Error("error_no_callback_for_the_received_http_status");
        }
    }

    /**
     * Resend the email confirmation account to the given user account
     * @model (optional) 
     */
    resendConfirmationCode(model: ResendConfirmationModel): Q.Promise<any> {
        return Q.Promise<any>((resolve, reject) => {
            this.resendConfirmationCodeWithCallbacks(model, (result) => resolve(result), (exception, reason) => reject(exception));
        });
    }
    
    private resendConfirmationCodeWithCallbacks(model: ResendConfirmationModel, onSuccess?: (result: any) => void, onFail?: (exception: string, reason: string) => void) {
        var url = this.baseUrl + "/api/Account/ResendConfirmation?"; 

        var content = JSON.stringify(model);

        jQuery.ajax({
            url: url,
            beforeSend: this.beforeSend,
            type: "post",
            data: content,
            dataType: "text",
            headers: {
                "Content-Type": "application/json; charset=UTF-8"
            }
        }).done((data, textStatus, xhr) => {
            this.processResendConfirmationCodeWithCallbacks(url, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processResendConfirmationCodeWithCallbacks(url, xhr, onSuccess, onFail);
        });
    }

    private processResendConfirmationCodeWithCallbacks(url: string, xhr: any, onSuccess?: any, onFail?: any) {
        try {
            var result = this.processResendConfirmationCode(xhr);
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    private processResendConfirmationCode(xhr: any) {
        var data = xhr.responseText; 
        var status = xhr.status.toString(); 

        if (status === "200") {
            var result200: any = null; 
            if (data !== undefined && data !== null && data !== "") {
                result200 = data;
            }
            return result200;
        }
        else
        {
            throw new Error("error_no_callback_for_the_received_http_status");
        }
    }

    /**
     * Confirm user account using code provided in mail
     * @model (optional) Model containing id and code
     * @return Success if successfully activated
     */
    confirmEmail(model: ConfirmationModel): Q.Promise<any> {
        return Q.Promise<any>((resolve, reject) => {
            this.confirmEmailWithCallbacks(model, (result) => resolve(result), (exception, reason) => reject(exception));
        });
    }
    
    private confirmEmailWithCallbacks(model: ConfirmationModel, onSuccess?: (result: any) => void, onFail?: (exception: string, reason: string) => void) {
        var url = this.baseUrl + "/api/Account/ConfirmEmail?"; 

        var content = JSON.stringify(model);

        jQuery.ajax({
            url: url,
            beforeSend: this.beforeSend,
            type: "post",
            data: content,
            dataType: "text",
            headers: {
                "Content-Type": "application/json; charset=UTF-8"
            }
        }).done((data, textStatus, xhr) => {
            this.processConfirmEmailWithCallbacks(url, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processConfirmEmailWithCallbacks(url, xhr, onSuccess, onFail);
        });
    }

    private processConfirmEmailWithCallbacks(url: string, xhr: any, onSuccess?: any, onFail?: any) {
        try {
            var result = this.processConfirmEmail(xhr);
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    private processConfirmEmail(xhr: any) {
        var data = xhr.responseText; 
        var status = xhr.status.toString(); 

        if (status === "200") {
            var result200: any = null; 
            if (data !== undefined && data !== null && data !== "") {
                result200 = data;
            }
            return result200;
        }
        else
        {
            throw new Error("error_no_callback_for_the_received_http_status");
        }
    }

    /**
     * Request password reset link
     * @model (optional) 
     */
    forgotPassword(model: ForgotPasswordViewModel): Q.Promise<any> {
        return Q.Promise<any>((resolve, reject) => {
            this.forgotPasswordWithCallbacks(model, (result) => resolve(result), (exception, reason) => reject(exception));
        });
    }
    
    private forgotPasswordWithCallbacks(model: ForgotPasswordViewModel, onSuccess?: (result: any) => void, onFail?: (exception: string, reason: string) => void) {
        var url = this.baseUrl + "/api/Account/ForgotPassword?"; 

        var content = JSON.stringify(model);

        jQuery.ajax({
            url: url,
            beforeSend: this.beforeSend,
            type: "post",
            data: content,
            dataType: "text",
            headers: {
                "Content-Type": "application/json; charset=UTF-8"
            }
        }).done((data, textStatus, xhr) => {
            this.processForgotPasswordWithCallbacks(url, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processForgotPasswordWithCallbacks(url, xhr, onSuccess, onFail);
        });
    }

    private processForgotPasswordWithCallbacks(url: string, xhr: any, onSuccess?: any, onFail?: any) {
        try {
            var result = this.processForgotPassword(xhr);
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    private processForgotPassword(xhr: any) {
        var data = xhr.responseText; 
        var status = xhr.status.toString(); 

        if (status === "200") {
            var result200: any = null; 
            if (data !== undefined && data !== null && data !== "") {
                result200 = data;
            }
            return result200;
        }
        else
        {
            throw new Error("error_no_callback_for_the_received_http_status");
        }
    }

    /**
     * Reset password confirmation
     * @model (optional) 
     */
    resetPassword(model: ResetPasswordViewModel): Q.Promise<any> {
        return Q.Promise<any>((resolve, reject) => {
            this.resetPasswordWithCallbacks(model, (result) => resolve(result), (exception, reason) => reject(exception));
        });
    }
    
    private resetPasswordWithCallbacks(model: ResetPasswordViewModel, onSuccess?: (result: any) => void, onFail?: (exception: string, reason: string) => void) {
        var url = this.baseUrl + "/api/Account/ResetPassword?"; 

        var content = JSON.stringify(model);

        jQuery.ajax({
            url: url,
            beforeSend: this.beforeSend,
            type: "post",
            data: content,
            dataType: "text",
            headers: {
                "Content-Type": "application/json; charset=UTF-8"
            }
        }).done((data, textStatus, xhr) => {
            this.processResetPasswordWithCallbacks(url, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processResetPasswordWithCallbacks(url, xhr, onSuccess, onFail);
        });
    }

    private processResetPasswordWithCallbacks(url: string, xhr: any, onSuccess?: any, onFail?: any) {
        try {
            var result = this.processResetPassword(xhr);
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    private processResetPassword(xhr: any) {
        var data = xhr.responseText; 
        var status = xhr.status.toString(); 

        if (status === "200") {
            var result200: any = null; 
            if (data !== undefined && data !== null && data !== "") {
                result200 = data;
            }
            return result200;
        }
        else
        {
            throw new Error("error_no_callback_for_the_received_http_status");
        }
    }

    /**
     * Create user accout for an external login
     * @model (optional) 
     */
    registerExternal(model: RegisterExternalBindingModel): Q.Promise<any> {
        return Q.Promise<any>((resolve, reject) => {
            this.registerExternalWithCallbacks(model, (result) => resolve(result), (exception, reason) => reject(exception));
        });
    }
    
    private registerExternalWithCallbacks(model: RegisterExternalBindingModel, onSuccess?: (result: any) => void, onFail?: (exception: string, reason: string) => void) {
        var url = this.baseUrl + "/api/Account/RegisterExternal?"; 

        var content = JSON.stringify(model);

        jQuery.ajax({
            url: url,
            beforeSend: this.beforeSend,
            type: "post",
            data: content,
            dataType: "text",
            headers: {
                "Content-Type": "application/json; charset=UTF-8"
            }
        }).done((data, textStatus, xhr) => {
            this.processRegisterExternalWithCallbacks(url, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processRegisterExternalWithCallbacks(url, xhr, onSuccess, onFail);
        });
    }

    private processRegisterExternalWithCallbacks(url: string, xhr: any, onSuccess?: any, onFail?: any) {
        try {
            var result = this.processRegisterExternal(xhr);
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    private processRegisterExternal(xhr: any) {
        var data = xhr.responseText; 
        var status = xhr.status.toString(); 

        if (status === "200") {
            var result200: any = null; 
            if (data !== undefined && data !== null && data !== "") {
                result200 = data;
            }
            return result200;
        }
        else
        {
            throw new Error("error_no_callback_for_the_received_http_status");
        }
    }
}

export class HistoryClient {
    baseUrl: string = undefined; 
    beforeSend: any = undefined; 

    constructor(baseUrl?: string) {
        this.baseUrl = baseUrl !== undefined ? baseUrl : ""; 
    }

    /**
     * Gets the specified turn including the actions and current state of the map
     */
    getTurn(gameId: number, turnId: number): Q.Promise<HistoryTurn> {
        return Q.Promise<HistoryTurn>((resolve, reject) => {
            this.getTurnWithCallbacks(gameId, turnId, (result) => resolve(result), (exception, reason) => reject(exception));
        });
    }
    
    private getTurnWithCallbacks(gameId: number, turnId: number, onSuccess?: (result: HistoryTurn) => void, onFail?: (exception: string, reason: string) => void) {
        var url = this.baseUrl + "/api/games/{gameId:long:min(1)}/history/{turnId:long:min(1)}?"; 

        if (gameId === undefined || gameId === null)
            throw new Error("The parameter 'gameId' must be defined.");
        url = url.replace("{gameId}", encodeURIComponent("" + gameId)); 
        if (turnId === undefined || turnId === null)
            throw new Error("The parameter 'turnId' must be defined.");
        url = url.replace("{turnId}", encodeURIComponent("" + turnId)); 

        var content = "";

        jQuery.ajax({
            url: url,
            beforeSend: this.beforeSend,
            type: "get",
            data: content,
            dataType: "text",
            headers: {
                "Content-Type": "application/json; charset=UTF-8"
            }
        }).done((data, textStatus, xhr) => {
            this.processGetTurnWithCallbacks(url, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processGetTurnWithCallbacks(url, xhr, onSuccess, onFail);
        });
    }

    private processGetTurnWithCallbacks(url: string, xhr: any, onSuccess?: any, onFail?: any) {
        try {
            var result = this.processGetTurn(xhr);
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    private processGetTurn(xhr: any) {
        var data = xhr.responseText; 
        var status = xhr.status.toString(); 

        if (status === "200") {
            var result200: HistoryTurn = null; 
            if (data !== undefined && data !== null && data !== "") {
                result200 = data === "" ? null : <HistoryTurn>jQuery.parseJSON(data);
            }
            return result200;
        }
        else
        {
            throw new Error("error_no_callback_for_the_received_http_status");
        }
    }
}

export class LadderClient {
    baseUrl: string = undefined; 
    beforeSend: any = undefined; 

    constructor(baseUrl?: string) {
        this.baseUrl = baseUrl !== undefined ? baseUrl : ""; 
    }

    /**
     * Returns active ladders
     * @return List of ladders
     */
    getAll(): Q.Promise<LadderSummary[]> {
        return Q.Promise<LadderSummary[]>((resolve, reject) => {
            this.getAllWithCallbacks((result) => resolve(result), (exception, reason) => reject(exception));
        });
    }
    
    private getAllWithCallbacks(onSuccess?: (result: LadderSummary[]) => void, onFail?: (exception: string, reason: string) => void) {
        var url = this.baseUrl + "/api/ladder?"; 

        var content = "";

        jQuery.ajax({
            url: url,
            beforeSend: this.beforeSend,
            type: "get",
            data: content,
            dataType: "text",
            headers: {
                "Content-Type": "application/json; charset=UTF-8"
            }
        }).done((data, textStatus, xhr) => {
            this.processGetAllWithCallbacks(url, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processGetAllWithCallbacks(url, xhr, onSuccess, onFail);
        });
    }

    private processGetAllWithCallbacks(url: string, xhr: any, onSuccess?: any, onFail?: any) {
        try {
            var result = this.processGetAll(xhr);
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    private processGetAll(xhr: any) {
        var data = xhr.responseText; 
        var status = xhr.status.toString(); 

        if (status === "200") {
            var result200: LadderSummary[] = null; 
            if (data !== undefined && data !== null && data !== "") {
                result200 = data === "" ? null : <LadderSummary[]>jQuery.parseJSON(data);
            }
            return result200;
        }
        else
        {
            throw new Error("error_no_callback_for_the_received_http_status");
        }
    }

    /**
     * Gets ladder identified by given id
     * @ladderId Id of ladder
     */
    get(ladderId: string): Q.Promise<Ladder> {
        return Q.Promise<Ladder>((resolve, reject) => {
            this.getWithCallbacks(ladderId, (result) => resolve(result), (exception, reason) => reject(exception));
        });
    }
    
    private getWithCallbacks(ladderId: string, onSuccess?: (result: Ladder) => void, onFail?: (exception: string, reason: string) => void) {
        var url = this.baseUrl + "/api/ladder/{ladderId:guid}?"; 

        if (ladderId === undefined || ladderId === null)
            throw new Error("The parameter 'ladderId' must be defined.");
        url = url.replace("{ladderId}", encodeURIComponent("" + ladderId)); 

        var content = "";

        jQuery.ajax({
            url: url,
            beforeSend: this.beforeSend,
            type: "get",
            data: content,
            dataType: "text",
            headers: {
                "Content-Type": "application/json; charset=UTF-8"
            }
        }).done((data, textStatus, xhr) => {
            this.processGetWithCallbacks(url, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processGetWithCallbacks(url, xhr, onSuccess, onFail);
        });
    }

    private processGetWithCallbacks(url: string, xhr: any, onSuccess?: any, onFail?: any) {
        try {
            var result = this.processGet(xhr);
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    private processGet(xhr: any) {
        var data = xhr.responseText; 
        var status = xhr.status.toString(); 

        if (status === "200") {
            var result200: Ladder = null; 
            if (data !== undefined && data !== null && data !== "") {
                result200 = data === "" ? null : <Ladder>jQuery.parseJSON(data);
            }
            return result200;
        }
        else
        {
            throw new Error("error_no_callback_for_the_received_http_status");
        }
    }

    /**
     * Queue up for a new game in the given ladder
     * @ladderId Ladder id
     * @return Status
     */
    postJoin(ladderId: string): Q.Promise<any> {
        return Q.Promise<any>((resolve, reject) => {
            this.postJoinWithCallbacks(ladderId, (result) => resolve(result), (exception, reason) => reject(exception));
        });
    }
    
    private postJoinWithCallbacks(ladderId: string, onSuccess?: (result: any) => void, onFail?: (exception: string, reason: string) => void) {
        var url = this.baseUrl + "/api/ladder/{ladderId:guid}/queue?"; 

        if (ladderId === undefined || ladderId === null)
            throw new Error("The parameter 'ladderId' must be defined.");
        url = url.replace("{ladderId}", encodeURIComponent("" + ladderId)); 

        var content = "";

        jQuery.ajax({
            url: url,
            beforeSend: this.beforeSend,
            type: "post",
            data: content,
            dataType: "text",
            headers: {
                "Content-Type": "application/json; charset=UTF-8"
            }
        }).done((data, textStatus, xhr) => {
            this.processPostJoinWithCallbacks(url, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processPostJoinWithCallbacks(url, xhr, onSuccess, onFail);
        });
    }

    private processPostJoinWithCallbacks(url: string, xhr: any, onSuccess?: any, onFail?: any) {
        try {
            var result = this.processPostJoin(xhr);
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    private processPostJoin(xhr: any) {
        var data = xhr.responseText; 
        var status = xhr.status.toString(); 

        if (status === "200") {
            var result200: any = null; 
            if (data !== undefined && data !== null && data !== "") {
                result200 = data;
            }
            return result200;
        }
        else
        {
            throw new Error("error_no_callback_for_the_received_http_status");
        }
    }

    /**
     * Gets ladder standings
     * @ladderId Id of ladder
     * @start (optional) Items to skip before returning
     * @count (optional) Count of standings to return
     */
    getStandings(ladderId: string, start: number, count: number): Q.Promise<LadderStanding[]> {
        return Q.Promise<LadderStanding[]>((resolve, reject) => {
            this.getStandingsWithCallbacks(ladderId, start, count, (result) => resolve(result), (exception, reason) => reject(exception));
        });
    }
    
    private getStandingsWithCallbacks(ladderId: string, start: number, count: number, onSuccess?: (result: LadderStanding[]) => void, onFail?: (exception: string, reason: string) => void) {
        var url = this.baseUrl + "/api/ladder/{ladderId:guid}/standings?"; 

        if (ladderId === undefined || ladderId === null)
            throw new Error("The parameter 'ladderId' must be defined.");
        url = url.replace("{ladderId}", encodeURIComponent("" + ladderId)); 

        if (start === null)
            throw new Error("The parameter 'start' cannot be null.");
        else if (start !== undefined)
            url += "start=" + encodeURIComponent("" + start) + "&"; 
        if (count === null)
            throw new Error("The parameter 'count' cannot be null.");
        else if (count !== undefined)
            url += "count=" + encodeURIComponent("" + count) + "&"; 

        var content = "";

        jQuery.ajax({
            url: url,
            beforeSend: this.beforeSend,
            type: "get",
            data: content,
            dataType: "text",
            headers: {
                "Content-Type": "application/json; charset=UTF-8"
            }
        }).done((data, textStatus, xhr) => {
            this.processGetStandingsWithCallbacks(url, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processGetStandingsWithCallbacks(url, xhr, onSuccess, onFail);
        });
    }

    private processGetStandingsWithCallbacks(url: string, xhr: any, onSuccess?: any, onFail?: any) {
        try {
            var result = this.processGetStandings(xhr);
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    private processGetStandings(xhr: any) {
        var data = xhr.responseText; 
        var status = xhr.status.toString(); 

        if (status === "200") {
            var result200: LadderStanding[] = null; 
            if (data !== undefined && data !== null && data !== "") {
                result200 = data === "" ? null : <LadderStanding[]>jQuery.parseJSON(data);
            }
            return result200;
        }
        else
        {
            throw new Error("error_no_callback_for_the_received_http_status");
        }
    }
}

export class MapClient {
    baseUrl: string = undefined; 
    beforeSend: any = undefined; 

    constructor(baseUrl?: string) {
        this.baseUrl = baseUrl !== undefined ? baseUrl : ""; 
    }

    getAllSummary(): Q.Promise<MapTemplateSummary[]> {
        return Q.Promise<MapTemplateSummary[]>((resolve, reject) => {
            this.getAllSummaryWithCallbacks((result) => resolve(result), (exception, reason) => reject(exception));
        });
    }
    
    private getAllSummaryWithCallbacks(onSuccess?: (result: MapTemplateSummary[]) => void, onFail?: (exception: string, reason: string) => void) {
        var url = this.baseUrl + "/api/map?"; 

        var content = "";

        jQuery.ajax({
            url: url,
            beforeSend: this.beforeSend,
            type: "get",
            data: content,
            dataType: "text",
            headers: {
                "Content-Type": "application/json; charset=UTF-8"
            }
        }).done((data, textStatus, xhr) => {
            this.processGetAllSummaryWithCallbacks(url, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processGetAllSummaryWithCallbacks(url, xhr, onSuccess, onFail);
        });
    }

    private processGetAllSummaryWithCallbacks(url: string, xhr: any, onSuccess?: any, onFail?: any) {
        try {
            var result = this.processGetAllSummary(xhr);
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    private processGetAllSummary(xhr: any) {
        var data = xhr.responseText; 
        var status = xhr.status.toString(); 

        if (status === "200") {
            var result200: MapTemplateSummary[] = null; 
            if (data !== undefined && data !== null && data !== "") {
                result200 = data === "" ? null : <MapTemplateSummary[]>jQuery.parseJSON(data);
            }
            return result200;
        }
        else
        {
            throw new Error("error_no_callback_for_the_received_http_status");
        }
    }

    /**
     * Get map template identified by name
     */
    getMapTemplate(name: string): Q.Promise<MapTemplate> {
        return Q.Promise<MapTemplate>((resolve, reject) => {
            this.getMapTemplateWithCallbacks(name, (result) => resolve(result), (exception, reason) => reject(exception));
        });
    }
    
    private getMapTemplateWithCallbacks(name: string, onSuccess?: (result: MapTemplate) => void, onFail?: (exception: string, reason: string) => void) {
        var url = this.baseUrl + "/api/map/{name:minlength(1)}?"; 

        if (name === undefined || name === null)
            throw new Error("The parameter 'name' must be defined.");
        url = url.replace("{name}", encodeURIComponent("" + name)); 

        var content = "";

        jQuery.ajax({
            url: url,
            beforeSend: this.beforeSend,
            type: "get",
            data: content,
            dataType: "text",
            headers: {
                "Content-Type": "application/json; charset=UTF-8"
            }
        }).done((data, textStatus, xhr) => {
            this.processGetMapTemplateWithCallbacks(url, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processGetMapTemplateWithCallbacks(url, xhr, onSuccess, onFail);
        });
    }

    private processGetMapTemplateWithCallbacks(url: string, xhr: any, onSuccess?: any, onFail?: any) {
        try {
            var result = this.processGetMapTemplate(xhr);
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    private processGetMapTemplate(xhr: any) {
        var data = xhr.responseText; 
        var status = xhr.status.toString(); 

        if (status === "200") {
            var result200: MapTemplate = null; 
            if (data !== undefined && data !== null && data !== "") {
                result200 = data === "" ? null : <MapTemplate>jQuery.parseJSON(data);
            }
            return result200;
        }
        else
        {
            throw new Error("error_no_callback_for_the_received_http_status");
        }
    }
}

export class GameClient {
    baseUrl: string = undefined; 
    beforeSend: any = undefined; 

    constructor(baseUrl?: string) {
        this.baseUrl = baseUrl !== undefined ? baseUrl : ""; 
    }

    /**
     * Get a list of open games, excluding games by the current player
     * @return List of games
     */
    getAll(): Q.Promise<GameSummary[]> {
        return Q.Promise<GameSummary[]>((resolve, reject) => {
            this.getAllWithCallbacks((result) => resolve(result), (exception, reason) => reject(exception));
        });
    }
    
    private getAllWithCallbacks(onSuccess?: (result: GameSummary[]) => void, onFail?: (exception: string, reason: string) => void) {
        var url = this.baseUrl + "/api/games/open?"; 

        var content = "";

        jQuery.ajax({
            url: url,
            beforeSend: this.beforeSend,
            type: "get",
            data: content,
            dataType: "text",
            headers: {
                "Content-Type": "application/json; charset=UTF-8"
            }
        }).done((data, textStatus, xhr) => {
            this.processGetAllWithCallbacks(url, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processGetAllWithCallbacks(url, xhr, onSuccess, onFail);
        });
    }

    private processGetAllWithCallbacks(url: string, xhr: any, onSuccess?: any, onFail?: any) {
        try {
            var result = this.processGetAll(xhr);
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    private processGetAll(xhr: any) {
        var data = xhr.responseText; 
        var status = xhr.status.toString(); 

        if (status === "200") {
            var result200: GameSummary[] = null; 
            if (data !== undefined && data !== null && data !== "") {
                result200 = data === "" ? null : <GameSummary[]>jQuery.parseJSON(data);
            }
            return result200;
        }
        else
        {
            throw new Error("error_no_callback_for_the_received_http_status");
        }
    }

    /**
     * Get a list of the games for the current player
     * @return List of games for the current user
     */
    getMy(): Q.Promise<GameSummary[]> {
        return Q.Promise<GameSummary[]>((resolve, reject) => {
            this.getMyWithCallbacks((result) => resolve(result), (exception, reason) => reject(exception));
        });
    }
    
    private getMyWithCallbacks(onSuccess?: (result: GameSummary[]) => void, onFail?: (exception: string, reason: string) => void) {
        var url = this.baseUrl + "/api/games/my?"; 

        var content = "";

        jQuery.ajax({
            url: url,
            beforeSend: this.beforeSend,
            type: "get",
            data: content,
            dataType: "text",
            headers: {
                "Content-Type": "application/json; charset=UTF-8"
            }
        }).done((data, textStatus, xhr) => {
            this.processGetMyWithCallbacks(url, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processGetMyWithCallbacks(url, xhr, onSuccess, onFail);
        });
    }

    private processGetMyWithCallbacks(url: string, xhr: any, onSuccess?: any, onFail?: any) {
        try {
            var result = this.processGetMy(xhr);
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    private processGetMy(xhr: any) {
        var data = xhr.responseText; 
        var status = xhr.status.toString(); 

        if (status === "200") {
            var result200: GameSummary[] = null; 
            if (data !== undefined && data !== null && data !== "") {
                result200 = data === "" ? null : <GameSummary[]>jQuery.parseJSON(data);
            }
            return result200;
        }
        else
        {
            throw new Error("error_no_callback_for_the_received_http_status");
        }
    }

    /**
     * Get list of games where it's the current player's team
     * @return List of games where it's the current user's team
     */
    getMyTurn(): Q.Promise<GameSummary[]> {
        return Q.Promise<GameSummary[]>((resolve, reject) => {
            this.getMyTurnWithCallbacks((result) => resolve(result), (exception, reason) => reject(exception));
        });
    }
    
    private getMyTurnWithCallbacks(onSuccess?: (result: GameSummary[]) => void, onFail?: (exception: string, reason: string) => void) {
        var url = this.baseUrl + "/api/games/myturn?"; 

        var content = "";

        jQuery.ajax({
            url: url,
            beforeSend: this.beforeSend,
            type: "get",
            data: content,
            dataType: "text",
            headers: {
                "Content-Type": "application/json; charset=UTF-8"
            }
        }).done((data, textStatus, xhr) => {
            this.processGetMyTurnWithCallbacks(url, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processGetMyTurnWithCallbacks(url, xhr, onSuccess, onFail);
        });
    }

    private processGetMyTurnWithCallbacks(url: string, xhr: any, onSuccess?: any, onFail?: any) {
        try {
            var result = this.processGetMyTurn(xhr);
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    private processGetMyTurn(xhr: any) {
        var data = xhr.responseText; 
        var status = xhr.status.toString(); 

        if (status === "200") {
            var result200: GameSummary[] = null; 
            if (data !== undefined && data !== null && data !== "") {
                result200 = data === "" ? null : <GameSummary[]>jQuery.parseJSON(data);
            }
            return result200;
        }
        else
        {
            throw new Error("error_no_callback_for_the_received_http_status");
        }
    }

    /**
     * Create a new game
     * @creationOptions (optional) Creation options
     * @return Summary of newly created game
     */
    post(creationOptions: GameCreationOptions): Q.Promise<GameSummary> {
        return Q.Promise<GameSummary>((resolve, reject) => {
            this.postWithCallbacks(creationOptions, (result) => resolve(result), (exception, reason) => reject(exception));
        });
    }
    
    private postWithCallbacks(creationOptions: GameCreationOptions, onSuccess?: (result: GameSummary) => void, onFail?: (exception: string, reason: string) => void) {
        var url = this.baseUrl + "/api/games?"; 

        var content = JSON.stringify(creationOptions);

        jQuery.ajax({
            url: url,
            beforeSend: this.beforeSend,
            type: "post",
            data: content,
            dataType: "text",
            headers: {
                "Content-Type": "application/json; charset=UTF-8"
            }
        }).done((data, textStatus, xhr) => {
            this.processPostWithCallbacks(url, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processPostWithCallbacks(url, xhr, onSuccess, onFail);
        });
    }

    private processPostWithCallbacks(url: string, xhr: any, onSuccess?: any, onFail?: any) {
        try {
            var result = this.processPost(xhr);
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    private processPost(xhr: any) {
        var data = xhr.responseText; 
        var status = xhr.status.toString(); 

        if (status === "200") {
            var result200: GameSummary = null; 
            if (data !== undefined && data !== null && data !== "") {
                result200 = data === "" ? null : <GameSummary>jQuery.parseJSON(data);
            }
            return result200;
        }
        else
        {
            throw new Error("error_no_callback_for_the_received_http_status");
        }
    }

    /**
     * Get detailed information about a single game
     * @gameId Id of the requested game
     * @return Information about the requested game
     */
    get(gameId: number): Q.Promise<Game> {
        return Q.Promise<Game>((resolve, reject) => {
            this.getWithCallbacks(gameId, (result) => resolve(result), (exception, reason) => reject(exception));
        });
    }
    
    private getWithCallbacks(gameId: number, onSuccess?: (result: Game) => void, onFail?: (exception: string, reason: string) => void) {
        var url = this.baseUrl + "/api/games/{gameId:long:min(1)}?"; 

        if (gameId === undefined || gameId === null)
            throw new Error("The parameter 'gameId' must be defined.");
        url = url.replace("{gameId}", encodeURIComponent("" + gameId)); 

        var content = "";

        jQuery.ajax({
            url: url,
            beforeSend: this.beforeSend,
            type: "get",
            data: content,
            dataType: "text",
            headers: {
                "Content-Type": "application/json; charset=UTF-8"
            }
        }).done((data, textStatus, xhr) => {
            this.processGetWithCallbacks(url, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processGetWithCallbacks(url, xhr, onSuccess, onFail);
        });
    }

    private processGetWithCallbacks(url: string, xhr: any, onSuccess?: any, onFail?: any) {
        try {
            var result = this.processGet(xhr);
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    private processGet(xhr: any) {
        var data = xhr.responseText; 
        var status = xhr.status.toString(); 

        if (status === "200") {
            var result200: Game = null; 
            if (data !== undefined && data !== null && data !== "") {
                result200 = data === "" ? null : <Game>jQuery.parseJSON(data);
            }
            return result200;
        }
        else
        {
            throw new Error("error_no_callback_for_the_received_http_status");
        }
    }

    /**
     * Cancel/delete the requested game, if possible.
     * @gameId Id of the game to delete
     * @return Status
     */
    delete(gameId: number): Q.Promise<any> {
        return Q.Promise<any>((resolve, reject) => {
            this.deleteWithCallbacks(gameId, (result) => resolve(result), (exception, reason) => reject(exception));
        });
    }
    
    private deleteWithCallbacks(gameId: number, onSuccess?: (result: any) => void, onFail?: (exception: string, reason: string) => void) {
        var url = this.baseUrl + "/api/games/{gameId:long:min(1)}?"; 

        if (gameId === undefined || gameId === null)
            throw new Error("The parameter 'gameId' must be defined.");
        url = url.replace("{gameId}", encodeURIComponent("" + gameId)); 

        var content = "";

        jQuery.ajax({
            url: url,
            beforeSend: this.beforeSend,
            type: "delete",
            data: content,
            dataType: "text",
            headers: {
                "Content-Type": "application/json; charset=UTF-8"
            }
        }).done((data, textStatus, xhr) => {
            this.processDeleteWithCallbacks(url, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processDeleteWithCallbacks(url, xhr, onSuccess, onFail);
        });
    }

    private processDeleteWithCallbacks(url: string, xhr: any, onSuccess?: any, onFail?: any) {
        try {
            var result = this.processDelete(xhr);
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    private processDelete(xhr: any) {
        var data = xhr.responseText; 
        var status = xhr.status.toString(); 

        if (status === "200") {
            var result200: any = null; 
            if (data !== undefined && data !== null && data !== "") {
                result200 = data;
            }
            return result200;
        }
        else
        {
            throw new Error("error_no_callback_for_the_received_http_status");
        }
    }

    /**
     * Get messages for a single game
     * @gameId Id of the requested game
     * @isPublic (optional) Value indicating whether to return only public messages, default is true
     * @return Messages posted in the requested game
     */
    getMessages(gameId: number, isPublic: boolean): Q.Promise<Game> {
        return Q.Promise<Game>((resolve, reject) => {
            this.getMessagesWithCallbacks(gameId, isPublic, (result) => resolve(result), (exception, reason) => reject(exception));
        });
    }
    
    private getMessagesWithCallbacks(gameId: number, isPublic: boolean, onSuccess?: (result: Game) => void, onFail?: (exception: string, reason: string) => void) {
        var url = this.baseUrl + "/api/games/{gameId:long:min(1)}/messages?"; 

        if (gameId === undefined || gameId === null)
            throw new Error("The parameter 'gameId' must be defined.");
        url = url.replace("{gameId}", encodeURIComponent("" + gameId)); 

        if (isPublic === null)
            throw new Error("The parameter 'isPublic' cannot be null.");
        else if (isPublic !== undefined)
            url += "isPublic=" + encodeURIComponent("" + isPublic) + "&"; 

        var content = "";

        jQuery.ajax({
            url: url,
            beforeSend: this.beforeSend,
            type: "get",
            data: content,
            dataType: "text",
            headers: {
                "Content-Type": "application/json; charset=UTF-8"
            }
        }).done((data, textStatus, xhr) => {
            this.processGetMessagesWithCallbacks(url, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processGetMessagesWithCallbacks(url, xhr, onSuccess, onFail);
        });
    }

    private processGetMessagesWithCallbacks(url: string, xhr: any, onSuccess?: any, onFail?: any) {
        try {
            var result = this.processGetMessages(xhr);
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    private processGetMessages(xhr: any) {
        var data = xhr.responseText; 
        var status = xhr.status.toString(); 

        if (status === "200") {
            var result200: Game = null; 
            if (data !== undefined && data !== null && data !== "") {
                result200 = data === "" ? null : <Game>jQuery.parseJSON(data);
            }
            return result200;
        }
        else
        {
            throw new Error("error_no_callback_for_the_received_http_status");
        }
    }

    /**
     * Join the given game
     * @gameId Id of game to join
     */
    postJoin(gameId: number): Q.Promise<any> {
        return Q.Promise<any>((resolve, reject) => {
            this.postJoinWithCallbacks(gameId, (result) => resolve(result), (exception, reason) => reject(exception));
        });
    }
    
    private postJoinWithCallbacks(gameId: number, onSuccess?: (result: any) => void, onFail?: (exception: string, reason: string) => void) {
        var url = this.baseUrl + "/api/games/{gameId:long:min(1)}/join?"; 

        if (gameId === undefined || gameId === null)
            throw new Error("The parameter 'gameId' must be defined.");
        url = url.replace("{gameId}", encodeURIComponent("" + gameId)); 

        var content = "";

        jQuery.ajax({
            url: url,
            beforeSend: this.beforeSend,
            type: "post",
            data: content,
            dataType: "text",
            headers: {
                "Content-Type": "application/json; charset=UTF-8"
            }
        }).done((data, textStatus, xhr) => {
            this.processPostJoinWithCallbacks(url, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processPostJoinWithCallbacks(url, xhr, onSuccess, onFail);
        });
    }

    private processPostJoinWithCallbacks(url: string, xhr: any, onSuccess?: any, onFail?: any) {
        try {
            var result = this.processPostJoin(xhr);
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    private processPostJoin(xhr: any) {
        var data = xhr.responseText; 
        var status = xhr.status.toString(); 

        if (status === "200") {
            var result200: any = null; 
            if (data !== undefined && data !== null && data !== "") {
                result200 = data;
            }
            return result200;
        }
        else
        {
            throw new Error("error_no_callback_for_the_received_http_status");
        }
    }

    /**
     * Leave the given game, only possible if game hasn't started yet, and current player
is not the creator.
     * @gameId Id of game to leave
     */
    postLeave(gameId: number): Q.Promise<any> {
        return Q.Promise<any>((resolve, reject) => {
            this.postLeaveWithCallbacks(gameId, (result) => resolve(result), (exception, reason) => reject(exception));
        });
    }
    
    private postLeaveWithCallbacks(gameId: number, onSuccess?: (result: any) => void, onFail?: (exception: string, reason: string) => void) {
        var url = this.baseUrl + "/api/games/{gameId:long:min(1)}/leave?"; 

        if (gameId === undefined || gameId === null)
            throw new Error("The parameter 'gameId' must be defined.");
        url = url.replace("{gameId}", encodeURIComponent("" + gameId)); 

        var content = "";

        jQuery.ajax({
            url: url,
            beforeSend: this.beforeSend,
            type: "post",
            data: content,
            dataType: "text",
            headers: {
                "Content-Type": "application/json; charset=UTF-8"
            }
        }).done((data, textStatus, xhr) => {
            this.processPostLeaveWithCallbacks(url, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processPostLeaveWithCallbacks(url, xhr, onSuccess, onFail);
        });
    }

    private processPostLeaveWithCallbacks(url: string, xhr: any, onSuccess?: any, onFail?: any) {
        try {
            var result = this.processPostLeave(xhr);
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    private processPostLeave(xhr: any) {
        var data = xhr.responseText; 
        var status = xhr.status.toString(); 

        if (status === "200") {
            var result200: any = null; 
            if (data !== undefined && data !== null && data !== "") {
                result200 = data;
            }
            return result200;
        }
        else
        {
            throw new Error("error_no_callback_for_the_received_http_status");
        }
    }

    /**
     * Surrender in the given game, only possible if current player
and game are still active.
     * @gameId Id of game to surrender in
     */
    postSurrender(gameId: number): Q.Promise<GameSummary> {
        return Q.Promise<GameSummary>((resolve, reject) => {
            this.postSurrenderWithCallbacks(gameId, (result) => resolve(result), (exception, reason) => reject(exception));
        });
    }
    
    private postSurrenderWithCallbacks(gameId: number, onSuccess?: (result: GameSummary) => void, onFail?: (exception: string, reason: string) => void) {
        var url = this.baseUrl + "/api/games/{gameId:long:min(1)}/surrender?"; 

        if (gameId === undefined || gameId === null)
            throw new Error("The parameter 'gameId' must be defined.");
        url = url.replace("{gameId}", encodeURIComponent("" + gameId)); 

        var content = "";

        jQuery.ajax({
            url: url,
            beforeSend: this.beforeSend,
            type: "post",
            data: content,
            dataType: "text",
            headers: {
                "Content-Type": "application/json; charset=UTF-8"
            }
        }).done((data, textStatus, xhr) => {
            this.processPostSurrenderWithCallbacks(url, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processPostSurrenderWithCallbacks(url, xhr, onSuccess, onFail);
        });
    }

    private processPostSurrenderWithCallbacks(url: string, xhr: any, onSuccess?: any, onFail?: any) {
        try {
            var result = this.processPostSurrender(xhr);
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    private processPostSurrender(xhr: any) {
        var data = xhr.responseText; 
        var status = xhr.status.toString(); 

        if (status === "200") {
            var result200: GameSummary = null; 
            if (data !== undefined && data !== null && data !== "") {
                result200 = data === "" ? null : <GameSummary>jQuery.parseJSON(data);
            }
            return result200;
        }
        else
        {
            throw new Error("error_no_callback_for_the_received_http_status");
        }
    }

    /**
     * Hides the given game for the current player
     * @gameId Id of game to hide
     */
    patchHide(gameId: number): Q.Promise<any> {
        return Q.Promise<any>((resolve, reject) => {
            this.patchHideWithCallbacks(gameId, (result) => resolve(result), (exception, reason) => reject(exception));
        });
    }
    
    private patchHideWithCallbacks(gameId: number, onSuccess?: (result: any) => void, onFail?: (exception: string, reason: string) => void) {
        var url = this.baseUrl + "/api/games/{gameId:long:min(1)}/hide?"; 

        if (gameId === undefined || gameId === null)
            throw new Error("The parameter 'gameId' must be defined.");
        url = url.replace("{gameId}", encodeURIComponent("" + gameId)); 

        var content = "";

        jQuery.ajax({
            url: url,
            beforeSend: this.beforeSend,
            type: "post",
            data: content,
            dataType: "text",
            headers: {
                "Content-Type": "application/json; charset=UTF-8"
            }
        }).done((data, textStatus, xhr) => {
            this.processPatchHideWithCallbacks(url, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processPatchHideWithCallbacks(url, xhr, onSuccess, onFail);
        });
    }

    private processPatchHideWithCallbacks(url: string, xhr: any, onSuccess?: any, onFail?: any) {
        try {
            var result = this.processPatchHide(xhr);
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    private processPatchHide(xhr: any) {
        var data = xhr.responseText; 
        var status = xhr.status.toString(); 

        if (status === "200") {
            var result200: any = null; 
            if (data !== undefined && data !== null && data !== "") {
                result200 = data;
            }
            return result200;
        }
        else
        {
            throw new Error("error_no_callback_for_the_received_http_status");
        }
    }

    /**
     * Hide all games which can be hidden for the current player
     */
    patchHideAll(): Q.Promise<any> {
        return Q.Promise<any>((resolve, reject) => {
            this.patchHideAllWithCallbacks((result) => resolve(result), (exception, reason) => reject(exception));
        });
    }
    
    private patchHideAllWithCallbacks(onSuccess?: (result: any) => void, onFail?: (exception: string, reason: string) => void) {
        var url = this.baseUrl + "/api/games/hide?"; 

        var content = "";

        jQuery.ajax({
            url: url,
            beforeSend: this.beforeSend,
            type: "post",
            data: content,
            dataType: "text",
            headers: {
                "Content-Type": "application/json; charset=UTF-8"
            }
        }).done((data, textStatus, xhr) => {
            this.processPatchHideAllWithCallbacks(url, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processPatchHideAllWithCallbacks(url, xhr, onSuccess, onFail);
        });
    }

    private processPatchHideAllWithCallbacks(url: string, xhr: any, onSuccess?: any, onFail?: any) {
        try {
            var result = this.processPatchHideAll(xhr);
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    private processPatchHideAll(xhr: any) {
        var data = xhr.responseText; 
        var status = xhr.status.toString(); 

        if (status === "200") {
            var result200: any = null; 
            if (data !== undefined && data !== null && data !== "") {
                result200 = data;
            }
            return result200;
        }
        else
        {
            throw new Error("error_no_callback_for_the_received_http_status");
        }
    }
}

export class MessageClient {
    baseUrl: string = undefined; 
    beforeSend: any = undefined; 

    constructor(baseUrl?: string) {
        this.baseUrl = baseUrl !== undefined ? baseUrl : ""; 
    }

    getAll(folder: MessageFolderAsInteger): Q.Promise<Message[]> {
        return Q.Promise<Message[]>((resolve, reject) => {
            this.getAllWithCallbacks(folder, (result) => resolve(result), (exception, reason) => reject(exception));
        });
    }
    
    private getAllWithCallbacks(folder: MessageFolderAsInteger, onSuccess?: (result: Message[]) => void, onFail?: (exception: string, reason: string) => void) {
        var url = this.baseUrl + "/api/messages/folder/{folder}?"; 

        if (folder === undefined || folder === null)
            throw new Error("The parameter 'folder' must be defined.");
        url = url.replace("{folder}", encodeURIComponent("" + folder)); 

        var content = "";

        jQuery.ajax({
            url: url,
            beforeSend: this.beforeSend,
            type: "get",
            data: content,
            dataType: "text",
            headers: {
                "Content-Type": "application/json; charset=UTF-8"
            }
        }).done((data, textStatus, xhr) => {
            this.processGetAllWithCallbacks(url, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processGetAllWithCallbacks(url, xhr, onSuccess, onFail);
        });
    }

    private processGetAllWithCallbacks(url: string, xhr: any, onSuccess?: any, onFail?: any) {
        try {
            var result = this.processGetAll(xhr);
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    private processGetAll(xhr: any) {
        var data = xhr.responseText; 
        var status = xhr.status.toString(); 

        if (status === "200") {
            var result200: Message[] = null; 
            if (data !== undefined && data !== null && data !== "") {
                result200 = data === "" ? null : <Message[]>jQuery.parseJSON(data);
            }
            return result200;
        }
        else
        {
            throw new Error("error_no_callback_for_the_received_http_status");
        }
    }

    get(messageId: string): Q.Promise<Message> {
        return Q.Promise<Message>((resolve, reject) => {
            this.getWithCallbacks(messageId, (result) => resolve(result), (exception, reason) => reject(exception));
        });
    }
    
    private getWithCallbacks(messageId: string, onSuccess?: (result: Message) => void, onFail?: (exception: string, reason: string) => void) {
        var url = this.baseUrl + "/api/messages/{messageId}?"; 

        if (messageId === undefined || messageId === null)
            throw new Error("The parameter 'messageId' must be defined.");
        url = url.replace("{messageId}", encodeURIComponent("" + messageId)); 

        var content = "";

        jQuery.ajax({
            url: url,
            beforeSend: this.beforeSend,
            type: "get",
            data: content,
            dataType: "text",
            headers: {
                "Content-Type": "application/json; charset=UTF-8"
            }
        }).done((data, textStatus, xhr) => {
            this.processGetWithCallbacks(url, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processGetWithCallbacks(url, xhr, onSuccess, onFail);
        });
    }

    private processGetWithCallbacks(url: string, xhr: any, onSuccess?: any, onFail?: any) {
        try {
            var result = this.processGet(xhr);
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    private processGet(xhr: any) {
        var data = xhr.responseText; 
        var status = xhr.status.toString(); 

        if (status === "200") {
            var result200: Message = null; 
            if (data !== undefined && data !== null && data !== "") {
                result200 = data === "" ? null : <Message>jQuery.parseJSON(data);
            }
            return result200;
        }
        else
        {
            throw new Error("error_no_callback_for_the_received_http_status");
        }
    }

    getFolderInformation(): Q.Promise<FolderInformation> {
        return Q.Promise<FolderInformation>((resolve, reject) => {
            this.getFolderInformationWithCallbacks((result) => resolve(result), (exception, reason) => reject(exception));
        });
    }
    
    private getFolderInformationWithCallbacks(onSuccess?: (result: FolderInformation) => void, onFail?: (exception: string, reason: string) => void) {
        var url = this.baseUrl + "/api/messages/folders?"; 

        var content = "";

        jQuery.ajax({
            url: url,
            beforeSend: this.beforeSend,
            type: "get",
            data: content,
            dataType: "text",
            headers: {
                "Content-Type": "application/json; charset=UTF-8"
            }
        }).done((data, textStatus, xhr) => {
            this.processGetFolderInformationWithCallbacks(url, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processGetFolderInformationWithCallbacks(url, xhr, onSuccess, onFail);
        });
    }

    private processGetFolderInformationWithCallbacks(url: string, xhr: any, onSuccess?: any, onFail?: any) {
        try {
            var result = this.processGetFolderInformation(xhr);
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    private processGetFolderInformation(xhr: any) {
        var data = xhr.responseText; 
        var status = xhr.status.toString(); 

        if (status === "200") {
            var result200: FolderInformation = null; 
            if (data !== undefined && data !== null && data !== "") {
                result200 = data === "" ? null : <FolderInformation>jQuery.parseJSON(data);
            }
            return result200;
        }
        else
        {
            throw new Error("error_no_callback_for_the_received_http_status");
        }
    }

    postSend(message: SendMessage): Q.Promise<any> {
        return Q.Promise<any>((resolve, reject) => {
            this.postSendWithCallbacks(message, (result) => resolve(result), (exception, reason) => reject(exception));
        });
    }
    
    private postSendWithCallbacks(message: SendMessage, onSuccess?: (result: any) => void, onFail?: (exception: string, reason: string) => void) {
        var url = this.baseUrl + "/api/messages?"; 

        var content = JSON.stringify(message);

        jQuery.ajax({
            url: url,
            beforeSend: this.beforeSend,
            type: "post",
            data: content,
            dataType: "text",
            headers: {
                "Content-Type": "application/json; charset=UTF-8"
            }
        }).done((data, textStatus, xhr) => {
            this.processPostSendWithCallbacks(url, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processPostSendWithCallbacks(url, xhr, onSuccess, onFail);
        });
    }

    private processPostSendWithCallbacks(url: string, xhr: any, onSuccess?: any, onFail?: any) {
        try {
            var result = this.processPostSend(xhr);
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    private processPostSend(xhr: any) {
        var data = xhr.responseText; 
        var status = xhr.status.toString(); 

        if (status === "200") {
            var result200: any = null; 
            if (data !== undefined && data !== null && data !== "") {
                result200 = data;
            }
            return result200;
        }
        else
        {
            throw new Error("error_no_callback_for_the_received_http_status");
        }
    }

    patchMarkRead(messageId: string): Q.Promise<any> {
        return Q.Promise<any>((resolve, reject) => {
            this.patchMarkReadWithCallbacks(messageId, (result) => resolve(result), (exception, reason) => reject(exception));
        });
    }
    
    private patchMarkReadWithCallbacks(messageId: string, onSuccess?: (result: any) => void, onFail?: (exception: string, reason: string) => void) {
        var url = this.baseUrl + "/api/messages/{messageId:guid}?"; 

        if (messageId === undefined || messageId === null)
            throw new Error("The parameter 'messageId' must be defined.");
        url = url.replace("{messageId}", encodeURIComponent("" + messageId)); 

        var content = "";

        jQuery.ajax({
            url: url,
            beforeSend: this.beforeSend,
            type: "post",
            data: content,
            dataType: "text",
            headers: {
                "Content-Type": "application/json; charset=UTF-8"
            }
        }).done((data, textStatus, xhr) => {
            this.processPatchMarkReadWithCallbacks(url, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processPatchMarkReadWithCallbacks(url, xhr, onSuccess, onFail);
        });
    }

    private processPatchMarkReadWithCallbacks(url: string, xhr: any, onSuccess?: any, onFail?: any) {
        try {
            var result = this.processPatchMarkRead(xhr);
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    private processPatchMarkRead(xhr: any) {
        var data = xhr.responseText; 
        var status = xhr.status.toString(); 

        if (status === "200") {
            var result200: any = null; 
            if (data !== undefined && data !== null && data !== "") {
                result200 = data;
            }
            return result200;
        }
        else
        {
            throw new Error("error_no_callback_for_the_received_http_status");
        }
    }

    delete(messageId: string): Q.Promise<any> {
        return Q.Promise<any>((resolve, reject) => {
            this.deleteWithCallbacks(messageId, (result) => resolve(result), (exception, reason) => reject(exception));
        });
    }
    
    private deleteWithCallbacks(messageId: string, onSuccess?: (result: any) => void, onFail?: (exception: string, reason: string) => void) {
        var url = this.baseUrl + "/api/messages/{messageId:guid}?"; 

        if (messageId === undefined || messageId === null)
            throw new Error("The parameter 'messageId' must be defined.");
        url = url.replace("{messageId}", encodeURIComponent("" + messageId)); 

        var content = "";

        jQuery.ajax({
            url: url,
            beforeSend: this.beforeSend,
            type: "delete",
            data: content,
            dataType: "text",
            headers: {
                "Content-Type": "application/json; charset=UTF-8"
            }
        }).done((data, textStatus, xhr) => {
            this.processDeleteWithCallbacks(url, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processDeleteWithCallbacks(url, xhr, onSuccess, onFail);
        });
    }

    private processDeleteWithCallbacks(url: string, xhr: any, onSuccess?: any, onFail?: any) {
        try {
            var result = this.processDelete(xhr);
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    private processDelete(xhr: any) {
        var data = xhr.responseText; 
        var status = xhr.status.toString(); 

        if (status === "200") {
            var result200: any = null; 
            if (data !== undefined && data !== null && data !== "") {
                result200 = data;
            }
            return result200;
        }
        else
        {
            throw new Error("error_no_callback_for_the_received_http_status");
        }
    }
}

export class NewsClient {
    baseUrl: string = undefined; 
    beforeSend: any = undefined; 

    constructor(baseUrl?: string) {
        this.baseUrl = baseUrl !== undefined ? baseUrl : ""; 
    }

    /**
     * Returns the last 10 news items for all languages
     * @return List of news items
     */
    getAll(): Q.Promise<NewsItem[]> {
        return Q.Promise<NewsItem[]>((resolve, reject) => {
            this.getAllWithCallbacks((result) => resolve(result), (exception, reason) => reject(exception));
        });
    }
    
    private getAllWithCallbacks(onSuccess?: (result: NewsItem[]) => void, onFail?: (exception: string, reason: string) => void) {
        var url = this.baseUrl + "/api/news?"; 

        var content = "";

        jQuery.ajax({
            url: url,
            beforeSend: this.beforeSend,
            type: "get",
            data: content,
            dataType: "text",
            headers: {
                "Content-Type": "application/json; charset=UTF-8"
            }
        }).done((data, textStatus, xhr) => {
            this.processGetAllWithCallbacks(url, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processGetAllWithCallbacks(url, xhr, onSuccess, onFail);
        });
    }

    private processGetAllWithCallbacks(url: string, xhr: any, onSuccess?: any, onFail?: any) {
        try {
            var result = this.processGetAll(xhr);
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    private processGetAll(xhr: any) {
        var data = xhr.responseText; 
        var status = xhr.status.toString(); 

        if (status === "200") {
            var result200: NewsItem[] = null; 
            if (data !== undefined && data !== null && data !== "") {
                result200 = data === "" ? null : <NewsItem[]>jQuery.parseJSON(data);
            }
            return result200;
        }
        else
        {
            throw new Error("error_no_callback_for_the_received_http_status");
        }
    }
}

export class NotificationClient {
    baseUrl: string = undefined; 
    beforeSend: any = undefined; 

    constructor(baseUrl?: string) {
        this.baseUrl = baseUrl !== undefined ? baseUrl : ""; 
    }

    /**
     * Get notification summary for current user
     */
    getSummary(): Q.Promise<any> {
        return Q.Promise<any>((resolve, reject) => {
            this.getSummaryWithCallbacks((result) => resolve(result), (exception, reason) => reject(exception));
        });
    }
    
    private getSummaryWithCallbacks(onSuccess?: (result: any) => void, onFail?: (exception: string, reason: string) => void) {
        var url = this.baseUrl + "/api/notifications/summary?"; 

        var content = "";

        jQuery.ajax({
            url: url,
            beforeSend: this.beforeSend,
            type: "get",
            data: content,
            dataType: "text",
            headers: {
                "Content-Type": "application/json; charset=UTF-8"
            }
        }).done((data, textStatus, xhr) => {
            this.processGetSummaryWithCallbacks(url, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processGetSummaryWithCallbacks(url, xhr, onSuccess, onFail);
        });
    }

    private processGetSummaryWithCallbacks(url: string, xhr: any, onSuccess?: any, onFail?: any) {
        try {
            var result = this.processGetSummary(xhr);
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    private processGetSummary(xhr: any) {
        var data = xhr.responseText; 
        var status = xhr.status.toString(); 

        if (status === "200") {
            var result200: any = null; 
            if (data !== undefined && data !== null && data !== "") {
                result200 = data;
            }
            return result200;
        }
        else
        {
            throw new Error("error_no_callback_for_the_received_http_status");
        }
    }
}

export class PlayClient {
    baseUrl: string = undefined; 
    beforeSend: any = undefined; 

    constructor(baseUrl?: string) {
        this.baseUrl = baseUrl !== undefined ? baseUrl : ""; 
    }

    /**
     * Place units to countries.
     * @gameId Id of the game
     * @placeUnitsOptions (optional) List of country/unit count pairs
     * @return GameActionResult of action
     */
    postPlace(gameId: number, placeUnitsOptions: PlaceUnitsOptions[]): Q.Promise<GameActionResult> {
        return Q.Promise<GameActionResult>((resolve, reject) => {
            this.postPlaceWithCallbacks(gameId, placeUnitsOptions, (result) => resolve(result), (exception, reason) => reject(exception));
        });
    }
    
    private postPlaceWithCallbacks(gameId: number, placeUnitsOptions: PlaceUnitsOptions[], onSuccess?: (result: GameActionResult) => void, onFail?: (exception: string, reason: string) => void) {
        var url = this.baseUrl + "/api/games/{gameId:long:min(1)}/play/place?"; 

        if (gameId === undefined || gameId === null)
            throw new Error("The parameter 'gameId' must be defined.");
        url = url.replace("{gameId}", encodeURIComponent("" + gameId)); 

        var content = JSON.stringify(placeUnitsOptions);

        jQuery.ajax({
            url: url,
            beforeSend: this.beforeSend,
            type: "post",
            data: content,
            dataType: "text",
            headers: {
                "Content-Type": "application/json; charset=UTF-8"
            }
        }).done((data, textStatus, xhr) => {
            this.processPostPlaceWithCallbacks(url, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processPostPlaceWithCallbacks(url, xhr, onSuccess, onFail);
        });
    }

    private processPostPlaceWithCallbacks(url: string, xhr: any, onSuccess?: any, onFail?: any) {
        try {
            var result = this.processPostPlace(xhr);
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    private processPostPlace(xhr: any) {
        var data = xhr.responseText; 
        var status = xhr.status.toString(); 

        if (status === "200") {
            var result200: GameActionResult = null; 
            if (data !== undefined && data !== null && data !== "") {
                result200 = data === "" ? null : <GameActionResult>jQuery.parseJSON(data);
            }
            return result200;
        }
        else
        {
            throw new Error("error_no_callback_for_the_received_http_status");
        }
    }

    /**
     * Exchange cards for the current player. Which cards to exchange is automatically chosen to gain the most bonus for the player.
     * @gameId Id of the game
     * @return GameActionResult of action
     */
    postExchange(gameId: number): Q.Promise<GameActionResult> {
        return Q.Promise<GameActionResult>((resolve, reject) => {
            this.postExchangeWithCallbacks(gameId, (result) => resolve(result), (exception, reason) => reject(exception));
        });
    }
    
    private postExchangeWithCallbacks(gameId: number, onSuccess?: (result: GameActionResult) => void, onFail?: (exception: string, reason: string) => void) {
        var url = this.baseUrl + "/api/games/{gameId:long:min(1)}/play/exchange?"; 

        if (gameId === undefined || gameId === null)
            throw new Error("The parameter 'gameId' must be defined.");
        url = url.replace("{gameId}", encodeURIComponent("" + gameId)); 

        var content = "";

        jQuery.ajax({
            url: url,
            beforeSend: this.beforeSend,
            type: "post",
            data: content,
            dataType: "text",
            headers: {
                "Content-Type": "application/json; charset=UTF-8"
            }
        }).done((data, textStatus, xhr) => {
            this.processPostExchangeWithCallbacks(url, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processPostExchangeWithCallbacks(url, xhr, onSuccess, onFail);
        });
    }

    private processPostExchangeWithCallbacks(url: string, xhr: any, onSuccess?: any, onFail?: any) {
        try {
            var result = this.processPostExchange(xhr);
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    private processPostExchange(xhr: any) {
        var data = xhr.responseText; 
        var status = xhr.status.toString(); 

        if (status === "200") {
            var result200: GameActionResult = null; 
            if (data !== undefined && data !== null && data !== "") {
                result200 = data === "" ? null : <GameActionResult>jQuery.parseJSON(data);
            }
            return result200;
        }
        else
        {
            throw new Error("error_no_callback_for_the_received_http_status");
        }
    }

    /**
     * Attack from one to another country.
     * @gameId Id of the game
     * @options (optional) Options for the command
     * @return GameActionResult of action
     */
    postAttack(gameId: number, options: AttackOptions): Q.Promise<GameActionResult> {
        return Q.Promise<GameActionResult>((resolve, reject) => {
            this.postAttackWithCallbacks(gameId, options, (result) => resolve(result), (exception, reason) => reject(exception));
        });
    }
    
    private postAttackWithCallbacks(gameId: number, options: AttackOptions, onSuccess?: (result: GameActionResult) => void, onFail?: (exception: string, reason: string) => void) {
        var url = this.baseUrl + "/api/games/{gameId:long:min(1)}/play/attack?"; 

        if (gameId === undefined || gameId === null)
            throw new Error("The parameter 'gameId' must be defined.");
        url = url.replace("{gameId}", encodeURIComponent("" + gameId)); 

        var content = JSON.stringify(options);

        jQuery.ajax({
            url: url,
            beforeSend: this.beforeSend,
            type: "post",
            data: content,
            dataType: "text",
            headers: {
                "Content-Type": "application/json; charset=UTF-8"
            }
        }).done((data, textStatus, xhr) => {
            this.processPostAttackWithCallbacks(url, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processPostAttackWithCallbacks(url, xhr, onSuccess, onFail);
        });
    }

    private processPostAttackWithCallbacks(url: string, xhr: any, onSuccess?: any, onFail?: any) {
        try {
            var result = this.processPostAttack(xhr);
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    private processPostAttack(xhr: any) {
        var data = xhr.responseText; 
        var status = xhr.status.toString(); 

        if (status === "200") {
            var result200: GameActionResult = null; 
            if (data !== undefined && data !== null && data !== "") {
                result200 = data === "" ? null : <GameActionResult>jQuery.parseJSON(data);
            }
            return result200;
        }
        else
        {
            throw new Error("error_no_callback_for_the_received_http_status");
        }
    }

    /**
     * Switch to moving.
     * @gameId Id of the game
     * @return GameActionResult of action
     */
    postEndAttack(gameId: number): Q.Promise<GameActionResult> {
        return Q.Promise<GameActionResult>((resolve, reject) => {
            this.postEndAttackWithCallbacks(gameId, (result) => resolve(result), (exception, reason) => reject(exception));
        });
    }
    
    private postEndAttackWithCallbacks(gameId: number, onSuccess?: (result: GameActionResult) => void, onFail?: (exception: string, reason: string) => void) {
        var url = this.baseUrl + "/api/games/{gameId:long:min(1)}/play/endattack?"; 

        if (gameId === undefined || gameId === null)
            throw new Error("The parameter 'gameId' must be defined.");
        url = url.replace("{gameId}", encodeURIComponent("" + gameId)); 

        var content = "";

        jQuery.ajax({
            url: url,
            beforeSend: this.beforeSend,
            type: "post",
            data: content,
            dataType: "text",
            headers: {
                "Content-Type": "application/json; charset=UTF-8"
            }
        }).done((data, textStatus, xhr) => {
            this.processPostEndAttackWithCallbacks(url, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processPostEndAttackWithCallbacks(url, xhr, onSuccess, onFail);
        });
    }

    private processPostEndAttackWithCallbacks(url: string, xhr: any, onSuccess?: any, onFail?: any) {
        try {
            var result = this.processPostEndAttack(xhr);
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    private processPostEndAttack(xhr: any) {
        var data = xhr.responseText; 
        var status = xhr.status.toString(); 

        if (status === "200") {
            var result200: GameActionResult = null; 
            if (data !== undefined && data !== null && data !== "") {
                result200 = data === "" ? null : <GameActionResult>jQuery.parseJSON(data);
            }
            return result200;
        }
        else
        {
            throw new Error("error_no_callback_for_the_received_http_status");
        }
    }

    /**
     * Move units between countries. Only allowed after placing. Cancels any attacks that the player had left before. Attacking is not
possible anymore after moving.
     * @gameId Id of the game
     * @options (optional) Options for the command
     * @return GameActionResult of action
     */
    postMove(gameId: number, options: MoveOptions): Q.Promise<GameActionResult> {
        return Q.Promise<GameActionResult>((resolve, reject) => {
            this.postMoveWithCallbacks(gameId, options, (result) => resolve(result), (exception, reason) => reject(exception));
        });
    }
    
    private postMoveWithCallbacks(gameId: number, options: MoveOptions, onSuccess?: (result: GameActionResult) => void, onFail?: (exception: string, reason: string) => void) {
        var url = this.baseUrl + "/api/games/{gameId:long:min(1)}/play/move?"; 

        if (gameId === undefined || gameId === null)
            throw new Error("The parameter 'gameId' must be defined.");
        url = url.replace("{gameId}", encodeURIComponent("" + gameId)); 

        var content = JSON.stringify(options);

        jQuery.ajax({
            url: url,
            beforeSend: this.beforeSend,
            type: "post",
            data: content,
            dataType: "text",
            headers: {
                "Content-Type": "application/json; charset=UTF-8"
            }
        }).done((data, textStatus, xhr) => {
            this.processPostMoveWithCallbacks(url, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processPostMoveWithCallbacks(url, xhr, onSuccess, onFail);
        });
    }

    private processPostMoveWithCallbacks(url: string, xhr: any, onSuccess?: any, onFail?: any) {
        try {
            var result = this.processPostMove(xhr);
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    private processPostMove(xhr: any) {
        var data = xhr.responseText; 
        var status = xhr.status.toString(); 

        if (status === "200") {
            var result200: GameActionResult = null; 
            if (data !== undefined && data !== null && data !== "") {
                result200 = data === "" ? null : <GameActionResult>jQuery.parseJSON(data);
            }
            return result200;
        }
        else
        {
            throw new Error("error_no_callback_for_the_received_http_status");
        }
    }

    /**
     * End the current turn
     * @gameId Id of the game
     * @return GameActionResult of action
     */
    postEndTurn(gameId: number): Q.Promise<Game> {
        return Q.Promise<Game>((resolve, reject) => {
            this.postEndTurnWithCallbacks(gameId, (result) => resolve(result), (exception, reason) => reject(exception));
        });
    }
    
    private postEndTurnWithCallbacks(gameId: number, onSuccess?: (result: Game) => void, onFail?: (exception: string, reason: string) => void) {
        var url = this.baseUrl + "/api/games/{gameId:long:min(1)}/play/endturn?"; 

        if (gameId === undefined || gameId === null)
            throw new Error("The parameter 'gameId' must be defined.");
        url = url.replace("{gameId}", encodeURIComponent("" + gameId)); 

        var content = "";

        jQuery.ajax({
            url: url,
            beforeSend: this.beforeSend,
            type: "post",
            data: content,
            dataType: "text",
            headers: {
                "Content-Type": "application/json; charset=UTF-8"
            }
        }).done((data, textStatus, xhr) => {
            this.processPostEndTurnWithCallbacks(url, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processPostEndTurnWithCallbacks(url, xhr, onSuccess, onFail);
        });
    }

    private processPostEndTurnWithCallbacks(url: string, xhr: any, onSuccess?: any, onFail?: any) {
        try {
            var result = this.processPostEndTurn(xhr);
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    private processPostEndTurn(xhr: any) {
        var data = xhr.responseText; 
        var status = xhr.status.toString(); 

        if (status === "200") {
            var result200: Game = null; 
            if (data !== undefined && data !== null && data !== "") {
                result200 = data === "" ? null : <Game>jQuery.parseJSON(data);
            }
            return result200;
        }
        else
        {
            throw new Error("error_no_callback_for_the_received_http_status");
        }
    }
}

export class TournamentClient {
    baseUrl: string = undefined; 
    beforeSend: any = undefined; 

    constructor(baseUrl?: string) {
        this.baseUrl = baseUrl !== undefined ? baseUrl : ""; 
    }

    /**
     * Returns tournaments
     * @return List of tournaments
     */
    getAll(): Q.Promise<Tournament[]> {
        return Q.Promise<Tournament[]>((resolve, reject) => {
            this.getAllWithCallbacks((result) => resolve(result), (exception, reason) => reject(exception));
        });
    }
    
    private getAllWithCallbacks(onSuccess?: (result: Tournament[]) => void, onFail?: (exception: string, reason: string) => void) {
        var url = this.baseUrl + "/api/tournaments?"; 

        var content = "";

        jQuery.ajax({
            url: url,
            beforeSend: this.beforeSend,
            type: "get",
            data: content,
            dataType: "text",
            headers: {
                "Content-Type": "application/json; charset=UTF-8"
            }
        }).done((data, textStatus, xhr) => {
            this.processGetAllWithCallbacks(url, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processGetAllWithCallbacks(url, xhr, onSuccess, onFail);
        });
    }

    private processGetAllWithCallbacks(url: string, xhr: any, onSuccess?: any, onFail?: any) {
        try {
            var result = this.processGetAll(xhr);
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    private processGetAll(xhr: any) {
        var data = xhr.responseText; 
        var status = xhr.status.toString(); 

        if (status === "200") {
            var result200: Tournament[] = null; 
            if (data !== undefined && data !== null && data !== "") {
                result200 = data === "" ? null : <Tournament[]>jQuery.parseJSON(data);
            }
            return result200;
        }
        else
        {
            throw new Error("error_no_callback_for_the_received_http_status");
        }
    }

    /**
     * Get tournament identified by Id
     * @tournamentId Id of tournament
     */
    getById(tournamentId: string): Q.Promise<Tournament> {
        return Q.Promise<Tournament>((resolve, reject) => {
            this.getByIdWithCallbacks(tournamentId, (result) => resolve(result), (exception, reason) => reject(exception));
        });
    }
    
    private getByIdWithCallbacks(tournamentId: string, onSuccess?: (result: Tournament) => void, onFail?: (exception: string, reason: string) => void) {
        var url = this.baseUrl + "/api/tournaments/{tournamentId:guid}?"; 

        if (tournamentId === undefined || tournamentId === null)
            throw new Error("The parameter 'tournamentId' must be defined.");
        url = url.replace("{tournamentId}", encodeURIComponent("" + tournamentId)); 

        var content = "";

        jQuery.ajax({
            url: url,
            beforeSend: this.beforeSend,
            type: "get",
            data: content,
            dataType: "text",
            headers: {
                "Content-Type": "application/json; charset=UTF-8"
            }
        }).done((data, textStatus, xhr) => {
            this.processGetByIdWithCallbacks(url, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processGetByIdWithCallbacks(url, xhr, onSuccess, onFail);
        });
    }

    private processGetByIdWithCallbacks(url: string, xhr: any, onSuccess?: any, onFail?: any) {
        try {
            var result = this.processGetById(xhr);
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    private processGetById(xhr: any) {
        var data = xhr.responseText; 
        var status = xhr.status.toString(); 

        if (status === "200") {
            var result200: Tournament = null; 
            if (data !== undefined && data !== null && data !== "") {
                result200 = data === "" ? null : <Tournament>jQuery.parseJSON(data);
            }
            return result200;
        }
        else
        {
            throw new Error("error_no_callback_for_the_received_http_status");
        }
    }

    /**
     * Join tournament
     * @tournamentId Id of tournament
     */
    postJoin(tournamentId: string): Q.Promise<TournamentTeam> {
        return Q.Promise<TournamentTeam>((resolve, reject) => {
            this.postJoinWithCallbacks(tournamentId, (result) => resolve(result), (exception, reason) => reject(exception));
        });
    }
    
    private postJoinWithCallbacks(tournamentId: string, onSuccess?: (result: TournamentTeam) => void, onFail?: (exception: string, reason: string) => void) {
        var url = this.baseUrl + "/api/tournaments/{tournamentId:guid}?"; 

        if (tournamentId === undefined || tournamentId === null)
            throw new Error("The parameter 'tournamentId' must be defined.");
        url = url.replace("{tournamentId}", encodeURIComponent("" + tournamentId)); 

        var content = "";

        jQuery.ajax({
            url: url,
            beforeSend: this.beforeSend,
            type: "post",
            data: content,
            dataType: "text",
            headers: {
                "Content-Type": "application/json; charset=UTF-8"
            }
        }).done((data, textStatus, xhr) => {
            this.processPostJoinWithCallbacks(url, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processPostJoinWithCallbacks(url, xhr, onSuccess, onFail);
        });
    }

    private processPostJoinWithCallbacks(url: string, xhr: any, onSuccess?: any, onFail?: any) {
        try {
            var result = this.processPostJoin(xhr);
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    private processPostJoin(xhr: any) {
        var data = xhr.responseText; 
        var status = xhr.status.toString(); 

        if (status === "200") {
            var result200: TournamentTeam = null; 
            if (data !== undefined && data !== null && data !== "") {
                result200 = data === "" ? null : <TournamentTeam>jQuery.parseJSON(data);
            }
            return result200;
        }
        else
        {
            throw new Error("error_no_callback_for_the_received_http_status");
        }
    }

    /**
     * Get teams for tournament
     * @tournamentId Id of tournament
     */
    getTeams(tournamentId: string): Q.Promise<TournamentTeam[]> {
        return Q.Promise<TournamentTeam[]>((resolve, reject) => {
            this.getTeamsWithCallbacks(tournamentId, (result) => resolve(result), (exception, reason) => reject(exception));
        });
    }
    
    private getTeamsWithCallbacks(tournamentId: string, onSuccess?: (result: TournamentTeam[]) => void, onFail?: (exception: string, reason: string) => void) {
        var url = this.baseUrl + "/api/tournaments/{tournamentId:guid}/teams?"; 

        if (tournamentId === undefined || tournamentId === null)
            throw new Error("The parameter 'tournamentId' must be defined.");
        url = url.replace("{tournamentId}", encodeURIComponent("" + tournamentId)); 

        var content = "";

        jQuery.ajax({
            url: url,
            beforeSend: this.beforeSend,
            type: "get",
            data: content,
            dataType: "text",
            headers: {
                "Content-Type": "application/json; charset=UTF-8"
            }
        }).done((data, textStatus, xhr) => {
            this.processGetTeamsWithCallbacks(url, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processGetTeamsWithCallbacks(url, xhr, onSuccess, onFail);
        });
    }

    private processGetTeamsWithCallbacks(url: string, xhr: any, onSuccess?: any, onFail?: any) {
        try {
            var result = this.processGetTeams(xhr);
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    private processGetTeams(xhr: any) {
        var data = xhr.responseText; 
        var status = xhr.status.toString(); 

        if (status === "200") {
            var result200: TournamentTeam[] = null; 
            if (data !== undefined && data !== null && data !== "") {
                result200 = data === "" ? null : <TournamentTeam[]>jQuery.parseJSON(data);
            }
            return result200;
        }
        else
        {
            throw new Error("error_no_callback_for_the_received_http_status");
        }
    }

    /**
     * Create new team for a tournament
     * @tournamentId Id of tournament
     * @name Name of team
     * @password (optional) Optional password for team
     * @return Summary of newly created team
     */
    postCreateTeam(tournamentId: string, name: string, password: string): Q.Promise<TournamentTeamSummary> {
        return Q.Promise<TournamentTeamSummary>((resolve, reject) => {
            this.postCreateTeamWithCallbacks(tournamentId, name, password, (result) => resolve(result), (exception, reason) => reject(exception));
        });
    }
    
    private postCreateTeamWithCallbacks(tournamentId: string, name: string, password: string, onSuccess?: (result: TournamentTeamSummary) => void, onFail?: (exception: string, reason: string) => void) {
        var url = this.baseUrl + "/api/tournaments/{tournamentId:guid}/teams?"; 

        if (tournamentId === undefined || tournamentId === null)
            throw new Error("The parameter 'tournamentId' must be defined.");
        url = url.replace("{tournamentId}", encodeURIComponent("" + tournamentId)); 

        if (name === undefined)
            throw new Error("The parameter 'name' must be defined.");
        else
            url += "name=" + encodeURIComponent("" + name) + "&"; 
        if (password !== undefined)
            url += "password=" + encodeURIComponent("" + password) + "&"; 

        var content = "";

        jQuery.ajax({
            url: url,
            beforeSend: this.beforeSend,
            type: "post",
            data: content,
            dataType: "text",
            headers: {
                "Content-Type": "application/json; charset=UTF-8"
            }
        }).done((data, textStatus, xhr) => {
            this.processPostCreateTeamWithCallbacks(url, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processPostCreateTeamWithCallbacks(url, xhr, onSuccess, onFail);
        });
    }

    private processPostCreateTeamWithCallbacks(url: string, xhr: any, onSuccess?: any, onFail?: any) {
        try {
            var result = this.processPostCreateTeam(xhr);
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    private processPostCreateTeam(xhr: any) {
        var data = xhr.responseText; 
        var status = xhr.status.toString(); 

        if (status === "200") {
            var result200: TournamentTeamSummary = null; 
            if (data !== undefined && data !== null && data !== "") {
                result200 = data === "" ? null : <TournamentTeamSummary>jQuery.parseJSON(data);
            }
            return result200;
        }
        else
        {
            throw new Error("error_no_callback_for_the_received_http_status");
        }
    }

    /**
     * Join existing team
     * @tournamentId Id of tournament
     * @teamId Id of team
     * @password (optional) Optional password for team to join
     */
    postJoinTeam(tournamentId: string, teamId: string, password: string): Q.Promise<any> {
        return Q.Promise<any>((resolve, reject) => {
            this.postJoinTeamWithCallbacks(tournamentId, teamId, password, (result) => resolve(result), (exception, reason) => reject(exception));
        });
    }
    
    private postJoinTeamWithCallbacks(tournamentId: string, teamId: string, password: string, onSuccess?: (result: any) => void, onFail?: (exception: string, reason: string) => void) {
        var url = this.baseUrl + "/api/tournaments/{tournamentId:guid}/teams/{teamId:guid}?"; 

        if (tournamentId === undefined || tournamentId === null)
            throw new Error("The parameter 'tournamentId' must be defined.");
        url = url.replace("{tournamentId}", encodeURIComponent("" + tournamentId)); 
        if (teamId === undefined || teamId === null)
            throw new Error("The parameter 'teamId' must be defined.");
        url = url.replace("{teamId}", encodeURIComponent("" + teamId)); 

        if (password !== undefined)
            url += "password=" + encodeURIComponent("" + password) + "&"; 

        var content = "";

        jQuery.ajax({
            url: url,
            beforeSend: this.beforeSend,
            type: "post",
            data: content,
            dataType: "text",
            headers: {
                "Content-Type": "application/json; charset=UTF-8"
            }
        }).done((data, textStatus, xhr) => {
            this.processPostJoinTeamWithCallbacks(url, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processPostJoinTeamWithCallbacks(url, xhr, onSuccess, onFail);
        });
    }

    private processPostJoinTeamWithCallbacks(url: string, xhr: any, onSuccess?: any, onFail?: any) {
        try {
            var result = this.processPostJoinTeam(xhr);
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    private processPostJoinTeam(xhr: any) {
        var data = xhr.responseText; 
        var status = xhr.status.toString(); 

        if (status === "200") {
            var result200: any = null; 
            if (data !== undefined && data !== null && data !== "") {
                result200 = data;
            }
            return result200;
        }
        else
        {
            throw new Error("error_no_callback_for_the_received_http_status");
        }
    }

    /**
     * Delete a team. Only allowed if user created it
     * @tournamentId Id of tournament
     * @teamId Id of team to delete
     */
    deleteTeam(tournamentId: string, teamId: string): Q.Promise<any> {
        return Q.Promise<any>((resolve, reject) => {
            this.deleteTeamWithCallbacks(tournamentId, teamId, (result) => resolve(result), (exception, reason) => reject(exception));
        });
    }
    
    private deleteTeamWithCallbacks(tournamentId: string, teamId: string, onSuccess?: (result: any) => void, onFail?: (exception: string, reason: string) => void) {
        var url = this.baseUrl + "/api/tournaments/{tournamentId:guid}/teams/{teamId:guid}?"; 

        if (tournamentId === undefined || tournamentId === null)
            throw new Error("The parameter 'tournamentId' must be defined.");
        url = url.replace("{tournamentId}", encodeURIComponent("" + tournamentId)); 
        if (teamId === undefined || teamId === null)
            throw new Error("The parameter 'teamId' must be defined.");
        url = url.replace("{teamId}", encodeURIComponent("" + teamId)); 

        var content = "";

        jQuery.ajax({
            url: url,
            beforeSend: this.beforeSend,
            type: "delete",
            data: content,
            dataType: "text",
            headers: {
                "Content-Type": "application/json; charset=UTF-8"
            }
        }).done((data, textStatus, xhr) => {
            this.processDeleteTeamWithCallbacks(url, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processDeleteTeamWithCallbacks(url, xhr, onSuccess, onFail);
        });
    }

    private processDeleteTeamWithCallbacks(url: string, xhr: any, onSuccess?: any, onFail?: any) {
        try {
            var result = this.processDeleteTeam(xhr);
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    private processDeleteTeam(xhr: any) {
        var data = xhr.responseText; 
        var status = xhr.status.toString(); 

        if (status === "200") {
            var result200: any = null; 
            if (data !== undefined && data !== null && data !== "") {
                result200 = data;
            }
            return result200;
        }
        else
        {
            throw new Error("error_no_callback_for_the_received_http_status");
        }
    }

    /**
     * Leave a team and tournament
     * @tournamentId Id of tournament
     */
    leaveTournament(tournamentId: string): Q.Promise<any> {
        return Q.Promise<any>((resolve, reject) => {
            this.leaveTournamentWithCallbacks(tournamentId, (result) => resolve(result), (exception, reason) => reject(exception));
        });
    }
    
    private leaveTournamentWithCallbacks(tournamentId: string, onSuccess?: (result: any) => void, onFail?: (exception: string, reason: string) => void) {
        var url = this.baseUrl + "/api/tournaments/{tournamentId:guid}/teams/me?"; 

        if (tournamentId === undefined || tournamentId === null)
            throw new Error("The parameter 'tournamentId' must be defined.");
        url = url.replace("{tournamentId}", encodeURIComponent("" + tournamentId)); 

        var content = "";

        jQuery.ajax({
            url: url,
            beforeSend: this.beforeSend,
            type: "post",
            data: content,
            dataType: "text",
            headers: {
                "Content-Type": "application/json; charset=UTF-8"
            }
        }).done((data, textStatus, xhr) => {
            this.processLeaveTournamentWithCallbacks(url, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processLeaveTournamentWithCallbacks(url, xhr, onSuccess, onFail);
        });
    }

    private processLeaveTournamentWithCallbacks(url: string, xhr: any, onSuccess?: any, onFail?: any) {
        try {
            var result = this.processLeaveTournament(xhr);
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    private processLeaveTournament(xhr: any) {
        var data = xhr.responseText; 
        var status = xhr.status.toString(); 

        if (status === "200") {
            var result200: any = null; 
            if (data !== undefined && data !== null && data !== "") {
                result200 = data;
            }
            return result200;
        }
        else
        {
            throw new Error("error_no_callback_for_the_received_http_status");
        }
    }
}

export class UserClient {
    baseUrl: string = undefined; 
    beforeSend: any = undefined; 

    constructor(baseUrl?: string) {
        this.baseUrl = baseUrl !== undefined ? baseUrl : ""; 
    }

    /**
     * Find users starting with the given query
     * @query Query to search for
     */
    findUsers(query: string): Q.Promise<UserReference[]> {
        return Q.Promise<UserReference[]>((resolve, reject) => {
            this.findUsersWithCallbacks(query, (result) => resolve(result), (exception, reason) => reject(exception));
        });
    }
    
    private findUsersWithCallbacks(query: string, onSuccess?: (result: UserReference[]) => void, onFail?: (exception: string, reason: string) => void) {
        var url = this.baseUrl + "/api/users/find/{query:minlength(3):maxlength(50)}?"; 

        if (query === undefined || query === null)
            throw new Error("The parameter 'query' must be defined.");
        url = url.replace("{query}", encodeURIComponent("" + query)); 

        var content = "";

        jQuery.ajax({
            url: url,
            beforeSend: this.beforeSend,
            type: "get",
            data: content,
            dataType: "text",
            headers: {
                "Content-Type": "application/json; charset=UTF-8"
            }
        }).done((data, textStatus, xhr) => {
            this.processFindUsersWithCallbacks(url, xhr, onSuccess, onFail);
        }).fail((xhr) => {
            this.processFindUsersWithCallbacks(url, xhr, onSuccess, onFail);
        });
    }

    private processFindUsersWithCallbacks(url: string, xhr: any, onSuccess?: any, onFail?: any) {
        try {
            var result = this.processFindUsers(xhr);
            if (onSuccess !== undefined)
                onSuccess(result);
        } catch (e) {
            if (onFail !== undefined)
                onFail(e, "http_service_exception");
        }
    }

    private processFindUsers(xhr: any) {
        var data = xhr.responseText; 
        var status = xhr.status.toString(); 

        if (status === "200") {
            var result200: UserReference[] = null; 
            if (data !== undefined && data !== null && data !== "") {
                result200 = data === "" ? null : <UserReference[]>jQuery.parseJSON(data);
            }
            return result200;
        }
        else
        {
            throw new Error("error_no_callback_for_the_received_http_status");
        }
    }
}

export interface UserInfo {
    UserId: string;
    UserName: string;
    HasRegistered: boolean;
    LoginProvider: string;
    Language: string;
    Roles: string[];
}

export interface ManageInfoViewModel {
    LocalLoginProvider: string;
    UserName: string;
    Logins: UserLoginInfoViewModel[];
    ExternalLoginProviders: ExternalLoginViewModel[];
}

export interface UserLoginInfoViewModel {
    LoginProvider: string;
    ProviderKey: string;
}

export interface ExternalLoginViewModel {
    Name: string;
    Url: string;
    State: string;
}

export interface ChangePasswordBindingModel {
    OldPassword: string;
    NewPassword: string;
    ConfirmPassword: string;
}

export interface SetPasswordBindingModel {
    NewPassword: string;
    ConfirmPassword: string;
}

export interface LanguageModel {
    Language: string;
}

export interface AddExternalLoginBindingModel {
    ExternalAccessToken: string;
}

export interface RemoveLoginBindingModel {
    LoginProvider: string;
    ProviderKey: string;
}

export interface RegisterBindingModel {
    UserName: string;
    Password: string;
    ConfirmPassword: string;
    Email: string;
    Language: string;
    CallbackUrl: string;
}

export interface ResendConfirmationModel {
    CallbackUrl: string;
    UserName: string;
    Password: string;
    Language: string;
}

export interface ConfirmationModel {
    UserId: string;
    Code: string;
}

export interface ForgotPasswordViewModel {
    CallbackUrl: string;
    UserName: string;
    Email: string;
    Language: string;
}

export interface ResetPasswordViewModel {
    UserId: string;
    Password: string;
    ConfirmPassword: string;
    Code: string;
}

export interface RegisterExternalBindingModel {
    UserName: string;
}

export interface HistoryTurn {
    GameId: number;
    TurnId: number;
    Actions: HistoryEntry[];
    Game: Game;
}

export interface HistoryEntry {
    Id: number;
    TurnNo: number;
    DateTime: Date;
    ActorId: string;
    OtherPlayerId: string;
    Action: HistoryActionAsInteger;
    OriginIdentifier: string;
    DestinationIdentifier: string;
    Units: number;
    UnitsLost: number;
    UnitsLostOther: number;
    Result: boolean;
}

export enum HistoryActionAsInteger {
    None = 0, 
    StartGame = 1, 
    EndGame = 2, 
    PlaceUnits = 3, 
    Attack = 4, 
    Move = 5, 
    ExchangeCards = 6, 
    PlayerLost = 7, 
    PlayerWon = 8, 
    PlayerTimeout = 9, 
    OwnerChange = 10, 
    EndTurn = 11, 
}

export interface Game {
    Id: number;
    Type: GameTypeAsInteger;
    Name: string;
    MapTemplate: string;
    Teams: Team[];
    State: GameStateAsInteger;
    PlayState: PlayStateAsInteger;
    CurrentPlayer: PlayerSummary;
    Map: Map;
    Options: GameOptions;
    LastModifiedAt: Date;
    TimeoutSecondsLeft: number;
    TurnCounter: number;
    UnitsToPlace: number;
    AttacksInCurrentTurn: number;
    MovesInCurrentTurn: number;
}

export enum GameTypeAsInteger {
    Fun = 0, 
    Ranking = 1, 
    Tournament = 2, 
}

export interface Team {
    Id: string;
    PlayOrder: number;
    Players: Player[];
}

export interface PlayerSummary {
    Id: string;
    UserId: string;
    Name: string;
    State: PlayerStateAsInteger;
    Outcome: PlayerOutcomeAsInteger;
    TeamId: string;
    PlayOrder: number;
    Timeouts: number;
}

export interface Player extends PlayerSummary {
    Cards: BonusCardAsInteger[];
    PlacedInitialUnits: boolean;
    NumberOfUnits: number;
    NumberOfCountries: number;
}

export enum BonusCardAsInteger {
    A = 0, 
    B = 1, 
    C = 2, 
}

export enum PlayerStateAsInteger {
    None = 0, 
    Active = 1, 
    InActive = 2, 
}

export enum PlayerOutcomeAsInteger {
    None = 0, 
    Won = 1, 
    Defeated = 2, 
    Surrendered = 3, 
    Timeout = 4, 
}

export enum GameStateAsInteger {
    None = 0, 
    Open = 1, 
    Active = 2, 
    Ended = 3, 
}

export enum PlayStateAsInteger {
    None = 0, 
    PlaceUnits = 1, 
    Attack = 2, 
    Move = 3, 
    Done = 4, 
}

export interface Map {
    Countries: Country[];
}

export interface Country {
    Identifier: string;
    PlayerId: string;
    TeamId: string;
    Units: number;
}

export interface GameOptions {
    NumberOfPlayersPerTeam: number;
    NumberOfTeams: number;
    MinUnitsPerCountry: number;
    NewUnitsPerTurn: number;
    AttacksPerTurn: number;
    MovesPerTurn: number;
    InitialCountryUnits: number;
    MapDistribution: MapDistributionAsInteger;
    TimeoutInSeconds: number;
    MaximumTimeoutsPerPlayer: number;
    MaximumNumberOfCards: number;
    VictoryConditions: VictoryConditionTypeAsInteger[];
    VisibilityModifier: VisibilityModifierTypeAsInteger[];
}

export enum MapDistributionAsInteger {
    Default = 0, 
    Malibu = 1, 
    TeamCluster = 2, 
}

export enum VictoryConditionTypeAsInteger {
    Survival = 0, 
    ControlContinent = 1, 
}

export enum VisibilityModifierTypeAsInteger {
    None = 0, 
    Fog = 1, 
}

export interface LadderSummary {
    Id: string;
    Name: string;
    Options: GameOptions;
    Standing: LadderStanding;
    IsQueued: boolean;
    QueueCount: number;
    MapTemplates: string[];
}

export interface LadderStanding {
    UserId: string;
    UserName: string;
    Position: number;
    GamesPlayed: number;
    GamesWon: number;
    GamesLost: number;
    Rating: number;
    LastGame: Date;
}

export interface Ladder extends LadderSummary {
    Standings: LadderStanding[];
    IsActive: boolean;
}

export interface MapTemplateSummary {
    Id: number;
    Name: string;
    Image: string;
}

export interface MapTemplate {
    Name: string;
    Image: string;
    Countries: CountryTemplate[];
    Connections: Connection[];
    Continents: Continent[];
}

export interface CountryTemplate {
    Identifier: string;
    Name: string;
    X: number;
    Y: number;
}

export interface Connection {
    Origin: string;
    Destination: string;
}

export interface Continent {
    Id: number;
    Name: string;
    Bonus: number;
    Countries: string[];
}

export interface GameSummary {
    Id: number;
    Type: GameTypeAsInteger;
    Name: string;
    LadderId: string;
    LadderName: string;
    Options: GameOptions;
    CreatedByUserId: string;
    CreatedByName: string;
    StartedAt: Date;
    LastActionAt: Date;
    TimeoutSecondsLeft: number;
    MapTemplate: string;
    State: GameStateAsInteger;
    CurrentPlayer: PlayerSummary;
    Teams: TeamSummary[];
}

export interface TeamSummary {
    Id: string;
    PlayOrder: number;
    Players: PlayerSummary[];
}

export interface GameCreationOptions extends GameOptions {
    Name: string;
    AddBot: boolean;
    MapTemplate: string;
}

export enum MessageFolderAsInteger {
    None = 0, 
    Inbox = 1, 
    Sent = 2, 
}

export interface SendMessage {
    To: UserReference;
    Subject: string;
    Text: string;
}

export interface Message extends SendMessage {
    Id: string;
    From: UserReference;
    Folder: MessageFolderAsInteger;
    SentAt: Date;
    IsRead: boolean;
}

export interface UserReference {
    Id: string;
    Name: string;
}

export interface FolderInformation {
    Folder: MessageFolderAsInteger;
    Count: number;
    UnreadCount: number;
}

export interface NewsItem {
    DateTime: Date;
    PostedBy: string;
    Content: NewsContent[];
}

export interface NewsContent {
    Language: string;
    Title: string;
    Text: string;
}

export interface PlaceUnitsOptions {
    CountryIdentifier: string;
    NumberOfUnits: number;
}

export interface GameActionResult {
    Id: number;
    Teams: Team[];
    State: GameStateAsInteger;
    PlayState: PlayStateAsInteger;
    CountryUpdates: Country[];
    ActionResult: ActionResultAsInteger;
    AttacksInCurrentTurn: number;
    MovesInCurrentTurn: number;
    Cards: BonusCardAsInteger[];
    CurrentPlayer: Player;
}

export enum ActionResultAsInteger {
    None = 0, 
    Successful = 1, 
    NotSuccessful = 2, 
}

export interface AttackOptions {
    OriginCountryIdentifier: string;
    DestinationCountryIdentifier: string;
    NumberOfUnits: number;
}

export interface MoveOptions {
    OriginCountryIdentifier: string;
    DestinationCountryIdentifier: string;
    NumberOfUnits: number;
}

export interface TournamentSummary {
    Id: string;
    Name: string;
    State: TournamentStateAsInteger;
    Options: GameOptions;
    NumberOfTeams: number;
    NumberOfGroupGames: number;
    NumberOfKnockoutGames: number;
    NumberOfFinalGames: number;
    StartOfRegistration: Date;
    StartOfTournament: Date;
    EndOfTournament: Date;
    Completion: number;
}

export interface Tournament extends TournamentSummary {
    Teams: TournamentTeam[];
    Groups: TournamentGroup[];
    Pairings: TournamentPairing[];
    MapTemplates: string[];
    Winner: TournamentTeam;
    Phase: number;
}

export interface TournamentTeamSummary {
    Id: string;
    Name: string;
    GroupOrder: number;
    State: TournamentTeamStateAsInteger;
}

export interface TournamentTeam extends TournamentTeamSummary {
    Participants: UserReference[];
}

export enum TournamentTeamStateAsInteger {
    Open = 0, 
    Active = 1, 
    InActive = 2, 
}

export interface TournamentGroup {
    Id: string;
    Teams: TournamentTeamSummary[];
}

export interface TournamentPairing {
    TeamA: TournamentTeamSummary;
    TeamB: TournamentTeamSummary;
    TeamAWon: number;
    TeamBWon: number;
    NumberOfGames: number;
    Phase: number;
    Order: number;
}

export enum TournamentStateAsInteger {
    Open = 0, 
    Groups = 1, 
    Knockout = 2, 
    Closed = 3, 
}