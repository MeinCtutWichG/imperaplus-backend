/* tslint: disable */
//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v6.15.6138.26180 (NJsonSchema v5.5.6138.25231) (http://NSwag.org)
// </auto-generated>
//----------------------

export class AccountClient {
    private baseUrl: string = undefined; 

    constructor(baseUrl?: string) {
        this.baseUrl = baseUrl ? baseUrl : ""; 
    }

    /**
     * @return Success
     */
    token(grant_type: string, username: string, password: string): Promise<LoginResponseModel> {
        let url_ = this.baseUrl + "/api/Account/token"; 

        const content_ = new FormData();
        if (grant_type !== null)
            content_.append("grant_type", grant_type.ToString()));
        if (username !== null)
            content_.append("username", username.ToString()));
        if (password !== null)
            content_.append("password", password.ToString()));
        return fetch(url_, {
			body: content_,
            method: "POST",
            headers: {
                'Content-Type': undefined
            }
        }).then((response) => {
            return this.processToken(response);
        });
    }

    private processToken(response: Response) {
        return response.text().then((data) => {
            const status = response.status.toString(); 

            if (status === "200") {
                let result200: LoginResponseModel = null; 
                result200 = data === "" ? null : <LoginResponseModel>JSON.parse(data);
                return result200; 
            }
            else
            {
                throw "error_no_callback_for_the_received_http_status"; 
            }
        });
    }

    /**
     * Checks if a username is available
     * @userName Username to check
     * @return Success
     */
    userNameAvailable(userName: string): Promise<void> {
        let url_ = this.baseUrl + "/api/Account/UserNameAvailable?"; 

        if (userName !== undefined)
            url_ += "userName=" + encodeURIComponent("" + userName) + "&"; 
        return fetch(url_, {
            method: "GET",
            headers: {
                "Content-Type": "application/json; charset=UTF-8"
            }
        }).then((response) => {
            return this.processUserNameAvailable(response);
        });
    }

    private processUserNameAvailable(response: Response) {
        return response.text().then((data) => {
            const status = response.status.toString(); 

            if (status === "200") {
            }
            else
            {
                throw "error_no_callback_for_the_received_http_status"; 
            }
        });
    }

    /**
     * Get user information
     * @return Success
     */
    userInfo(): Promise<UserInfo> {
        let url_ = this.baseUrl + "/api/Account/UserInfo"; 

        return fetch(url_, {
            method: "GET",
            headers: {
                "Content-Type": "application/json; charset=UTF-8"
            }
        }).then((response) => {
            return this.processUserInfo(response);
        });
    }

    private processUserInfo(response: Response) {
        return response.text().then((data) => {
            const status = response.status.toString(); 

            if (status === "200") {
                let result200: UserInfo = null; 
                result200 = data === "" ? null : <UserInfo>JSON.parse(data);
                return result200; 
            }
            else
            {
                throw "error_no_callback_for_the_received_http_status"; 
            }
        });
    }

    /**
     * Get user information for an external user (i.e., just logged in using an external provider)
     * @return Success
     */
    externalUserInfo(): Promise<UserInfo> {
        let url_ = this.baseUrl + "/api/Account/ExternalUserInfo"; 

        return fetch(url_, {
            method: "GET",
            headers: {
                "Content-Type": "application/json; charset=UTF-8"
            }
        }).then((response) => {
            return this.processExternalUserInfo(response);
        });
    }

    private processExternalUserInfo(response: Response) {
        return response.text().then((data) => {
            const status = response.status.toString(); 

            if (status === "200") {
                let result200: UserInfo = null; 
                result200 = data === "" ? null : <UserInfo>JSON.parse(data);
                return result200; 
            }
            else
            {
                throw "error_no_callback_for_the_received_http_status"; 
            }
        });
    }

    /**
     * @return Success
     */
    logout(): Promise<void> {
        let url_ = this.baseUrl + "/api/Account/Logout"; 

        const content_ = "";
        return fetch(url_, {
			body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json; charset=UTF-8"
            }
        }).then((response) => {
            return this.processLogout(response);
        });
    }

    private processLogout(response: Response) {
        return response.text().then((data) => {
            const status = response.status.toString(); 

            if (status === "200") {
            }
            else
            {
                throw "error_no_callback_for_the_received_http_status"; 
            }
        });
    }

    /**
     * @return Success
     */
    manageInfo(returnUrl: string, generateState: boolean): Promise<ManageInfoViewModel> {
        let url_ = this.baseUrl + "/api/Account/ManageInfo?"; 

        if (returnUrl !== undefined)
            url_ += "returnUrl=" + encodeURIComponent("" + returnUrl) + "&"; 
        if (generateState !== undefined)
            url_ += "generateState=" + encodeURIComponent("" + generateState) + "&"; 
        return fetch(url_, {
            method: "GET",
            headers: {
                "Content-Type": "application/json; charset=UTF-8"
            }
        }).then((response) => {
            return this.processManageInfo(response);
        });
    }

    private processManageInfo(response: Response) {
        return response.text().then((data) => {
            const status = response.status.toString(); 

            if (status === "200") {
                let result200: ManageInfoViewModel = null; 
                result200 = data === "" ? null : <ManageInfoViewModel>JSON.parse(data);
                return result200; 
            }
            else
            {
                throw "error_no_callback_for_the_received_http_status"; 
            }
        });
    }

    /**
     * @return Success
     */
    changePassword(model: ChangePasswordBindingModel): Promise<void> {
        let url_ = this.baseUrl + "/api/Account/ChangePassword"; 

        const content_ = JSON.stringify(model);
        return fetch(url_, {
			body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json; charset=UTF-8"
            }
        }).then((response) => {
            return this.processChangePassword(response);
        });
    }

    private processChangePassword(response: Response) {
        return response.text().then((data) => {
            const status = response.status.toString(); 

            if (status === "200") {
            }
            else
            {
                throw "error_no_callback_for_the_received_http_status"; 
            }
        });
    }

    /**
     * @return Success
     */
    setPassword(model: SetPasswordBindingModel): Promise<void> {
        let url_ = this.baseUrl + "/api/Account/SetPassword"; 

        const content_ = JSON.stringify(model);
        return fetch(url_, {
			body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json; charset=UTF-8"
            }
        }).then((response) => {
            return this.processSetPassword(response);
        });
    }

    private processSetPassword(response: Response) {
        return response.text().then((data) => {
            const status = response.status.toString(); 

            if (status === "200") {
            }
            else
            {
                throw "error_no_callback_for_the_received_http_status"; 
            }
        });
    }

    /**
     * @return Success
     */
    removeLogin(model: RemoveLoginBindingModel): Promise<void> {
        let url_ = this.baseUrl + "/api/Account/RemoveLogin"; 

        const content_ = JSON.stringify(model);
        return fetch(url_, {
			body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json; charset=UTF-8"
            }
        }).then((response) => {
            return this.processRemoveLogin(response);
        });
    }

    private processRemoveLogin(response: Response) {
        return response.text().then((data) => {
            const status = response.status.toString(); 

            if (status === "200") {
            }
            else
            {
                throw "error_no_callback_for_the_received_http_status"; 
            }
        });
    }

    /**
     * @return Success
     */
    externalLogins(returnUrl: string, generateState: boolean): Promise<ExternalLoginViewModel[]> {
        let url_ = this.baseUrl + "/api/Account/ExternalLogins?"; 

        if (returnUrl !== undefined)
            url_ += "returnUrl=" + encodeURIComponent("" + returnUrl) + "&"; 
        if (generateState !== undefined)
            url_ += "generateState=" + encodeURIComponent("" + generateState) + "&"; 
        return fetch(url_, {
            method: "GET",
            headers: {
                "Content-Type": "application/json; charset=UTF-8"
            }
        }).then((response) => {
            return this.processExternalLogins(response);
        });
    }

    private processExternalLogins(response: Response) {
        return response.text().then((data) => {
            const status = response.status.toString(); 

            if (status === "200") {
                let result200: ExternalLoginViewModel[] = null; 
                result200 = data === "" ? null : <ExternalLoginViewModel[]>JSON.parse(data);
                return result200; 
            }
            else
            {
                throw "error_no_callback_for_the_received_http_status"; 
            }
        });
    }

    /**
     * @return Success
     */
    register(model: RegisterBindingModel): Promise<void> {
        let url_ = this.baseUrl + "/api/Account/Register"; 

        const content_ = JSON.stringify(model);
        return fetch(url_, {
			body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json; charset=UTF-8"
            }
        }).then((response) => {
            return this.processRegister(response);
        });
    }

    private processRegister(response: Response) {
        return response.text().then((data) => {
            const status = response.status.toString(); 

            if (status === "200") {
            }
            else
            {
                throw "error_no_callback_for_the_received_http_status"; 
            }
        });
    }

    /**
     * Resend the email confirmation account to the given user account
     * @return Success
     */
    resendConfirmation(model: ResendConfirmationModel): Promise<void> {
        let url_ = this.baseUrl + "/api/Account/ResendConfirmation"; 

        const content_ = JSON.stringify(model);
        return fetch(url_, {
			body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json; charset=UTF-8"
            }
        }).then((response) => {
            return this.processResendConfirmation(response);
        });
    }

    private processResendConfirmation(response: Response) {
        return response.text().then((data) => {
            const status = response.status.toString(); 

            if (status === "200") {
            }
            else
            {
                throw "error_no_callback_for_the_received_http_status"; 
            }
        });
    }

    /**
     * Confirm user account using code provided in mail
     * @model Model containing id and code
     * @return Success
     */
    confirmEmail(model: ConfirmationModel): Promise<void> {
        let url_ = this.baseUrl + "/api/Account/ConfirmEmail"; 

        const content_ = JSON.stringify(model);
        return fetch(url_, {
			body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json; charset=UTF-8"
            }
        }).then((response) => {
            return this.processConfirmEmail(response);
        });
    }

    private processConfirmEmail(response: Response) {
        return response.text().then((data) => {
            const status = response.status.toString(); 

            if (status === "200") {
            }
            else
            {
                throw "error_no_callback_for_the_received_http_status"; 
            }
        });
    }

    /**
     * Request password reset link
     * @return Success
     */
    forgotPassword(model: ForgotPasswordViewModel): Promise<void> {
        let url_ = this.baseUrl + "/api/Account/ForgotPassword"; 

        const content_ = JSON.stringify(model);
        return fetch(url_, {
			body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json; charset=UTF-8"
            }
        }).then((response) => {
            return this.processForgotPassword(response);
        });
    }

    private processForgotPassword(response: Response) {
        return response.text().then((data) => {
            const status = response.status.toString(); 

            if (status === "200") {
            }
            else
            {
                throw "error_no_callback_for_the_received_http_status"; 
            }
        });
    }

    /**
     * Reset password confirmation
     * @return Success
     */
    resetPassword(model: ResetPasswordViewModel): Promise<void> {
        let url_ = this.baseUrl + "/api/Account/ResetPassword"; 

        const content_ = JSON.stringify(model);
        return fetch(url_, {
			body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json; charset=UTF-8"
            }
        }).then((response) => {
            return this.processResetPassword(response);
        });
    }

    private processResetPassword(response: Response) {
        return response.text().then((data) => {
            const status = response.status.toString(); 

            if (status === "200") {
            }
            else
            {
                throw "error_no_callback_for_the_received_http_status"; 
            }
        });
    }

    /**
     * Create user accout for an external login
     * @return Success
     */
    registerExternal(model: RegisterExternalBindingModel): Promise<void> {
        let url_ = this.baseUrl + "/api/Account/RegisterExternal"; 

        const content_ = JSON.stringify(model);
        return fetch(url_, {
			body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json; charset=UTF-8"
            }
        }).then((response) => {
            return this.processRegisterExternal(response);
        });
    }

    private processRegisterExternal(response: Response) {
        return response.text().then((data) => {
            const status = response.status.toString(); 

            if (status === "200") {
            }
            else
            {
                throw "error_no_callback_for_the_received_http_status"; 
            }
        });
    }
}

export class GamesClient {
    private baseUrl: string = undefined; 

    constructor(baseUrl?: string) {
        this.baseUrl = baseUrl ? baseUrl : ""; 
    }

    /**
     * Get a list of open games, excluding games by the current player
     * @return Success
     */
    open(): Promise<GameSummary[]> {
        let url_ = this.baseUrl + "/api/games/open"; 

        return fetch(url_, {
            method: "GET",
            headers: {
                "Content-Type": "application/json; charset=UTF-8"
            }
        }).then((response) => {
            return this.processOpen(response);
        });
    }

    private processOpen(response: Response) {
        return response.text().then((data) => {
            const status = response.status.toString(); 

            if (status === "200") {
                let result200: GameSummary[] = null; 
                result200 = data === "" ? null : <GameSummary[]>JSON.parse(data);
                return result200; 
            }
            else
            {
                throw "error_no_callback_for_the_received_http_status"; 
            }
        });
    }

    /**
     * Get a list of the games for the current player
     * @return Success
     */
    my(): Promise<GameSummary[]> {
        let url_ = this.baseUrl + "/api/games/my"; 

        return fetch(url_, {
            method: "GET",
            headers: {
                "Content-Type": "application/json; charset=UTF-8"
            }
        }).then((response) => {
            return this.processMy(response);
        });
    }

    private processMy(response: Response) {
        return response.text().then((data) => {
            const status = response.status.toString(); 

            if (status === "200") {
                let result200: GameSummary[] = null; 
                result200 = data === "" ? null : <GameSummary[]>JSON.parse(data);
                return result200; 
            }
            else
            {
                throw "error_no_callback_for_the_received_http_status"; 
            }
        });
    }

    /**
     * Get list of games where it's the current player's team
     * @return Success
     */
    myturn(): Promise<GameSummary[]> {
        let url_ = this.baseUrl + "/api/games/myturn"; 

        return fetch(url_, {
            method: "GET",
            headers: {
                "Content-Type": "application/json; charset=UTF-8"
            }
        }).then((response) => {
            return this.processMyturn(response);
        });
    }

    private processMyturn(response: Response) {
        return response.text().then((data) => {
            const status = response.status.toString(); 

            if (status === "200") {
                let result200: GameSummary[] = null; 
                result200 = data === "" ? null : <GameSummary[]>JSON.parse(data);
                return result200; 
            }
            else
            {
                throw "error_no_callback_for_the_received_http_status"; 
            }
        });
    }

    /**
     * Get messages for a single game
     * @gameId Id of the requested game
     * @isPublic Value indicating whether to return only public messages, default is true
     * @return Success
     */
    messages(gameId: number, isPublic: boolean): Promise<Game> {
        let url_ = this.baseUrl + "/api/games/{gameId}/messages?"; 

        if (gameId === undefined || gameId === null)
            throw new Error("The parameter 'gameId' must be defined.");
        url_ = url_.replace("{gameId}", encodeURIComponent("" + gameId)); 

        if (isPublic !== undefined)
            url_ += "isPublic=" + encodeURIComponent("" + isPublic) + "&"; 
        return fetch(url_, {
            method: "GET",
            headers: {
                "Content-Type": "application/json; charset=UTF-8"
            }
        }).then((response) => {
            return this.processMessages(response);
        });
    }

    private processMessages(response: Response) {
        return response.text().then((data) => {
            const status = response.status.toString(); 

            if (status === "200") {
                let result200: Game = null; 
                result200 = data === "" ? null : <Game>JSON.parse(data);
                return result200; 
            }
            else
            {
                throw "error_no_callback_for_the_received_http_status"; 
            }
        });
    }

    /**
     * Join the given game
     * @gameId Id of game to join
     * @return Success
     */
    join(gameId: number): Promise<void> {
        let url_ = this.baseUrl + "/api/games/{gameId}/join"; 

        if (gameId === undefined || gameId === null)
            throw new Error("The parameter 'gameId' must be defined.");
        url_ = url_.replace("{gameId}", encodeURIComponent("" + gameId)); 

        const content_ = "";
        return fetch(url_, {
			body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json; charset=UTF-8"
            }
        }).then((response) => {
            return this.processJoin(response);
        });
    }

    private processJoin(response: Response) {
        return response.text().then((data) => {
            const status = response.status.toString(); 

            if (status === "200") {
            }
            else
            {
                throw "error_no_callback_for_the_received_http_status"; 
            }
        });
    }

    /**
     * Leave the given game, only possible if game hasn't started yet, and current player
is not the creator.
     * @gameId Id of game to leave
     * @return Success
     */
    leave(gameId: number): Promise<void> {
        let url_ = this.baseUrl + "/api/games/{gameId}/leave"; 

        if (gameId === undefined || gameId === null)
            throw new Error("The parameter 'gameId' must be defined.");
        url_ = url_.replace("{gameId}", encodeURIComponent("" + gameId)); 

        const content_ = "";
        return fetch(url_, {
			body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json; charset=UTF-8"
            }
        }).then((response) => {
            return this.processLeave(response);
        });
    }

    private processLeave(response: Response) {
        return response.text().then((data) => {
            const status = response.status.toString(); 

            if (status === "200") {
            }
            else
            {
                throw "error_no_callback_for_the_received_http_status"; 
            }
        });
    }

    /**
     * Surrender in the given game, only possible if current player
and game are still active.
     * @gameId Id of game to surrender in
     * @return Success
     */
    surrender(gameId: number): Promise<GameSummary> {
        let url_ = this.baseUrl + "/api/games/{gameId}/surrender"; 

        if (gameId === undefined || gameId === null)
            throw new Error("The parameter 'gameId' must be defined.");
        url_ = url_.replace("{gameId}", encodeURIComponent("" + gameId)); 

        const content_ = "";
        return fetch(url_, {
			body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json; charset=UTF-8"
            }
        }).then((response) => {
            return this.processSurrender(response);
        });
    }

    private processSurrender(response: Response) {
        return response.text().then((data) => {
            const status = response.status.toString(); 

            if (status === "200") {
                let result200: GameSummary = null; 
                result200 = data === "" ? null : <GameSummary>JSON.parse(data);
                return result200; 
            }
            else
            {
                throw "error_no_callback_for_the_received_http_status"; 
            }
        });
    }

    /**
     * Hides the given game for the current player
     * @gameId Id of game to hide
     * @return Success
     */
    hide(gameId: number): Promise<void> {
        let url_ = this.baseUrl + "/api/games/{gameId}/hide"; 

        if (gameId === undefined || gameId === null)
            throw new Error("The parameter 'gameId' must be defined.");
        url_ = url_.replace("{gameId}", encodeURIComponent("" + gameId)); 

        const content_ = "";
        return fetch(url_, {
			body: content_,
            method: "PATCH",
            headers: {
                "Content-Type": "application/json; charset=UTF-8"
            }
        }).then((response) => {
            return this.processHide(response);
        });
    }

    private processHide(response: Response) {
        return response.text().then((data) => {
            const status = response.status.toString(); 

            if (status === "200") {
            }
            else
            {
                throw "error_no_callback_for_the_received_http_status"; 
            }
        });
    }

    /**
     * Hide all games which can be hidden for the current player
     * @return Success
     */
    hide(): Promise<void> {
        let url_ = this.baseUrl + "/api/games/hide"; 

        const content_ = "";
        return fetch(url_, {
			body: content_,
            method: "PATCH",
            headers: {
                "Content-Type": "application/json; charset=UTF-8"
            }
        }).then((response) => {
            return this.processHide(response);
        });
    }

    private processHide(response: Response) {
        return response.text().then((data) => {
            const status = response.status.toString(); 

            if (status === "200") {
            }
            else
            {
                throw "error_no_callback_for_the_received_http_status"; 
            }
        });
    }

    /**
     * Gets the specified turn including the actions and current state of the map
     * @return Success
     */
    history(gameId: number, turnId: number): Promise<HistoryTurn> {
        let url_ = this.baseUrl + "/api/games/{gameId}/history/{turnId}"; 

        if (gameId === undefined || gameId === null)
            throw new Error("The parameter 'gameId' must be defined.");
        url_ = url_.replace("{gameId}", encodeURIComponent("" + gameId)); 
        if (turnId === undefined || turnId === null)
            throw new Error("The parameter 'turnId' must be defined.");
        url_ = url_.replace("{turnId}", encodeURIComponent("" + turnId)); 

        return fetch(url_, {
            method: "GET",
            headers: {
                "Content-Type": "application/json; charset=UTF-8"
            }
        }).then((response) => {
            return this.processHistory(response);
        });
    }

    private processHistory(response: Response) {
        return response.text().then((data) => {
            const status = response.status.toString(); 

            if (status === "200") {
                let result200: HistoryTurn = null; 
                result200 = data === "" ? null : <HistoryTurn>JSON.parse(data);
                return result200; 
            }
            else
            {
                throw "error_no_callback_for_the_received_http_status"; 
            }
        });
    }
}

export class ApiClient {
    private baseUrl: string = undefined; 

    constructor(baseUrl?: string) {
        this.baseUrl = baseUrl ? baseUrl : ""; 
    }

    /**
     * Create a new game
     * @creationOptions Creation options
     * @return Success
     */
    games(creationOptions: GameCreationOptions): Promise<GameSummary> {
        let url_ = this.baseUrl + "/api/games"; 

        const content_ = JSON.stringify(creationOptions);
        return fetch(url_, {
			body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json; charset=UTF-8"
            }
        }).then((response) => {
            return this.processGames(response);
        });
    }

    private processGames(response: Response) {
        return response.text().then((data) => {
            const status = response.status.toString(); 

            if (status === "200") {
                let result200: GameSummary = null; 
                result200 = data === "" ? null : <GameSummary>JSON.parse(data);
                return result200; 
            }
            else
            {
                throw "error_no_callback_for_the_received_http_status"; 
            }
        });
    }

    /**
     * Get detailed information about a single game
     * @gameId Id of the requested game
     * @return Success
     */
    games(gameId: number): Promise<Game> {
        let url_ = this.baseUrl + "/api/games/{gameId}"; 

        if (gameId === undefined || gameId === null)
            throw new Error("The parameter 'gameId' must be defined.");
        url_ = url_.replace("{gameId}", encodeURIComponent("" + gameId)); 

        return fetch(url_, {
            method: "GET",
            headers: {
                "Content-Type": "application/json; charset=UTF-8"
            }
        }).then((response) => {
            return this.processGames(response);
        });
    }

    private processGames(response: Response) {
        return response.text().then((data) => {
            const status = response.status.toString(); 

            if (status === "200") {
                let result200: Game = null; 
                result200 = data === "" ? null : <Game>JSON.parse(data);
                return result200; 
            }
            else
            {
                throw "error_no_callback_for_the_received_http_status"; 
            }
        });
    }

    /**
     * Cancel/delete the requested game, if possible.
     * @gameId Id of the game to delete
     * @return Success
     */
    games(gameId: number): Promise<void> {
        let url_ = this.baseUrl + "/api/games/{gameId}"; 

        if (gameId === undefined || gameId === null)
            throw new Error("The parameter 'gameId' must be defined.");
        url_ = url_.replace("{gameId}", encodeURIComponent("" + gameId)); 

        const content_ = "";
        return fetch(url_, {
			body: content_,
            method: "DELETE",
            headers: {
                "Content-Type": "application/json; charset=UTF-8"
            }
        }).then((response) => {
            return this.processGames(response);
        });
    }

    private processGames(response: Response) {
        return response.text().then((data) => {
            const status = response.status.toString(); 

            if (status === "200") {
            }
            else
            {
                throw "error_no_callback_for_the_received_http_status"; 
            }
        });
    }

    /**
     * Returns active ladders
     * @return Success
     */
    ladder(): Promise<LadderSummary[]> {
        let url_ = this.baseUrl + "/api/ladder"; 

        return fetch(url_, {
            method: "GET",
            headers: {
                "Content-Type": "application/json; charset=UTF-8"
            }
        }).then((response) => {
            return this.processLadder(response);
        });
    }

    private processLadder(response: Response) {
        return response.text().then((data) => {
            const status = response.status.toString(); 

            if (status === "200") {
                let result200: LadderSummary[] = null; 
                result200 = data === "" ? null : <LadderSummary[]>JSON.parse(data);
                return result200; 
            }
            else
            {
                throw "error_no_callback_for_the_received_http_status"; 
            }
        });
    }

    /**
     * Gets ladder identified by given id
     * @ladderId Id of ladder
     * @return Success
     */
    ladder(ladderId: string): Promise<Ladder> {
        let url_ = this.baseUrl + "/api/ladder/{ladderId}"; 

        if (ladderId === undefined || ladderId === null)
            throw new Error("The parameter 'ladderId' must be defined.");
        url_ = url_.replace("{ladderId}", encodeURIComponent("" + ladderId)); 

        return fetch(url_, {
            method: "GET",
            headers: {
                "Content-Type": "application/json; charset=UTF-8"
            }
        }).then((response) => {
            return this.processLadder(response);
        });
    }

    private processLadder(response: Response) {
        return response.text().then((data) => {
            const status = response.status.toString(); 

            if (status === "200") {
                let result200: Ladder = null; 
                result200 = data === "" ? null : <Ladder>JSON.parse(data);
                return result200; 
            }
            else
            {
                throw "error_no_callback_for_the_received_http_status"; 
            }
        });
    }

    /**
     * @return Success
     */
    map(): Promise<MapTemplateDescriptor[]> {
        let url_ = this.baseUrl + "/api/map"; 

        return fetch(url_, {
            method: "GET",
            headers: {
                "Content-Type": "application/json; charset=UTF-8"
            }
        }).then((response) => {
            return this.processMap(response);
        });
    }

    private processMap(response: Response) {
        return response.text().then((data) => {
            const status = response.status.toString(); 

            if (status === "200") {
                let result200: MapTemplateDescriptor[] = null; 
                result200 = data === "" ? null : <MapTemplateDescriptor[]>JSON.parse(data);
                return result200; 
            }
            else
            {
                throw "error_no_callback_for_the_received_http_status"; 
            }
        });
    }

    /**
     * Get map template identified by name
     * @return Success
     */
    map(name: string): Promise<MapTemplate> {
        let url_ = this.baseUrl + "/api/map/{name}"; 

        if (name === undefined || name === null)
            throw new Error("The parameter 'name' must be defined.");
        url_ = url_.replace("{name}", encodeURIComponent("" + name)); 

        return fetch(url_, {
            method: "GET",
            headers: {
                "Content-Type": "application/json; charset=UTF-8"
            }
        }).then((response) => {
            return this.processMap(response);
        });
    }

    private processMap(response: Response) {
        return response.text().then((data) => {
            const status = response.status.toString(); 

            if (status === "200") {
                let result200: MapTemplate = null; 
                result200 = data === "" ? null : <MapTemplate>JSON.parse(data);
                return result200; 
            }
            else
            {
                throw "error_no_callback_for_the_received_http_status"; 
            }
        });
    }

    /**
     * @return Success
     */
    messages(messageId: string): Promise<Message> {
        let url_ = this.baseUrl + "/api/messages/{messageId}"; 

        if (messageId === undefined || messageId === null)
            throw new Error("The parameter 'messageId' must be defined.");
        url_ = url_.replace("{messageId}", encodeURIComponent("" + messageId)); 

        return fetch(url_, {
            method: "GET",
            headers: {
                "Content-Type": "application/json; charset=UTF-8"
            }
        }).then((response) => {
            return this.processMessages(response);
        });
    }

    private processMessages(response: Response) {
        return response.text().then((data) => {
            const status = response.status.toString(); 

            if (status === "200") {
                let result200: Message = null; 
                result200 = data === "" ? null : <Message>JSON.parse(data);
                return result200; 
            }
            else
            {
                throw "error_no_callback_for_the_received_http_status"; 
            }
        });
    }

    /**
     * @return Success
     */
    messages(messageId: string): Promise<void> {
        let url_ = this.baseUrl + "/api/messages/{messageId}"; 

        if (messageId === undefined || messageId === null)
            throw new Error("The parameter 'messageId' must be defined.");
        url_ = url_.replace("{messageId}", encodeURIComponent("" + messageId)); 

        const content_ = "";
        return fetch(url_, {
			body: content_,
            method: "DELETE",
            headers: {
                "Content-Type": "application/json; charset=UTF-8"
            }
        }).then((response) => {
            return this.processMessages(response);
        });
    }

    private processMessages(response: Response) {
        return response.text().then((data) => {
            const status = response.status.toString(); 

            if (status === "200") {
            }
            else
            {
                throw "error_no_callback_for_the_received_http_status"; 
            }
        });
    }

    /**
     * @return Success
     */
    messages(messageId: string): Promise<void> {
        let url_ = this.baseUrl + "/api/messages/{messageId}"; 

        if (messageId === undefined || messageId === null)
            throw new Error("The parameter 'messageId' must be defined.");
        url_ = url_.replace("{messageId}", encodeURIComponent("" + messageId)); 

        const content_ = "";
        return fetch(url_, {
			body: content_,
            method: "PATCH",
            headers: {
                "Content-Type": "application/json; charset=UTF-8"
            }
        }).then((response) => {
            return this.processMessages(response);
        });
    }

    private processMessages(response: Response) {
        return response.text().then((data) => {
            const status = response.status.toString(); 

            if (status === "200") {
            }
            else
            {
                throw "error_no_callback_for_the_received_http_status"; 
            }
        });
    }

    /**
     * @return Success
     */
    messages(message: SendMessage): Promise<void> {
        let url_ = this.baseUrl + "/api/messages"; 

        const content_ = JSON.stringify(message);
        return fetch(url_, {
			body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json; charset=UTF-8"
            }
        }).then((response) => {
            return this.processMessages(response);
        });
    }

    private processMessages(response: Response) {
        return response.text().then((data) => {
            const status = response.status.toString(); 

            if (status === "200") {
            }
            else
            {
                throw "error_no_callback_for_the_received_http_status"; 
            }
        });
    }

    /**
     * Returns the last 10 news items for all languages
     * @return Success
     */
    news(): Promise<NewsItem[]> {
        let url_ = this.baseUrl + "/api/news"; 

        return fetch(url_, {
            method: "GET",
            headers: {
                "Content-Type": "application/json; charset=UTF-8"
            }
        }).then((response) => {
            return this.processNews(response);
        });
    }

    private processNews(response: Response) {
        return response.text().then((data) => {
            const status = response.status.toString(); 

            if (status === "200") {
                let result200: NewsItem[] = null; 
                result200 = data === "" ? null : <NewsItem[]>JSON.parse(data);
                return result200; 
            }
            else
            {
                throw "error_no_callback_for_the_received_http_status"; 
            }
        });
    }

    /**
     * Returns tournaments
     * @return Success
     */
    tournaments(): Promise<Tournament[]> {
        let url_ = this.baseUrl + "/api/tournaments"; 

        return fetch(url_, {
            method: "GET",
            headers: {
                "Content-Type": "application/json; charset=UTF-8"
            }
        }).then((response) => {
            return this.processTournaments(response);
        });
    }

    private processTournaments(response: Response) {
        return response.text().then((data) => {
            const status = response.status.toString(); 

            if (status === "200") {
                let result200: Tournament[] = null; 
                result200 = data === "" ? null : <Tournament[]>JSON.parse(data);
                return result200; 
            }
            else
            {
                throw "error_no_callback_for_the_received_http_status"; 
            }
        });
    }

    /**
     * Get tournament identified by Id
     * @tournamentId Id of tournament
     * @return Success
     */
    tournaments(tournamentId: string): Promise<Tournament> {
        let url_ = this.baseUrl + "/api/tournaments/{tournamentId}"; 

        if (tournamentId === undefined || tournamentId === null)
            throw new Error("The parameter 'tournamentId' must be defined.");
        url_ = url_.replace("{tournamentId}", encodeURIComponent("" + tournamentId)); 

        return fetch(url_, {
            method: "GET",
            headers: {
                "Content-Type": "application/json; charset=UTF-8"
            }
        }).then((response) => {
            return this.processTournaments(response);
        });
    }

    private processTournaments(response: Response) {
        return response.text().then((data) => {
            const status = response.status.toString(); 

            if (status === "200") {
                let result200: Tournament = null; 
                result200 = data === "" ? null : <Tournament>JSON.parse(data);
                return result200; 
            }
            else
            {
                throw "error_no_callback_for_the_received_http_status"; 
            }
        });
    }

    /**
     * Join tournament
     * @tournamentId Id of tournament
     * @return Success
     */
    tournaments(tournamentId: string): Promise<TournamentTeam> {
        let url_ = this.baseUrl + "/api/tournaments/{tournamentId}"; 

        if (tournamentId === undefined || tournamentId === null)
            throw new Error("The parameter 'tournamentId' must be defined.");
        url_ = url_.replace("{tournamentId}", encodeURIComponent("" + tournamentId)); 

        const content_ = "";
        return fetch(url_, {
			body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json; charset=UTF-8"
            }
        }).then((response) => {
            return this.processTournaments(response);
        });
    }

    private processTournaments(response: Response) {
        return response.text().then((data) => {
            const status = response.status.toString(); 

            if (status === "200") {
                let result200: TournamentTeam = null; 
                result200 = data === "" ? null : <TournamentTeam>JSON.parse(data);
                return result200; 
            }
            else
            {
                throw "error_no_callback_for_the_received_http_status"; 
            }
        });
    }
}

export class LadderClient {
    private baseUrl: string = undefined; 

    constructor(baseUrl?: string) {
        this.baseUrl = baseUrl ? baseUrl : ""; 
    }

    /**
     * Queue up for a new game in the given ladder
     * @ladderId Ladder id
     * @return Success
     */
    queue(ladderId: string): Promise<void> {
        let url_ = this.baseUrl + "/api/ladder/{ladderId}/queue"; 

        if (ladderId === undefined || ladderId === null)
            throw new Error("The parameter 'ladderId' must be defined.");
        url_ = url_.replace("{ladderId}", encodeURIComponent("" + ladderId)); 

        const content_ = "";
        return fetch(url_, {
			body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json; charset=UTF-8"
            }
        }).then((response) => {
            return this.processQueue(response);
        });
    }

    private processQueue(response: Response) {
        return response.text().then((data) => {
            const status = response.status.toString(); 

            if (status === "200") {
            }
            else
            {
                throw "error_no_callback_for_the_received_http_status"; 
            }
        });
    }

    /**
     * Gets ladder standings
     * @ladderId Id of ladder
     * @start Items to skip before returning
     * @count Count of standings to return
     * @return Success
     */
    standings(ladderId: string, start: number, count: number): Promise<LadderStanding[]> {
        let url_ = this.baseUrl + "/api/ladder/{ladderId}/standings?"; 

        if (ladderId === undefined || ladderId === null)
            throw new Error("The parameter 'ladderId' must be defined.");
        url_ = url_.replace("{ladderId}", encodeURIComponent("" + ladderId)); 

        if (start !== undefined)
            url_ += "start=" + encodeURIComponent("" + start) + "&"; 
        if (count !== undefined)
            url_ += "count=" + encodeURIComponent("" + count) + "&"; 
        return fetch(url_, {
            method: "GET",
            headers: {
                "Content-Type": "application/json; charset=UTF-8"
            }
        }).then((response) => {
            return this.processStandings(response);
        });
    }

    private processStandings(response: Response) {
        return response.text().then((data) => {
            const status = response.status.toString(); 

            if (status === "200") {
                let result200: LadderStanding[] = null; 
                result200 = data === "" ? null : <LadderStanding[]>JSON.parse(data);
                return result200; 
            }
            else
            {
                throw "error_no_callback_for_the_received_http_status"; 
            }
        });
    }
}

export class MessagesClient {
    private baseUrl: string = undefined; 

    constructor(baseUrl?: string) {
        this.baseUrl = baseUrl ? baseUrl : ""; 
    }

    /**
     * @return Success
     */
    folder(messageFolder: MessageFolder, folder: string): Promise<Message[]> {
        let url_ = this.baseUrl + "/api/messages/folder/{folder}?"; 

        if (folder === undefined || folder === null)
            throw new Error("The parameter 'folder' must be defined.");
        url_ = url_.replace("{folder}", encodeURIComponent("" + folder)); 

        if (messageFolder !== undefined)
            url_ += "messageFolder=" + encodeURIComponent("" + messageFolder) + "&"; 
        return fetch(url_, {
            method: "GET",
            headers: {
                "Content-Type": "application/json; charset=UTF-8"
            }
        }).then((response) => {
            return this.processFolder(response);
        });
    }

    private processFolder(response: Response) {
        return response.text().then((data) => {
            const status = response.status.toString(); 

            if (status === "200") {
                let result200: Message[] = null; 
                result200 = data === "" ? null : <Message[]>JSON.parse(data);
                return result200; 
            }
            else
            {
                throw "error_no_callback_for_the_received_http_status"; 
            }
        });
    }

    /**
     * @return Success
     */
    folders(): Promise<FolderInformation> {
        let url_ = this.baseUrl + "/api/messages/folders"; 

        return fetch(url_, {
            method: "GET",
            headers: {
                "Content-Type": "application/json; charset=UTF-8"
            }
        }).then((response) => {
            return this.processFolders(response);
        });
    }

    private processFolders(response: Response) {
        return response.text().then((data) => {
            const status = response.status.toString(); 

            if (status === "200") {
                let result200: FolderInformation = null; 
                result200 = data === "" ? null : <FolderInformation>JSON.parse(data);
                return result200; 
            }
            else
            {
                throw "error_no_callback_for_the_received_http_status"; 
            }
        });
    }
}

export class NotificationsClient {
    private baseUrl: string = undefined; 

    constructor(baseUrl?: string) {
        this.baseUrl = baseUrl ? baseUrl : ""; 
    }

    /**
     * Get notification summary for current user
     * @return Success
     */
    summary(): Promise<void> {
        let url_ = this.baseUrl + "/api/notifications/summary"; 

        return fetch(url_, {
            method: "GET",
            headers: {
                "Content-Type": "application/json; charset=UTF-8"
            }
        }).then((response) => {
            return this.processSummary(response);
        });
    }

    private processSummary(response: Response) {
        return response.text().then((data) => {
            const status = response.status.toString(); 

            if (status === "200") {
            }
            else
            {
                throw "error_no_callback_for_the_received_http_status"; 
            }
        });
    }
}

export class PlayClient {
    private baseUrl: string = undefined; 

    constructor(baseUrl?: string) {
        this.baseUrl = baseUrl ? baseUrl : ""; 
    }

    /**
     * Place units to countries.
     * @gameId Id of the game
     * @placeUnitsOptions List of country/unit count pairs
     * @return Success
     */
    place(gameId: number, placeUnitsOptions: PlaceUnitsOptions[]): Promise<GameActionResult> {
        let url_ = this.baseUrl + "/api/games/{gameId}/play/place"; 

        if (gameId === undefined || gameId === null)
            throw new Error("The parameter 'gameId' must be defined.");
        url_ = url_.replace("{gameId}", encodeURIComponent("" + gameId)); 

        const content_ = JSON.stringify(placeUnitsOptions);
        return fetch(url_, {
			body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json; charset=UTF-8"
            }
        }).then((response) => {
            return this.processPlace(response);
        });
    }

    private processPlace(response: Response) {
        return response.text().then((data) => {
            const status = response.status.toString(); 

            if (status === "200") {
                let result200: GameActionResult = null; 
                result200 = data === "" ? null : <GameActionResult>JSON.parse(data);
                return result200; 
            }
            else
            {
                throw "error_no_callback_for_the_received_http_status"; 
            }
        });
    }

    /**
     * Exchange cards for the current player. Which cards to exchange is automatically chosen to gain the most bonus for the player.
     * @gameId Id of the game
     * @return Success
     */
    exchange(gameId: number): Promise<GameActionResult> {
        let url_ = this.baseUrl + "/api/games/{gameId}/play/exchange"; 

        if (gameId === undefined || gameId === null)
            throw new Error("The parameter 'gameId' must be defined.");
        url_ = url_.replace("{gameId}", encodeURIComponent("" + gameId)); 

        const content_ = "";
        return fetch(url_, {
			body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json; charset=UTF-8"
            }
        }).then((response) => {
            return this.processExchange(response);
        });
    }

    private processExchange(response: Response) {
        return response.text().then((data) => {
            const status = response.status.toString(); 

            if (status === "200") {
                let result200: GameActionResult = null; 
                result200 = data === "" ? null : <GameActionResult>JSON.parse(data);
                return result200; 
            }
            else
            {
                throw "error_no_callback_for_the_received_http_status"; 
            }
        });
    }

    /**
     * Attack from one to another country.
     * @gameId Id of the game
     * @options Options for the command
     * @return Success
     */
    attack(gameId: number, options: AttackOptions): Promise<GameActionResult> {
        let url_ = this.baseUrl + "/api/games/{gameId}/play/attack"; 

        if (gameId === undefined || gameId === null)
            throw new Error("The parameter 'gameId' must be defined.");
        url_ = url_.replace("{gameId}", encodeURIComponent("" + gameId)); 

        const content_ = JSON.stringify(options);
        return fetch(url_, {
			body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json; charset=UTF-8"
            }
        }).then((response) => {
            return this.processAttack(response);
        });
    }

    private processAttack(response: Response) {
        return response.text().then((data) => {
            const status = response.status.toString(); 

            if (status === "200") {
                let result200: GameActionResult = null; 
                result200 = data === "" ? null : <GameActionResult>JSON.parse(data);
                return result200; 
            }
            else
            {
                throw "error_no_callback_for_the_received_http_status"; 
            }
        });
    }

    /**
     * Switch to moving.
     * @gameId Id of the game
     * @return Success
     */
    endattack(gameId: number): Promise<GameActionResult> {
        let url_ = this.baseUrl + "/api/games/{gameId}/play/endattack"; 

        if (gameId === undefined || gameId === null)
            throw new Error("The parameter 'gameId' must be defined.");
        url_ = url_.replace("{gameId}", encodeURIComponent("" + gameId)); 

        const content_ = "";
        return fetch(url_, {
			body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json; charset=UTF-8"
            }
        }).then((response) => {
            return this.processEndattack(response);
        });
    }

    private processEndattack(response: Response) {
        return response.text().then((data) => {
            const status = response.status.toString(); 

            if (status === "200") {
                let result200: GameActionResult = null; 
                result200 = data === "" ? null : <GameActionResult>JSON.parse(data);
                return result200; 
            }
            else
            {
                throw "error_no_callback_for_the_received_http_status"; 
            }
        });
    }

    /**
     * Move units between countries. Only allowed after placing. Cancels any attacks that the player had left before. Attacking is not
possible anymore after moving.
     * @gameId Id of the game
     * @options Options for the command
     * @return Success
     */
    move(gameId: number, options: MoveOptions): Promise<GameActionResult> {
        let url_ = this.baseUrl + "/api/games/{gameId}/play/move"; 

        if (gameId === undefined || gameId === null)
            throw new Error("The parameter 'gameId' must be defined.");
        url_ = url_.replace("{gameId}", encodeURIComponent("" + gameId)); 

        const content_ = JSON.stringify(options);
        return fetch(url_, {
			body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json; charset=UTF-8"
            }
        }).then((response) => {
            return this.processMove(response);
        });
    }

    private processMove(response: Response) {
        return response.text().then((data) => {
            const status = response.status.toString(); 

            if (status === "200") {
                let result200: GameActionResult = null; 
                result200 = data === "" ? null : <GameActionResult>JSON.parse(data);
                return result200; 
            }
            else
            {
                throw "error_no_callback_for_the_received_http_status"; 
            }
        });
    }

    /**
     * End the current turn
     * @gameId Id of the game
     * @return Success
     */
    endturn(gameId: number): Promise<Game> {
        let url_ = this.baseUrl + "/api/games/{gameId}/play/endturn"; 

        if (gameId === undefined || gameId === null)
            throw new Error("The parameter 'gameId' must be defined.");
        url_ = url_.replace("{gameId}", encodeURIComponent("" + gameId)); 

        const content_ = "";
        return fetch(url_, {
			body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json; charset=UTF-8"
            }
        }).then((response) => {
            return this.processEndturn(response);
        });
    }

    private processEndturn(response: Response) {
        return response.text().then((data) => {
            const status = response.status.toString(); 

            if (status === "200") {
                let result200: Game = null; 
                result200 = data === "" ? null : <Game>JSON.parse(data);
                return result200; 
            }
            else
            {
                throw "error_no_callback_for_the_received_http_status"; 
            }
        });
    }
}

export class TournamentsClient {
    private baseUrl: string = undefined; 

    constructor(baseUrl?: string) {
        this.baseUrl = baseUrl ? baseUrl : ""; 
    }

    /**
     * Get teams for tournament
     * @tournamentId Id of tournament
     * @return Success
     */
    teams(tournamentId: string): Promise<TournamentTeam[]> {
        let url_ = this.baseUrl + "/api/tournaments/{tournamentId}/teams"; 

        if (tournamentId === undefined || tournamentId === null)
            throw new Error("The parameter 'tournamentId' must be defined.");
        url_ = url_.replace("{tournamentId}", encodeURIComponent("" + tournamentId)); 

        return fetch(url_, {
            method: "GET",
            headers: {
                "Content-Type": "application/json; charset=UTF-8"
            }
        }).then((response) => {
            return this.processTeams(response);
        });
    }

    private processTeams(response: Response) {
        return response.text().then((data) => {
            const status = response.status.toString(); 

            if (status === "200") {
                let result200: TournamentTeam[] = null; 
                result200 = data === "" ? null : <TournamentTeam[]>JSON.parse(data);
                return result200; 
            }
            else
            {
                throw "error_no_callback_for_the_received_http_status"; 
            }
        });
    }

    /**
     * Create new team for a tournament
     * @tournamentId Id of tournament
     * @name Name of team
     * @password Optional password for team
     * @return Success
     */
    teams(tournamentId: string, name: string, password: string): Promise<TournamentTeamSummary> {
        let url_ = this.baseUrl + "/api/tournaments/{tournamentId}/teams?"; 

        if (tournamentId === undefined || tournamentId === null)
            throw new Error("The parameter 'tournamentId' must be defined.");
        url_ = url_.replace("{tournamentId}", encodeURIComponent("" + tournamentId)); 

        if (name !== undefined)
            url_ += "name=" + encodeURIComponent("" + name) + "&"; 
        if (password !== undefined)
            url_ += "password=" + encodeURIComponent("" + password) + "&"; 
        const content_ = "";
        return fetch(url_, {
			body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json; charset=UTF-8"
            }
        }).then((response) => {
            return this.processTeams(response);
        });
    }

    private processTeams(response: Response) {
        return response.text().then((data) => {
            const status = response.status.toString(); 

            if (status === "200") {
                let result200: TournamentTeamSummary = null; 
                result200 = data === "" ? null : <TournamentTeamSummary>JSON.parse(data);
                return result200; 
            }
            else
            {
                throw "error_no_callback_for_the_received_http_status"; 
            }
        });
    }

    /**
     * Join existing team
     * @tournamentId Id of tournament
     * @teamId Id of team
     * @password Optional password for team to join
     * @return Success
     */
    teams(tournamentId: string, teamId: string, password: string): Promise<void> {
        let url_ = this.baseUrl + "/api/tournaments/{tournamentId}/teams/{teamId}?"; 

        if (tournamentId === undefined || tournamentId === null)
            throw new Error("The parameter 'tournamentId' must be defined.");
        url_ = url_.replace("{tournamentId}", encodeURIComponent("" + tournamentId)); 
        if (teamId === undefined || teamId === null)
            throw new Error("The parameter 'teamId' must be defined.");
        url_ = url_.replace("{teamId}", encodeURIComponent("" + teamId)); 

        if (password !== undefined)
            url_ += "password=" + encodeURIComponent("" + password) + "&"; 
        const content_ = "";
        return fetch(url_, {
			body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json; charset=UTF-8"
            }
        }).then((response) => {
            return this.processTeams(response);
        });
    }

    private processTeams(response: Response) {
        return response.text().then((data) => {
            const status = response.status.toString(); 

            if (status === "200") {
            }
            else
            {
                throw "error_no_callback_for_the_received_http_status"; 
            }
        });
    }

    /**
     * Delete a team. Only allowed if user created it
     * @tournamentId Id of tournament
     * @teamId Id of team to delete
     * @return Success
     */
    teams(tournamentId: string, teamId: string): Promise<void> {
        let url_ = this.baseUrl + "/api/tournaments/{tournamentId}/teams/{teamId}"; 

        if (tournamentId === undefined || tournamentId === null)
            throw new Error("The parameter 'tournamentId' must be defined.");
        url_ = url_.replace("{tournamentId}", encodeURIComponent("" + tournamentId)); 
        if (teamId === undefined || teamId === null)
            throw new Error("The parameter 'teamId' must be defined.");
        url_ = url_.replace("{teamId}", encodeURIComponent("" + teamId)); 

        const content_ = "";
        return fetch(url_, {
			body: content_,
            method: "DELETE",
            headers: {
                "Content-Type": "application/json; charset=UTF-8"
            }
        }).then((response) => {
            return this.processTeams(response);
        });
    }

    private processTeams(response: Response) {
        return response.text().then((data) => {
            const status = response.status.toString(); 

            if (status === "200") {
            }
            else
            {
                throw "error_no_callback_for_the_received_http_status"; 
            }
        });
    }
}

export class TeamsClient {
    private baseUrl: string = undefined; 

    constructor(baseUrl?: string) {
        this.baseUrl = baseUrl ? baseUrl : ""; 
    }

    /**
     * Leave a team and tournament
     * @tournamentId Id of tournament
     * @return Success
     */
    me(tournamentId: string): Promise<void> {
        let url_ = this.baseUrl + "/api/tournaments/{tournamentId}/teams/me"; 

        if (tournamentId === undefined || tournamentId === null)
            throw new Error("The parameter 'tournamentId' must be defined.");
        url_ = url_.replace("{tournamentId}", encodeURIComponent("" + tournamentId)); 

        const content_ = "";
        return fetch(url_, {
			body: content_,
            method: "DELETE",
            headers: {
                "Content-Type": "application/json; charset=UTF-8"
            }
        }).then((response) => {
            return this.processMe(response);
        });
    }

    private processMe(response: Response) {
        return response.text().then((data) => {
            const status = response.status.toString(); 

            if (status === "200") {
            }
            else
            {
                throw "error_no_callback_for_the_received_http_status"; 
            }
        });
    }
}

export class UsersClient {
    private baseUrl: string = undefined; 

    constructor(baseUrl?: string) {
        this.baseUrl = baseUrl ? baseUrl : ""; 
    }

    /**
     * Find users starting with the given query
     * @query Query to search for
     * @return Success
     */
    find(query: string): Promise<UserReference[]> {
        let url_ = this.baseUrl + "/api/users/find/{query}"; 

        if (query === undefined || query === null)
            throw new Error("The parameter 'query' must be defined.");
        url_ = url_.replace("{query}", encodeURIComponent("" + query)); 

        return fetch(url_, {
            method: "GET",
            headers: {
                "Content-Type": "application/json; charset=UTF-8"
            }
        }).then((response) => {
            return this.processFind(response);
        });
    }

    private processFind(response: Response) {
        return response.text().then((data) => {
            const status = response.status.toString(); 

            if (status === "200") {
                let result200: UserReference[] = null; 
                result200 = data === "" ? null : <UserReference[]>JSON.parse(data);
                return result200; 
            }
            else
            {
                throw "error_no_callback_for_the_received_http_status"; 
            }
        });
    }
}

export interface LoginResponseModel {
    access_token: string;
    userId: string;
    userName: string;
    language: string;
    roles: string;
}

export interface UserInfo {
    userId: string;
    userName: string;
    hasRegistered: boolean;
    loginProvider: string;
    language: string;
    roles: string[];
}

export interface ManageInfoViewModel {
    localLoginProvider: string;
    userName: string;
    logins: UserLoginInfoViewModel[];
    externalLoginProviders: ExternalLoginViewModel[];
}

export interface UserLoginInfoViewModel {
    loginProvider: string;
    providerKey: string;
}

export interface ExternalLoginViewModel {
    name: string;
    url: string;
    state: string;
}

export interface ChangePasswordBindingModel {
    oldPassword: string;
    newPassword: string;
    confirmPassword: string;
}

export interface SetPasswordBindingModel {
    newPassword: string;
    confirmPassword: string;
}

export interface RemoveLoginBindingModel {
    loginProvider: string;
    providerKey: string;
}

export interface RegisterBindingModel {
    userName: string;
    password: string;
    confirmPassword: string;
    email: string;
    language: string;
    callbackUrl: string;
}

export interface ResendConfirmationModel {
    callbackUrl: string;
    userName: string;
    password: string;
    language: string;
}

export interface ConfirmationModel {
    userId: string;
    code: string;
}

export interface ForgotPasswordViewModel {
    callbackUrl: string;
    userName: string;
    email: string;
    language: string;
}

export interface ResetPasswordViewModel {
    userId: string;
    password: string;
    confirmPassword: string;
    code: string;
}

export interface RegisterExternalBindingModel {
    userName: string;
    email: string;
}

export interface GameSummary {
    id: number;
    type: GameSummaryType;
    name: string;
    ladderId: string;
    ladderName: string;
    options: GameOptions;
    createdByUserId: string;
    createdByName: string;
    startedAt: Date;
    lastActionAt: Date;
    timeoutSecondsLeft: number;
    mapTemplate: string;
    state: GameSummaryState;
    currentPlayer: PlayerSummary;
    teams: TeamSummary[];
}

export interface GameOptions {
    numberOfPlayersPerTeam: number;
    numberOfTeams: number;
    minUnitsPerCountry: number;
    newUnitsPerTurn: number;
    attacksPerTurn: number;
    movesPerTurn: number;
    initialCountryUnits: number;
    mapDistribution: GameOptionsMapDistribution;
    timeoutInSeconds: number;
    maximumTimeoutsPerPlayer: number;
    maximumNumberOfCards: number;
    victoryConditions: VictoryConditions[];
    visibilityModifier: VisibilityModifier[];
}

export interface PlayerSummary {
    id: string;
    userId: string;
    name: string;
    state: PlayerSummaryState;
    outcome: PlayerSummaryOutcome;
    teamId: string;
    playOrder: number;
    timeouts: number;
}

export interface TeamSummary {
    id: string;
    playOrder: number;
    players: PlayerSummary[];
}

export interface GameCreationOptions {
    name: string;
    addBot: boolean;
    mapTemplate: string;
    numberOfPlayersPerTeam: number;
    numberOfTeams: number;
    minUnitsPerCountry: number;
    newUnitsPerTurn: number;
    attacksPerTurn: number;
    movesPerTurn: number;
    initialCountryUnits: number;
    mapDistribution: GameCreationOptionsMapDistribution;
    timeoutInSeconds: number;
    maximumTimeoutsPerPlayer: number;
    maximumNumberOfCards: number;
    victoryConditions: VictoryConditions[];
    visibilityModifier: VisibilityModifier[];
}

export interface Game {
    id: number;
    type: GameType;
    name: string;
    mapTemplate: string;
    teams: Team[];
    state: GameState;
    playState: GamePlayState;
    currentPlayer: PlayerSummary;
    map: Map;
    options: GameOptions;
    lastModifiedAt: Date;
    timeoutSecondsLeft: number;
    turnCounter: number;
    unitsToPlace: number;
    attacksInCurrentTurn: number;
    movesInCurrentTurn: number;
}

export interface Team {
    id: string;
    playOrder: number;
    players: Player[];
}

export interface Map {
    countries: Country[];
}

export interface Player {
    cards: Cards[];
    placedInitialUnits: boolean;
    numberOfUnits: number;
    numberOfCountries: number;
    id: string;
    userId: string;
    name: string;
    state: PlayerState;
    outcome: PlayerOutcome;
    teamId: string;
    playOrder: number;
    timeouts: number;
}

export interface Country {
    identifier: string;
    playerId: string;
    teamId: string;
    units: number;
}

export interface HistoryTurn {
    gameId: number;
    turnId: number;
    actions: HistoryEntry[];
    game: Game;
}

export interface HistoryEntry {
    id: number;
    turnNo: number;
    dateTime: Date;
    actorId: string;
    otherPlayerId: string;
    readonly action: HistoryEntryAction;
    originIdentifier: string;
    destinationIdentifier: string;
    units: number;
    unitsLost: number;
    unitsLostOther: number;
    result: boolean;
}

export interface LadderSummary {
    id: string;
    name: string;
    options: GameOptions;
    standing: LadderStanding;
    isQueued: boolean;
    queueCount: number;
    mapTemplates: string[];
}

export interface LadderStanding {
    userId: string;
    userName: string;
    position: number;
    gamesPlayed: number;
    gamesWon: number;
    gamesLost: number;
    rating: number;
    lastGame: Date;
}

export interface Ladder {
    standings: LadderStanding[];
    isActive: boolean;
    id: string;
    name: string;
    options: GameOptions;
    standing: LadderStanding;
    isQueued: boolean;
    queueCount: number;
    mapTemplates: string[];
}

export interface MapTemplateDescriptor {
    name: string;
}

export interface MapTemplate {
    name: string;
    image: string;
    countries: CountryTemplate[];
    connections: Connection[];
    continents: Continent[];
}

export interface CountryTemplate {
    identifier: string;
    name: string;
    x: number;
    y: number;
}

export interface Connection {
    origin: string;
    destination: string;
}

export interface Continent {
    id: number;
    name: string;
    bonus: number;
    countries: string[];
}

export interface Message {
    id: string;
    from: UserReference;
    folder: MessageFolder2;
    sentAt: Date;
    isRead: boolean;
    to: UserReference;
    subject: string;
    text: string;
}

export interface UserReference {
    id: string;
    name: string;
}

export interface FolderInformation {
    folder: FolderInformationFolder;
    count: number;
    unreadCount: number;
}

export interface SendMessage {
    to: UserReference;
    subject: string;
    text: string;
}

export interface NewsItem {
    dateTime: Date;
    postedBy: string;
    content: NewsContent[];
}

export interface NewsContent {
    language: string;
    title: string;
    text: string;
}

export interface PlaceUnitsOptions {
    countryIdentifier: string;
    numberOfUnits: number;
}

export interface GameActionResult {
    id: number;
    teams: Team[];
    state: GameActionResultState;
    playState: GameActionResultPlayState;
    countryUpdates: Country[];
    actionResult: GameActionResultActionResult;
    attacksInCurrentTurn: number;
    movesInCurrentTurn: number;
    cards: Cards[];
    currentPlayer: Player;
}

export interface AttackOptions {
    originCountryIdentifier: string;
    destinationCountryIdentifier: string;
    numberOfUnits: number;
}

export interface MoveOptions {
    originCountryIdentifier: string;
    destinationCountryIdentifier: string;
    numberOfUnits: number;
}

export interface Tournament {
    teams: TournamentTeam[];
    groups: TournamentGroup[];
    pairings: TournamentPairing[];
    mapTemplates: string[];
    winner: TournamentTeam;
    phase: number;
    id: string;
    name: string;
    state: TournamentState;
    options: GameOptions;
    numberOfTeams: number;
    numberOfGroupGames: number;
    numberOfKnockoutGames: number;
    numberOfFinalGames: number;
    startOfRegistration: Date;
    startOfTournament: Date;
    endOfTournament: Date;
    completion: number;
}

export interface TournamentTeam {
    participants: UserReference[];
    id: string;
    name: string;
    groupOrder: number;
    state: TournamentTeamState;
}

export interface TournamentGroup {
    id: string;
    teams: TournamentTeamSummary[];
}

export interface TournamentPairing {
    teamA: TournamentTeamSummary;
    teamB: TournamentTeamSummary;
    teamAWon: number;
    teamBWon: number;
    numberOfGames: number;
    phase: number;
    order: number;
}

export interface TournamentTeamSummary {
    id: string;
    name: string;
    groupOrder: number;
    state: TournamentTeamSummaryState;
}

export enum MessageFolder {
    None = <any>"none", 
    Inbox = <any>"inbox", 
    Sent = <any>"sent", 
}

export enum GameSummaryType {
    Fun = <any>"fun", 
    Ranking = <any>"ranking", 
    Tournament = <any>"tournament", 
}

export enum GameSummaryState {
    None = <any>"none", 
    Open = <any>"open", 
    Active = <any>"active", 
    Ended = <any>"ended", 
}

export enum GameOptionsMapDistribution {
    Default = <any>"default", 
    Malibu = <any>"malibu", 
    TeamCluster = <any>"teamCluster", 
}

export enum VictoryConditions {
    Survival = <any>"survival", 
    ControlContinent = <any>"controlContinent", 
}

export enum VisibilityModifier {
    None = <any>"none", 
    Fog = <any>"fog", 
}

export enum PlayerSummaryState {
    None = <any>"none", 
    Active = <any>"active", 
    InActive = <any>"inActive", 
}

export enum PlayerSummaryOutcome {
    None = <any>"none", 
    Won = <any>"won", 
    Defeated = <any>"defeated", 
    Surrendered = <any>"surrendered", 
    Timeout = <any>"timeout", 
}

export enum GameCreationOptionsMapDistribution {
    Default = <any>"default", 
    Malibu = <any>"malibu", 
    TeamCluster = <any>"teamCluster", 
}

export enum GameType {
    Fun = <any>"fun", 
    Ranking = <any>"ranking", 
    Tournament = <any>"tournament", 
}

export enum GameState {
    None = <any>"none", 
    Open = <any>"open", 
    Active = <any>"active", 
    Ended = <any>"ended", 
}

export enum GamePlayState {
    None = <any>"none", 
    PlaceUnits = <any>"placeUnits", 
    Attack = <any>"attack", 
    Move = <any>"move", 
    Done = <any>"done", 
}

export enum Cards {
    A = <any>"a", 
    B = <any>"b", 
    C = <any>"c", 
}

export enum PlayerState {
    None = <any>"none", 
    Active = <any>"active", 
    InActive = <any>"inActive", 
}

export enum PlayerOutcome {
    None = <any>"none", 
    Won = <any>"won", 
    Defeated = <any>"defeated", 
    Surrendered = <any>"surrendered", 
    Timeout = <any>"timeout", 
}

export enum HistoryEntryAction {
    None = <any>"none", 
    StartGame = <any>"startGame", 
    EndGame = <any>"endGame", 
    PlaceUnits = <any>"placeUnits", 
    Attack = <any>"attack", 
    Move = <any>"move", 
    ExchangeCards = <any>"exchangeCards", 
    PlayerLost = <any>"playerLost", 
    PlayerWon = <any>"playerWon", 
    PlayerTimeout = <any>"playerTimeout", 
    OwnerChange = <any>"ownerChange", 
    EndTurn = <any>"endTurn", 
}

export enum MessageFolder2 {
    None = <any>"none", 
    Inbox = <any>"inbox", 
    Sent = <any>"sent", 
}

export enum FolderInformationFolder {
    None = <any>"none", 
    Inbox = <any>"inbox", 
    Sent = <any>"sent", 
}

export enum GameActionResultState {
    None = <any>"none", 
    Open = <any>"open", 
    Active = <any>"active", 
    Ended = <any>"ended", 
}

export enum GameActionResultPlayState {
    None = <any>"none", 
    PlaceUnits = <any>"placeUnits", 
    Attack = <any>"attack", 
    Move = <any>"move", 
    Done = <any>"done", 
}

export enum GameActionResultActionResult {
    None = <any>"none", 
    Successful = <any>"successful", 
    NotSuccessful = <any>"notSuccessful", 
}

export enum TournamentState {
    Open = <any>"open", 
    Groups = <any>"groups", 
    Knockout = <any>"knockout", 
    Closed = <any>"closed", 
}

export enum TournamentTeamState {
    Open = <any>"open", 
    Active = <any>"active", 
    InActive = <any>"inActive", 
}

export enum TournamentTeamSummaryState {
    Open = <any>"open", 
    Active = <any>"active", 
    InActive = <any>"inActive", 
}